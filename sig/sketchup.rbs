# The UI module contains a number of methods for creating simple UI elements
# from a SketchUp Ruby script.
# 
# @version SketchUp 6.0
module UI
  # The add_context_menu_handler method is used to register a block of code with
  # SketchUp that will be called when a context menu is to be displayed. The
  # context menu handler can then display the context menu with the items that
  # you have added.
  # 
  # Be careful with what you do in a context menu handler. If you perform an
  # operation takes take a long time, such as traversing the model or selection
  # in a large model it will delay the menu.
  # 
  # See the contextmenu.rb script in the Plugins/examples directory for an
  # example.
  # 
  # _@return_ — the number of context handlers that are
  # registered
  # 
  # ```ruby
  # # Right click on anything to see a Hello World item.
  # UI.add_context_menu_handler do |context_menu|
  #   context_menu.add_item("Hello World") {
  #     UI.messagebox("Hello world")
  #   }
  # end
  # ```
  def self.add_context_menu_handler: () -> Integer

  # The beep method plays a system beep sound.
  # 
  # The beep method does not accept any arguments nor return any values.
  # 
  # ```ruby
  # UI.beep
  # ```
  def self.beep: () -> void

  # The create_cursor method is used to create a cursor from an image file at
  # the specified location. This must be called from within a custom
  # Tool. See the Tool class for a complete example.
  # 
  # Since SketchUp 2016 it is possible to provide vector images for the cursors.
  # SVG format for Windows and PDF format for OS X.
  # 
  # _@param_ `path` — File path to an image.
  # 
  # _@param_ `hot_x` — An x coordinate that is the "hotpoint" for the cursor computed from the left edge of your cursor image.
  # 
  # _@param_ `hot_y` — A y coordinate that is the "hotpoint" for the cursor computed from the top edge of the of your cursor image. For example, a value of (hot_x, hot_y) = (5,10) would identify the hotpoint of the cursor at 5 pixels from the left edge of your cursor image and 10 pixels from the top edge of your cursor image.
  # 
  # _@return_ — ID associated with the cursor
  # 
  # ```ruby
  # cursor_id = nil
  # cursor_path = Sketchup.find_support_file("Pointer.png", "Plugins/")
  # if cursor_path
  #   cursor_id = UI.create_cursor(cursor_path, 0, 0)
  # end
  # 
  # def onSetCursor
  #   UI.set_cursor(cursor_id)
  # end
  # ```
  def self.create_cursor: (String path, Integer hot_x, Integer hot_y) -> Integer

  # sord omit - no YARD type given for "*args", using untyped
  # Creates a dialog box for inputting user information. The dialog box contains
  # input fields with static text prompts, optional default values, optional
  # drop down selections, and optional title.
  # 
  # You can also use this method to display drop down lists of options, by
  # passing an optional param.
  # 
  # _@return_ — An array of returned values if the user did
  # not cancel the dialog.  If the user canceled the
  # dialog, false is returned.  The returned values in the
  # array will be in the same order as the input fields.
  # 
  # ```ruby
  # # With three params, it shows all text boxes:
  # prompts = ["What is your Name?", "What is your Age?", "Gender"]
  # defaults = ["Enter name", "", "Male"]
  # input = UI.inputbox(prompts, defaults, "Tell me about yourself.")
  # 
  # # With four params, it shows a drop down box for prompts that have
  # # pipe-delimited lists of options. In this case, the Gender prompt
  # # is a drop down instead of a text box.
  # prompts = ["What is your Name?", "What is your Age?", "Gender"]
  # defaults = ["Enter name", "", "Male"]
  # list = ["", "", "Male|Female"]
  # input = UI.inputbox(prompts, defaults, list, "Tell me about yourself.")
  # ```
  def self.inputbox: (*untyped args) -> (::Array[String] | bool)

  # The {.inspector_names} method is used to returns the names of all the
  # inspectors. Inspectors are another name for the various floating dialog
  # windows that you can activate from withing SketchUp, such as the Materials
  # window.
  # 
  # _@return_ — an array of strings containing the names
  # of inspectors.
  # 
  # ```ruby
  # inspectors = UI.inspector_names
  # ```
  def self.inspector_names: () -> ::Array[String]

  # The {.menu} method retrieves a SketchUp's menu object with a given name. This
  # is the first step toward adding your own custom items to the bottom
  # of SketchUp's menus.
  # 
  # Valid menu names are: "File", "Edit", "View", "Camera", "Draw", "Tools",
  # "Window", "Extensions", "Help" and "Developer".
  # 
  # _@param_ `menu_name` — The name of an existing top level menu.
  # 
  # ```ruby
  # tool_menu = UI.menu("Tools")
  # tool_menu.add_item("Cheese Tool") {
  #   UI.messagebox("Cheese activated.")
  # }
  # ```
  # 
  # _@note_ — The "Extensions" menu was named "Plugins" prior to SketchUp 2015.
  # For backward compatibility "Plugins" still works.
  # 
  # _@note_ — In versions prior to SketchUp 2018 this would crash if you passed an
  # empty string.
  def self.menu: (?untyped menu_name) -> Sketchup::Menu

  # Creates a dialog box containing static text with a series of buttons for
  # the user to choose from.
  # 
  # Valid message box types are:
  # - +MB_OK+ - Contains an OK button.
  # - +MB_OKCANCEL+ - Contains OK and Cancel buttons.
  # - +MB_ABORTRETRYIGNORE+ - Contains Abort, Retry, and Ignore buttons.
  # - +MB_YESNOCANCEL+ - Contains Yes, No, and Cancel buttons.
  # - +MB_YESNO+ - Contains Yes and No buttons.
  # - +MB_RETRYCANCEL+ - Contains Retry and Cancel buttons.
  # - +MB_MULTILINE+ - Contains and OK button.
  # 
  # Return values can be any of following:
  # - +IDOK+
  # - +IDCANCEL+
  # - +IDABORT+
  # - +IDRETRY+
  # - +IDIGNORE+
  # - +IDYES+
  # - +IDNO+
  # 
  # In an +MB_MULTILINE+ message box, the message is displayed as a multi-line
  # message with scrollbars (as needed). +MB_MULTILNE+ also allows a third string
  # argument that will be used as the title for the messagebox.
  # 
  # _@param_ `message` — The message that you want to display.
  # 
  # _@param_ `type` — The message box type, which will be a constant from the list in the method comments.
  # 
  # _@return_ — A number corresponding to what the user selected.
  # 
  # ```ruby
  # result = UI.messagebox('Do you like cheese?', MB_YESNO)
  # if result == IDYES
  #   UI.messagebox('SketchUp likes cheese too!')
  # end
  # ```
  def self.messagebox: (String message, ?Integer _type) -> Integer

  # The model_info_pages method is used to returns the names of all the
  # available model info pages. These include UI windows such as Components,
  # Credits, and Units.
  # 
  # _@return_ — an array of strings containing the names of
  # model info pages.
  # 
  # ```ruby
  # mypages = UI.model_info_pages
  # ```
  def self.model_info_pages: () -> ::Array[String]

  # The {.openURL} method is used to open the default browser to a URL.
  # 
  # _@param_ `url`
  # 
  # ```ruby
  # status = UI.openURL("http://www.sketchup.com")
  # ```
  def self.openURL: (String url) -> bool

  # The {.openpanel} method is used to display the Open dialog box. The path that
  # is returned can then be used inside code to open a text or image file.
  # See the standard Ruby class File for examples of reading and writing from
  # disk.
  # 
  # _@param_ `title` — The title to apply to the open dialog box.
  # 
  # _@param_ `directory` — The default directory for the open panel.
  # 
  # _@param_ `filename` — The default filename for the open panel. On Windows, you can alternatively pass a wildcard filter using this format: UIname|wildcard||. Additional filter dropdown list items can be added by adding additional pairs of filter name and filter like this: UIname1|wildcard1|UIname2|wildcard2||. Also multiple wildcard filters can be combined into a single line using a semicolon-separated list in the filter field: ui_name|wildcard1;wildcard2||.
  # 
  # _@return_ — the full path and name of the file selected, or
  # nil if the dialog was canceled.
  # 
  # ```ruby
  # chosen_image = UI.openpanel("Open SKP File", "c:/", "model.skp")
  # chosen_image = UI.openpanel("Open Image File", "c:/", "Image Files|*.jpg;*.png;||")
  # chosen_image = UI.openpanel("Open CAD File", "c:/", "DXF|*.dxf|DWG|*.dwg||")
  # ```
  # 
  # _@see_ `UI.savepanel`
  def self.openpanel: (String title, String directory, String filename) -> String

  # The play_sound method is used to play a sound file. Valid sound files include
  # .wav and .mp3 files on the Mac and .wav files on the PC.
  # 
  # _@param_ `filename` — the relative path to the filename from the SketchUp install directory, or an absolute path to the file. (See Sketchup.find_support_file for a way to search for a specific file.)
  # 
  # ```ruby
  # UI.play_sound "Plugins/mediadiscussion.wav"
  # ```
  def self.play_sound: (String filename) -> void

  # The preferences_pages method is used to returns the names of all the
  # preferences pages. These include windows like Templates.
  # 
  # [SketchUp 2017] <code>"Extensions"</code> page was removed.
  # 
  # _@return_ — an array of strings containing the names
  # of preference pages.
  # 
  # ```ruby
  # prefs = UI.preferences_pages
  # ```
  def self.preferences_pages: () -> ::Array[String]

  # Tells SketchUp to refresh all inspectors such as the Component Browser and
  # the Outliner. This is useful when you need to manually force a refresh after
  # you've made a change to the document via Ruby. Generally, SketchUp will keep
  # these in sync for you, but occasionally it does not, such as when
  # model.start_operation has disabled UI updates.
  # 
  # ```ruby
  # UI.refresh_inspectors
  # ```
  def self.refresh_inspectors: () -> void

  # Tells SketchUp to refresh all floating toolbars. This is useful when you need
  # to manually force a refresh after you've made a change to the document via
  # Ruby. Generally, SketchUp will keep these in sync for you, but occasionally
  # it does not, such as when {Sketchup::Model#start_operation} has disabled UI
  # updates.
  # This only affects macOS, on Windows the toolbars are always refreshing.
  # 
  # ```ruby
  # UI.refresh_toolbars
  # ```
  def self.refresh_toolbars: () -> void

  # The {.savepanel} method is used to display the Save dialog box. The path that
  # is returned can then be used inside code to save out a text or image file.
  # See the standard Ruby class File for examples of reading and writing from
  # disk.
  # 
  # _@param_ `title` — The title to apply to the save dialog box.
  # 
  # _@param_ `directory` — The default directory for the save panel.
  # 
  # _@param_ `filename` — The default filename for the save panel. On Windows, you can alternatively pass a mask, like "*.txt", to have all the .txt files display. If you want multiple file types to display, you can supply multiple masks for the filename and separate them with a semicolon, like this: "*.txt;*.doc".
  # 
  # _@return_ — the full path and name of the file
  # selected or nil if the dialog was canceled.
  # 
  # ```ruby
  # path_to_save_to = UI.savepanel("Save Image File", "c:\\", "Shapes.jpg")
  # ```
  # 
  # _@see_ `UI.openpanel`
  def self.savepanel: (String title, String directory, String filename) -> String

  # Returns the scaling factor SketchUp uses on high DPI monitors. Useful for
  # things like {Sketchup::View#draw2d}.
  # 
  # ```ruby
  # # Scale a set of points representing 2d screen points to account for high
  # # DPI monitors.
  # points2d = [
  #   Geom::Point3d.new(0, 0, 0),
  #   Geom::Point3d.new(8, 0, 0),
  #   Geom::Point3d.new(8, 4, 0),
  #   Geom::Point3d.new(0, 4, 0)
  # ]
  # tr = Geom::Transformation.scaling(UI.scale_factor)
  # points2d.each { |point| point.transform!(tr)
  # ```
  # 
  # _@note_ — SU2017M0 will automatically scale up line width and text size, but will
  # not scale up the points provided to {Sketchup::View#draw2d}.
  def self.scale_factor: () -> Float

  # The {.select_directory} method is used to display the OS dialog for selecting
  # one or several directories from the file system.
  # 
  # _@param_ `options` — The dialog can be customized by providing a hash or named arguments of options.
  # 
  # _@return_ — A string with the full path of the
  # directory selected when
  # :select_multiple option is set to
  # false otherwise an array of strings
  # or nil if the user cancelled.
  # 
  # ```ruby
  # # Default title and folder:
  # chosen_folder = UI.select_directory
  # 
  # # Custom dialog title:
  # chosen_folder = UI.select_directory(title: "Select Image Directory")
  # 
  # # Force a start folder:
  # chosen_folder = UI.select_directory(directory: "C:/images")
  # 
  # # Allow multiple items to the selected:
  # chosen_folder = UI.select_directory(select_multiple: true)
  # 
  # # Custom dialog title and force a start folder:
  # chosen_folder = UI.select_directory(
  #   title: "Select Image Directory",
  #   directory: "C:/images"
  # )
  # ```
  def self.select_directory: (?::Hash[untyped, untyped] options) -> (String | ::Array[String])?

  # The {.set_cursor} method is used to change the cursor to a new cursor with a
  # given cursor id. See UI.create_cursor and the Tool class for details
  # on creating your own tools with arbitrary cursors.
  # 
  # If you call this while a standard SketchUp tool is active, you will not
  # see your custom cursor, as these tools are constantly setting their
  # own cursors to indicate SketchUp's state.
  # 
  # _@param_ `cursor_id` — The id of the cursor you want to display.
  # 
  # ```ruby
  # def onSetCursor
  #   UI.set_cursor(cursor_id)
  # end
  # ```
  def self.set_cursor: (Integer cursor_id) -> bool

  # The set_toolbar_visible method is used to set whether a given toolbar is
  # visible.  Note that the toolbars and their names are different on the
  # Mac vs. PC, so be careful and be sure to test when using this method in a
  # cross-platform script.
  # 
  # _@param_ `name` — The name of a Ruby toolbar.
  # 
  # _@param_ `visible` — True to make the toolbar visible, false to hide it.
  # 
  # _@return_ — true if successful, false if not.
  # 
  # ```ruby
  # status = UI.set_toolbar_visible("Camera", true)
  # ```
  def self.set_toolbar_visible: (String name, bool visible) -> bool

  # The +show_extension_manager+ method is used to display the Extension Manager
  # dialog.
  # 
  # ```ruby
  # UI.show_extension_manager
  # ```
  def self.show_extension_manager: () -> void

  # The {.show_inspector} method is used to display the inspector with the given
  # name. You can get the list of valid inspectors with UI.inspector_names.
  # 
  # _@param_ `name` — The name of inspector that you want to display.
  # 
  # _@return_ — true if successful, false if unsuccessful
  # 
  # ```ruby
  # status = UI.show_inspector("Components")
  # ```
  def self.show_inspector: (String name) -> bool

  # The {.show_model_info} method is used to display the model info dialog for a
  # specific page. You can get the list of valid page names with {UI.model_info_pages}.
  # 
  # [SketchUp 2014] <code>"Classifications"</code> page was added.
  # 
  # _@param_ `page_name` — The name of the model info dialog you want to display.
  # 
  # ```ruby
  # UI.show_model_info('Credits')
  # ```
  def self.show_model_info: (String page_name) -> bool

  # The show_preferences method is used to display a SketchUp preferences dialog.
  # You can get the list of valid dialogs with {UI.preferences_pages}.
  # 
  # _@param_ `page_name` — The name of the preferences dialog you want to display.
  # 
  # _@return_ — true
  # 
  # ```ruby
  # status = UI.show_preferences('GraphicsCard')
  # ```
  def self.show_preferences: (String page_name) -> bool

  # The start_timer method is used to start a timer. This is an effective method
  # to create a repeating snippet of code for arbitrary animation.
  # 
  # See this blog post for an detailed example of custom animation using timers:
  # http://sketchupapi.blogspot.com/2008/10/animate-yo-cheese.html
  # 
  # Note that there is a bug that if you open a modal window in a non-repeating
  # timer the timer will repeat until the window is closed.
  # 
  # _@param_ `seconds` — The time in seconds before your code should be called.
  # 
  # _@param_ `repeat` — true if you want the timer to repeat, false (or omit) if you do not want it to repeat.
  # 
  # _@return_ — a timer ID
  # 
  # ```ruby
  # # Beep once after 10 seconds.
  # id = UI.start_timer(10, false) { UI.beep }
  # ```
  def self.start_timer: (Numeric seconds, ?bool repeat) -> Integer

  # The stop_timer method is used to stop a timer based on its id.
  # 
  # _@param_ `id` — The timer id for the timer that you want to stop.
  # 
  # ```ruby
  # # Stop timer before it triggers.
  # id = UI.start_timer(10) { UI.beep }
  # UI.stop_timer(id)
  # ```
  def self.stop_timer: (Integer id) -> void

  # The toolbar method is used to get a Ruby toolbar by name. If the toolbar
  # doesn't exist a new one will be created.
  # 
  # _@param_ `name` — The name of the Ruby toolbar.
  # 
  # _@return_ — a Toolbar object
  # 
  # ```ruby
  # toolbar = UI.toolbar('Test')
  # ```
  def self.toolbar: (String name) -> UI::Toolbar

  # The toolbar_names method is used to return the name of all the available
  # native toolbars (this differs between PC and Mac). These toolbar names
  # do not include Ruby toolbars.
  # 
  # _@return_ — Array of strings representing toolbar names.
  # 
  # ```ruby
  # names = UI.toolbar_names
  # ```
  def self.toolbar_names: () -> ::Array[String]

  # The toolbar_visible? method is used to determine whether a given toolbar is
  # visible. Note that the toolbars and their names are different on the
  # Mac vs. PC, so be careful and be sure to test when using this method in a
  # cross-platform script.
  # 
  # _@param_ `name` — The name of a native toolbar.
  # 
  # ```ruby
  # status = UI.toolbar_visible?("Camera")
  # ```
  def self.toolbar_visible?: (String name) -> bool

  # The Command class is the preferred class for adding tools to the menus and
  # Ruby toolbars. For example, you could add a menu item and pass it a code
  # block directly, or you could first create a Command.
  # 
  # Using Commands gives you greater control over how the item works in the UI,
  # and it allows multiple spots in the UI to call the same code. For example,
  # You might want a toolbar button and a context-click menu item to both point
  # to the same command, and to control the tooltip and its "graying" from
  # a single spot in your code.
  # 
  # @example
  #   # You can add menu items as procedure blocks, as shown here, but
  #   # you have no control over whether it is grayed out, for example.
  #   UI.menu("Draw").add_item("My Procedure") {
  #     UI.messagebox("My Procedure")
  #   }
  # 
  #   # Better to create a command object.
  #   cmd = UI::Command.new("Tester") {
  #     UI.messagebox("My Command")
  #   }
  #   cmd.menu_text = "My Command"
  #   cmd.set_validation_proc {
  #     if Sketchup.active_model.selection.length == 0
  #       MF_GRAYED
  #     else
  #       MF_ENABLED
  #     end
  #   }
  #   UI.menu("Draw").add_item cmd
  # 
  # @version SketchUp 6.0
  class Command
    # The new method is used to create a new command.
    # 
    # _@param_ `menutext` — The text that will appear for this command's menu item if it appears on a menu.
    # 
    # _@return_ — the new Command object
    # 
    # ```ruby
    # UI.menu("Draw").add_separator
    # 
    # # Adds a Test submenu to the Draw menu where the Tester menu item appears
    # testmenu = UI.menu("Draw").add_submenu("Test")
    # 
    # # This menu item simply displays Hello World on the screen when clicked.
    # cmd = UI::Command.new("Tester") { UI.messagebox("Hello World") }
    # testmenu.add_item cmd
    # ```
    # 
    # _@note_ — Prior to SketchUp 2019 it was not possible to sub-class {UI::Command}
    # due to a bug in how SketchUp initialized the class.
    def self.new: (String menutext) -> UI::Command

    # The {#extension} method returns the command's associated extension.
    # 
    # ```ruby
    # extension = Sketchup.extensions['Sandbox Tools']
    # cmd = UI::Command.new("Tester") {}
    # cmd.extension = extension
    # p cmd.extension == extension
    # ```
    # 
    # _@note_ — This is an advanced feature that extension developers normally won't
    # have to deal with. It's purpose is to address scenarios when SketchUp
    # isn't able to automatically infer which extension the command belongs to.
    def extension: () -> SketchupExtension?

    # sord omit - no YARD return type given, using untyped
    # The {#extension=} method explicitly sets the command's associated extension.
    # 
    # _@param_ `extension`
    # 
    # ```ruby
    # extension = Sketchup.extensions['Sandbox Tools']
    # cmd = UI::Command.new("Tester") {}
    # cmd.extension = extension
    # ```
    # 
    # _@note_ — This is an advanced feature that extension developers normally won't
    # have to deal with. It's purpose is to address scenarios when SketchUp
    # isn't able to automatically infer which extension the command belongs to.
    # These scenarios are for example an extension using a library to add its
    # commands or command manager extensions.
    def extension=: (SketchupExtension? _extension) -> untyped

    # The {#get_validation_proc} method returns the command's validation proc.
    # 
    # ```ruby
    # cmd = UI::Command.new("Tester") {}
    # cmd.set_validation_proc { MF_DISABLED }
    # proc = cmd.get_validation_proc
    # ```
    # 
    # _@see_ `#set_validation_proc`
    def get_validation_proc: () -> Proc?

    # The large_icon method returns the icon file for the command's
    # large icon.
    # 
    # _@return_ — the path to the large icon.
    # 
    # ```ruby
    # toolbar = UI::Toolbar.new "Test"
    # # This command displays Hello World on the screen when clicked
    # cmd = UI::Command.new("Test") { UI.messagebox("Hello World") }
    # cmd.small_icon = "ToolPencilSmall.png"
    # cmd.large_icon = "ToolPencilLarge.png"
    # toolbar = toolbar.add_item cmd
    # toolbar.show
    # puts cmd.large_icon
    # ```
    def large_icon: () -> String

    # The large_icon= method is used to identify the icon file for the command's
    # large icon. large icons should be 32x32 pixel images for best display
    # quality.
    # 
    # Since SketchUp 2016 it is possible to provide vector images for the command.
    # SVG format for Windows and PDF format for OS X. Since the vector images scale
    # for both small and large icon sizes, you may choose to use only one vector
    # image for both variants.
    # 
    # _@param_ `path` — The path to the large icon.
    # 
    # ```ruby
    # toolbar = UI::Toolbar.new "Test"
    # # This command displays Hello World on the screen when clicked
    # cmd = UI::Command.new("Test") { UI.messagebox("Hello World") }
    # cmd.small_icon = "ToolPencilSmall.png"
    # cmd.large_icon = "ToolPencilLarge.png"
    # toolbar = toolbar.add_item cmd
    # toolbar.show
    # ```
    def large_icon=: (String path) -> String

    # The menu_text method returns the menu item name for the command.
    # 
    # ```ruby
    # add_separator_to_menu("Draw")
    # # Adds a Test submenu to the Draw menu where the Tester menu item appears
    # testmenu = UI.menu("Draw").add_submenu("Test")
    # cmd = UI::Command.new("Tester") { UI.messagebox("Hello World") }
    # cmd.menu_text = "New String"
    # testmenu.add_item cmd
    # puts cmd.menu_text
    # ```
    def menu_text: () -> String

    # The menu_text= method is used to set the menu item name for the command.
    # 
    # _@param_ `menuitem` — A string representing the menu item for the command.
    # 
    # ```ruby
    # add_separator_to_menu("Draw")
    # # Adds a Test submenu to the Draw menu where the Tester menu item appears
    # testmenu = UI.menu("Draw").add_submenu("Test")
    # cmd = UI::Command.new("Tester") { UI.messagebox("Hello World") }
    # cmd.menu_text = "New String"
    # testmenu.add_item cmd
    # ```
    def menu_text=: (String menuitem) -> String

    # The {#proc} method returns the command's proc that is called when the command
    # is invoked.
    # 
    # ```ruby
    # cmd = UI::Command.new("Tester") {}
    # cmd.set_validation_proc { MF_DISABLED }
    # proc = cmd.proc
    # proc.call
    # ```
    def proc: () -> Proc

    # The {#set_validation_proc} method allows you to change whether the command
    # is enabled, checked, etc. For instance, the command toggling a dialog window
    # may be displayed as checked while the dialog is open.
    # 
    # ```ruby
    # # Create a command object.
    # cmd = UI::Command.new("Tester") {
    #   UI.messagebox("My Command")
    # }
    # cmd.menu_text = "My Command"
    # cmd.set_validation_proc {
    #   if Sketchup.active_model.selection.length == 0
    #     MF_GRAYED
    #   else
    #     MF_ENABLED
    #   end
    # }
    # UI.menu("Draw").add_item(cmd)
    # ```
    # 
    # _@note_ — Avoid disabling an command as it often isn't obvious to the user why
    # it is disabled. Prefer keeping the command enabled but show an error
    # message if pressed when it cannot be used.
    # 
    # _@see_ `#get_validation_proc`
    def set_validation_proc: () ?{ () -> Integer } -> UI::Command

    # The small_icon method returns the icon file for the command's
    # small icon.
    # 
    # _@return_ — the path to the small_icon
    # 
    # ```ruby
    # toolbar = UI::Toolbar.new "Test"
    # # This toolbar command displays Hello World on the screen when clicked.
    # cmd = UI::Command.new("Tester") { UI.messagebox("Hello World") }
    # cmd.small_icon = "ToolPencilSmall.png"
    # cmd.large_icon = "ToolPencilLarge.png"
    # toolbar = toolbar.add_item cmd
    # toolbar.show
    # puts cmd.small_icon
    # ```
    def small_icon: () -> String

    # The small_icon= method is used to identify the icon file for the command's
    # small icon. Small icons should be 24x24 pixel images for best display
    # quality.
    # 
    # Since SketchUp 2016 it is possible to provide vector images for the cursors.
    # SVG format for Windows and PDF format for OS X. Since the vector images scale
    # for both small and large icon sizes, you may choose to use only one vector
    # image for both variants.
    # 
    # _@param_ `path` — A path to the small icon.
    # 
    # ```ruby
    # toolbar = UI::Toolbar.new "Test"
    # # This toolbar command displays Hello World on the screen when clicked.
    # cmd = UI::Command.new("Tester") { UI.messagebox("Hello World") }
    # cmd.small_icon = "ToolPencilSmall.png"
    # cmd.large_icon = "ToolPencilLarge.png"
    # toolbar = toolbar.add_item cmd
    # toolbar.show
    # ```
    def small_icon=: (String path) -> String

    # The status_bar_text method returns the status bar text for the
    # command.
    # 
    # _@return_ — the status bar text.
    # 
    # ```ruby
    # toolbar = UI::Toolbar.new("Test")
    # # This toolbar tool simply displays Hello World on the screen
    # # when clicked
    # cmd = UI::Command.new("Tester") { UI.messagebox("Hello World") }
    # cmd.small_icon = "ToolPencilSmall.png"
    # cmd.large_icon = "ToolPencilLarge.png"
    # cmd.status_bar_text = "Testing the toolbars class."
    # toolbar = toolbar.add_item cmd
    # toolbar.show
    # puts cmd.status_bar_text
    # ```
    def status_bar_text: () -> String

    # The status_bar_text= method is used to set the status bar text for the
    # command. This should be a description what the command does.
    # 
    # _@param_ `text` — The text that will appear on the status bar when the cursor is over the command's menu item.
    # 
    # ```ruby
    # toolbar = UI::Toolbar.new("Test")
    # # This toolbar tool simply displays Hello World on the screen when clicked
    # cmd = UI::Command.new("Tester") { UI.messagebox("Hello World") }
    # cmd.small_icon = "ToolPencilSmall.png"
    # cmd.large_icon = "ToolPencilLarge.png"
    # cmd.status_bar_text = "Testing the toolbars class."
    # toolbar = toolbar.add_item cmd
    # toolbar.show
    # ```
    def status_bar_text=: (String text) -> String

    # The tooltip method returns command item's tooltip text.
    # 
    # _@return_ — the tooltip text
    # 
    # ```ruby
    # toolbar = UI::Toolbar.new "Test"
    # # This command displays Hello World on the screen when clicked
    # cmd = UI::Command.new("Test") { UI.messagebox("Hello World") }
    # cmd.tooltip = "Hello World Tool"
    # toolbar = toolbar.add_item cmd
    # toolbar.show
    # puts cmd.tooltip
    # ```
    def tooltip: () -> String

    # The {#tooltip=} method is used to define a command item's tooltip header. Tooltips
    # will appear when the command is attached to a tool bar and the user hovers
    # their cursor over the icon.
    # 
    # _@param_ `text` — The text of the tooltip.
    # 
    # ```ruby
    # toolbar = UI::Toolbar.new "Test"
    # # This command displays Hello World on the screen when clicked
    # cmd = UI::Command.new("Test") { UI.messagebox("Hello World") }
    # cmd.tooltip = "Hello World Tool"
    # toolbar = toolbar.add_item cmd
    # toolbar.show
    # ```
    # 
    # _@note_ — The tooltip text should repeat the commands' title text. For the command
    # description, use {#status_bar_text}.
    def tooltip=: (String text) -> String
  end

  # The Toolbar class contains methods to create and manipulate SketchUp
  # toolbars in Ruby. Toolbars are collections of buttons that you can use
  # to activate custom Tools or ruby scripts.
  # 
  # Also see the Command object for details on creating "commands" which
  # can be called from your toolbars.
  # 
  # @example
  #   toolbar = UI::Toolbar.new "Test"
  #   # This toolbar icon simply displays Hello World on the screen
  #   cmd = UI::Command.new("Test") {
  #     UI.messagebox "Hello World"
  #   }
  #   cmd.small_icon = "ToolPencilSmall.png"
  #   cmd.large_icon = "ToolPencilLarge.png"
  #   cmd.tooltip = "Test Toolbars"
  #   cmd.status_bar_text = "Testing the toolbars class"
  #   cmd.menu_text = "Test"
  #   toolbar = toolbar.add_item cmd
  #   toolbar.show
  # 
  # @version SketchUp 6.0
  class Toolbar
    include Enumerable[UI::Command]

    # The new method creates a new Toolbar object.
    # 
    # _@param_ `toolbarname` — The name for the new toolbar.
    # 
    # _@return_ — the newly created toolbar object
    # 
    # ```ruby
    # toolbar = UI::Toolbar.new "Test"
    # ```
    def self.new: (String toolbarname) -> UI::Toolbar

    # The add_item method is used to add an item to the toolbar.
    # 
    # _@param_ `command` — A Command object representing the command to add to the toolbar.
    # 
    # _@return_ — the toolbar where the command was just added
    # 
    # ```ruby
    # toolbar = toolbar.add_item command
    # ```
    def add_item: (UI::Command command) -> UI::Toolbar

    # sord omit - no YARD type given for "arg", using untyped
    # The add_separator method is used to add a line separator to the toolbar.
    # 
    # _@return_ — the toolbar where the line separator was just added
    # 
    # ```ruby
    # toolbar = toolbar.add_separator
    # ```
    def add_separator: (untyped arg) -> UI::Toolbar

    # The {#count} method is inherited from the +Enumerable+ mix-in module.
    # 
    # ```ruby
    # number = toolbar.count
    # ```
    def count: () -> Integer

    # The each method is used to iterate through all of the commands
    # attached to a toolbar.
    # 
    # ```ruby
    # toolbar = UI::Toolbar.new "Test"
    # # This command displays Hello World on the screen when clicked
    # cmd = UI::Command.new("Test") { UI.messagebox("Hello World") }
    # toolbar.add_item cmd
    # toolbar = toolbar.add_separator
    # cmd = UI::Command.new("Test 2") { UI.messagebox("Hello World 2") }
    # toolbar.add_item cmd
    # toolbar.show
    # toolbar.each { | item |
    #   puts item
    # }
    # ```
    def each: () ?{ (UI::Command) -> void } -> void

    # The get_last_state method is used to determine if the toolbar was hidden or
    # visible in the previous session of SketchUp.
    # 
    # Valid states are 1 for visible, 0 for hidden, -1 for before never shown.
    # 
    # _@return_ — the last state of the toolbar (see comments)
    # 
    # ```ruby
    # state = toolbar.get_last_state
    # ```
    def get_last_state: () -> bool

    # The hide method is used to hide the toolbar on the user interface.
    # 
    # ```ruby
    # toolbar = UI::Toolbar.new "Test"
    # # This toolbar icon simply displays Hello World on the screen
    # cmd = UI::Command.new("Test") {
    #   UI.messagebox "Hello World"
    # }
    # cmd.small_icon = "ToolPencilSmall.png"
    # cmd.large_icon = "ToolPencilLarge.png"
    # cmd.tooltip = "Test Toolbars"
    # cmd.status_bar_text = "Testing the toolbars class"
    # cmd.menu_text = "Test"
    # toolbar = toolbar.add_item cmd
    # toolbar.show
    # UI.messagebox "Toolbar Showing"
    # toolbar.hide
    # UI.messagebox "Toolbar Hidden"
    # ```
    def hide: () -> void

    # The {#length} method returns the number of items in the toolbar.
    # 
    # ```ruby
    # number = toolbar.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The name method returns the name of the toolbar.
    # 
    # _@return_ — the name of the toolbar.
    # 
    # ```ruby
    # toolbar = UI::Toolbar.new "Test"
    # # This command displays Hello World on the screen when clicked
    # cmd = UI::Command.new("Test") { UI.messagebox("Hello World") }
    # toolbar.add_item cmd
    # toolbar = toolbar.add_separator
    # cmd = UI::Command.new("Test 2") { UI.messagebox("Hello World 2") }
    # puts toolbar.name
    # toolbar.show
    # ```
    def name: () -> String

    # The restore method is used to reposition the toolbar to its previous
    # location and show if not hidden.
    # 
    # ```ruby
    # toolbar.restore
    # ```
    def restore: () -> void

    # The show method is used to display the toolbar in the user interface.
    # 
    # ```ruby
    # toolbar = UI::Toolbar.new "Test"
    # # This toolbar icon simply displays Hello World on the screen
    # cmd = UI::Command.new("Test") {
    #   UI.messagebox "Hello World"
    # }
    # cmd.small_icon = "ToolPencilSmall.png"
    # cmd.large_icon = "ToolPencilLarge.png"
    # cmd.tooltip = "Test Toolbars"
    # cmd.status_bar_text = "Testing the toolbars class"
    # cmd.menu_text = "Test"
    # toolbar = toolbar.add_item cmd
    # toolbar.show
    # ```
    def show: () -> void

    # The {#size} method is an alias of {#length}.
    # 
    # ```ruby
    # number = toolbar.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer

    # The visible? method is used to find out if a toolbar is currently visible.
    # 
    # ```ruby
    # visible = toolbar.visible?
    # ```
    def visible?: () -> bool
  end

  # The Ruby WebDialog class allows you to create and interact with DHTML dialog
  # boxes from Ruby.
  # 
  # If your goal is to simply display a website to your users, consider using
  # {UI.openURL}, which will show them a web page in their default browser rather
  # than inside a dialog in SketchUp.
  # 
  # See this blog post for a detailed, step-by-step example:
  # http://sketchupapi.blogspot.com/2008/02/sharing-data-between-sketchup-ruby-and.html
  # 
  # Under Windows the IE render mode is different in webdialogs than from what
  # you see in the normal browser. It will by default pick an older render mode
  # and different versions of SketchUp will use different modes. In order to
  # reliably control the render mode of your webdialogs under Windows you need to
  # insert a special META compatibility tag:
  # 
  #   // To always force the latest version available:
  #   <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  # 
  #   // To lock to a specific IE version:
  #   <meta http-equiv="X-UA-Compatible" content="IE=8"/>
  # 
  # Starting with SketchUp 2013, you can embed a special HTML link in your dialog
  # that will launch Extension Warehouse and show a specified extension's page.
  # This can be useful if your extension has a dependency on another one and you
  # would like to direct the user to install that extension.
  # 
  # For example, to launch an extension's page whose URL is:
  # http://extensions.sketchup.com/en/content/advanced-camera-tools
  # The link would be:
  # 
  # @deprecated Please use {UI::HtmlDialog} that was introduced in
  #   SketchUp 2017.
  # 
  # @example
  #   <a href="skp:launchEW@advanced-camera-tools">Get Advanced Camera Tools</a>
  # 
  # @version SketchUp 6.0
  class WebDialog
    # The add_action_callback method establishes a Ruby callback method that your
    # web dialog can call to perform some function.
    # 
    # Use the skp:callback_method_name to invoke the callback method from your
    # webdialog. Your JavaScript in the webdialog will invoke the callback method
    # with a string representing arguments to the callback method.
    # 
    # Note that you're sending data down to Ruby as a single string that's
    # passed via the window.location bar. In Internet Explorer on PC, there is
    # a length limit of 2038 characters for this bar, so if you're
    # needing to pass large data down you might consider using get_element_value
    # to pull in a longer string from a hidden input field in the HTML.
    # 
    # _@param_ `callback_name` — The name of the callback method to be invoked from the webdialog.
    # 
    # _@return_ — nil
    # 
    # ```ruby
    # # In Ruby code...
    # dlg.add_action_callback("ruby_messagebox") {|dialog, params|
    #   UI.messagebox("You called ruby_messagebox with: " + params.to_s)
    # }
    # 
    # # JavaScript inside the page loaded into the WebDialog:
    # # window.location = 'skp:ruby_messagebox@Hello World';
    # ```
    def add_action_callback: (untyped callback_name) ?{ (untyped dialog, untyped params) -> void } -> untyped

    # By default, actions are only allowed on the host where the webdialog is
    # displayed. The allow_actions_from_host method is used to selectively allow
    # actions to take place on a host remote from the host where the webdialog
    # exists. If the webdialog is local, no remote host is allowed unless you use
    # this method.
    # 
    # _@param_ `hostname` — The name (domain) of the host that your webdialog can access safely.
    # 
    # ```ruby
    # dialog.allow_actions_from_host("sketchup.com")
    # ```
    def allow_actions_from_host: (String hostname) -> bool

    # The bring_to_front method is used to bring the webdialog to the front of all
    # the windows on the desktop. See show_modal for how to ensure that your
    # WedDialogs are on top.
    # 
    # ```ruby
    # dialog.bring_to_front
    # ```
    def bring_to_front: () -> UI::WebDialog

    # The close method is used to close the webdialog.
    # 
    # ```ruby
    # dialog.close
    # ```
    def close: () -> void

    # The execute_script method is used to execute a JavaScript string on the web
    # dialog.
    # 
    # _@param_ `script` — The JavaScript script to execute on the webdialog.
    # 
    # ```ruby
    # js_command = "document.getElementById('id').innerHTML = '<b>Hi!</b>'"
    # dialog.execute_script(js_command)
    # ```
    def execute_script: (String script) -> bool

    # The get_default_dialog_color method is used to get the default dialog color
    # for the web dialog.
    # 
    # _@return_ — a six digit hexidecimal number representing the color
    # 
    # ```ruby
    # dialog.get_default_dialog_color
    # #ece9d8
    # ```
    def get_default_dialog_color: () -> String

    # The get_element_value method is used to get a value, with a given
    # element_id, from the web dialog's DOM.
    # 
    # _@param_ `element_id` — The name of the element in your HTML code.
    # 
    # _@return_ — a string containing the retrieved value.
    # 
    # ```ruby
    # # In Ruby code:
    # dialog.get_element_value("myTextInput")
    # 
    # # In webdialog's HTML:
    # <input type="text" id="myTextInput" value="hello">
    # ```
    def get_element_value: (String element_id) -> String

    # sord omit - no YARD type given for "*args", using untyped
    # The +new+ method is used to create a new webdialog.
    # 
    # 250, left = 0, top = 0, resizable = true)
    #   @param [String] dialog_title   The title to be displayed in the webdialog.
    #   @param [Boolean] scrollable    true if you want to allow scrollbars, false
    #                                  if you do not want to allow scrollbars.
    #   @param [String, nil] pref_key  The registry entry where the location and
    #                                  size of the dialog will be saved.
    #                                  If preferences_key is not included, the
    #                                  location and size will not be stored.
    #   @param [Integer] width         The width of the webdialog.
    #   @param [Integer] height        The height of the webdialog.
    #   @param [Integer] left          The number of pixels from the left.
    #   @param [Integer] top           The number of pixels from the top.
    #   @param [Integer] resizable     true if you want the webdialog to be resizable,
    #                                  false if not.
    #   @return [UI::WebDialog]
    # 
    # ```ruby
    # dlg = UI::WebDialog.new("Show sketchup.com", true,
    #   "ShowSketchupDotCom", 739, 641, 150, 150, true);
    # dlg.set_url "http://www.sketchup.com"
    # dlg.show
    # ```
    # 
    # _@note_ — Since SU2017 the position and size of the dialog is DPI aware - it will
    # scale to the DPI of the monitor automatically. Specify units as they would
    # be on a traditional low-DPI monitor.
    # 
    # _@note_ — The browser which is embedded inside the dialog depends on the
    # user's OS. On Mac, Safari is embedded, while on the PC whatever version of
    # Internet Explorer is installed will be embedded.
    def initialize: (*untyped args) -> void

    # The max_height method is used to get the maximum height that the user is
    # allowed to resize the dialog to.
    # 
    # _@return_ — the maximum height in pixels
    # 
    # ```ruby
    # max = dialog.max_height
    # ```
    def max_height: () -> Integer

    # The max_height= method is used to set the maximum height that the user is
    # allowed to resize the dialog to.
    # 
    # _@param_ `height` — The maximum height in pixels
    # 
    # ```ruby
    # dialog.max_height = 400
    # ```
    # 
    # _@note_ — As of SU2017 this will automatically scale the height by the same
    # factor as {UI.scale_factor}.
    def max_height=: (Integer height) -> Integer

    # The max_width method is used to get the maximum width that the user is
    # allowed to resize the dialog to.
    # 
    # _@return_ — the maximum width in pixels
    # 
    # ```ruby
    # max = dialog.max_width
    # ```
    def max_width: () -> Integer

    # The max_width= method is used to set the maximum width that the user is
    # allowed to resize the dialog to.
    # 
    # _@param_ `width` — The maximum width in pixels
    # 
    # ```ruby
    # dialog.max_width = 500
    # ```
    # 
    # _@note_ — As of SU2017 this will automatically scale the width by the same factor
    # as {UI.scale_factor}.
    def max_width=: (Integer width) -> Integer

    # The min_width method is used to get the minimum height that the user is
    # allowed to resize the dialog to.
    # 
    # _@return_ — the minimum height in pixels
    # 
    # ```ruby
    # min = dialog.min_height
    # ```
    def min_height: () -> Integer

    # The min_height= method is used to set the minimum height that the user is
    # allowed to resize the dialog to.
    # 
    # _@param_ `height` — The minimum height in pixels
    # 
    # ```ruby
    # dialog.min_height = 100
    # ```
    # 
    # _@note_ — As of SU2017 this will automatically scale the height by the same
    # factor as {UI.scale_factor}.
    def min_height=: (Integer height) -> Integer

    # The min_width method is used to get the minimum width that the user is
    # allowed to resize the dialog to.
    # 
    # _@return_ — the minimum width in pixels
    # 
    # ```ruby
    # min = dialog.min_width
    # ```
    def min_width: () -> Integer

    # The min_width= method is used to set the minimum width that the user is
    # allowed to resize the dialog to.
    # 
    # _@param_ `width` — The minimum width in pixels
    # 
    # ```ruby
    # dialog.min_width = 200
    # ```
    # 
    # _@note_ — As of SU2017 this will automatically scale the width by the same factor
    # as {UI.scale_factor}.
    def min_width=: (Integer width) -> Integer

    # sord omit - no YARD type given for "nav_buttons", using untyped
    # The navigation_buttons_enabled= method is used to set whether the home, next,
    # and back buttons are visible at the top of the WebDialog on the mac. This
    # method has no use on the PC, as these buttons are never displayed.
    # 
    # ```ruby
    # dialog.navigation_buttons_enabled = false
    # ```
    def navigation_buttons_enabled=: (untyped nav_buttons) -> bool

    # The navigation_buttons_enabled? method is used to get whether the home, next,
    # and back buttons are visible at the top of the WebDialog on the mac. This
    # method has no use on the PC, as these buttons are never displayed.
    # 
    # On the mac, this defaults to true for new WebDialogs.
    # 
    # ```ruby
    # nav_buttons = dialog.navigation_buttons_enabled?
    # ```
    def navigation_buttons_enabled?: () -> bool

    # The post_url method is used to send the data to a url using the HTTP POST
    # method.
    # 
    # _@param_ `url` — The url to send the data.
    # 
    # _@param_ `data` — The data to be sent.
    # 
    # ```ruby
    # data = dialog.post_url("http://www.mydomain.com/formchecker.cgi",data)
    # ```
    def post_url: (String url, String data) -> void

    # The screen_scale_factor method returns the ratio of screen pixels to logical
    # window units (called 'points' on Mac) for the screen this WebDialog is
    # currently in. On a retina screen Mac, this ratio will be greater than 1.0.
    # On Windows this always return 1.0.
    # 
    # _@return_ — screen scale factor
    # 
    # ```ruby
    # factor = dialog.screen_scale_factor
    # ```
    def screen_scale_factor: () -> Float

    # The set_background_color method is used to set the background color for the
    # webdialog.
    # 
    # _@param_ `color` — A six digit hexidecimal color.
    # 
    # ```ruby
    # dlg.set_background_color("f3f0f0")
    # ```
    def set_background_color: (String color) -> void

    # The {#set_file} method is used to identify a local HTML file to display in
    # the webdialog.
    # 
    # _@param_ `filename` — The filename for the webdialog file (HTML file).
    # 
    # _@param_ `path` — A path that filename is relative to.
    # 
    # ```ruby
    # file = File.join(__dir__, 'mypage.html')
    # dialog.set_file(file)
    # ```
    def set_file: (String filename, ?String? path) -> void

    # The set_full_security method is used to place the WebDialog into a higher
    # security mode where remote URLs and plugins (such as Flash) are not allowed
    # inside the browser. This defaults to false when a new WebDialog is created.
    # 
    # _@return_ — the updated WebDialog
    # 
    # ```ruby
    # dialog.set_full_security
    # ```
    def set_full_security: () -> UI::WebDialog

    # The set_html method is used to load a webdialog with a string of provided
    # HTML.
    # 
    # _@param_ `html_string` — A string of valid html to display in your webdialog.
    # 
    # ```ruby
    # html= '<b>Hello world!</b>'
    # dialog.set_html(html)
    # ```
    def set_html: (String html_string) -> void

    # The set_on_close method is used to establish one or more activities to
    # perform when the dialog closes (such as saving values stored in the dialog).
    # 
    # ```ruby
    # dialog.set_on_close{ UI.messagebox("Closing the webDialog") }
    # ```
    def set_on_close: () -> void

    # The set_position method is used to set the position of the webdialog
    # relative to the screen, in pixels.
    # 
    # _@param_ `left` — The number of pixels from the left.
    # 
    # _@param_ `top` — The number of pixels from the top of the screen.
    # 
    # ```ruby
    # dialog.set_position(100,50)
    # ```
    # 
    # _@note_ — As of SU2017 this will automatically scale the x and y by the same
    # factor as {UI.scale_factor}.
    def set_position: (Integer left, Integer _top) -> void

    # The set_size method is used to set the size of the webdialog, in pixels.
    # 
    # _@param_ `w` — Width of the webdialog.
    # 
    # _@param_ `h` — Height of the webdialog.
    # 
    # ```ruby
    # dialog.set_size(320,240)
    # ```
    # 
    # _@note_ — As of SU2017 this will automatically scale the width and height by the
    # same factor as {UI.scale_factor}.
    def set_size: (Integer w, Integer h) -> void

    # The set_url method is used to load a webdialog with the content at a
    # specific URL. This method allows you to load web sites in a webdialog.
    # 
    # _@param_ `url` — The URL for a specific web site.
    # 
    # ```ruby
    # dialog.set_url "http://www.sketchup.com"
    # ```
    def set_url: (String url) -> void

    # The show method is used to display a non-modal dialog box.
    # 
    # ```ruby
    # dialog.show {
    #   dialog.execute_script("alert(10)");
    # }
    # ```
    def show: () -> void

    # The show_modal method is used to display a modal dialog box. In SketchUp 6
    # and 7, this behaves differently on Mac vs. PC. On the PC, it shows a truly
    # modal dialog, meaning so long as the WebDialog is visible, no input can be
    # performed elsewhere inside SketchUp. On the Mac, "modal" WebDialogs do not
    # behave this way, but instead are "always on top" of other windows.
    # 
    # ```ruby
    # dialog.show_modal {
    #   dialog.execute_script("alert(10)");
    # }
    # ```
    def show_modal: () -> void

    # The visible? method is used to tell if the webdialog is currently shown.
    # 
    # ```ruby
    # vis = dialog.visible?
    # ```
    def visible?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The write_image method is used to grab a portion of the web dialog screen and
    # save the image to the given file path.
    # 
    # _@param_ `image_path` — The destination path of the saved image.
    # 
    # _@param_ `option` — Specifies what method to use when saving the image. For JPG/JPEG images, this specifies the image quality and can range from 1 to 100. For PNG images this specifies the compression algorithm: <4 (best speed), 4-8 (default), or >=9 (best compression).
    # 
    # _@param_ `top_left_x` — The x coordinate of the upper left corner of the region to grab.
    # 
    # _@param_ `top_left_y` — The x coordinate of the upper left corner of the region to grab.
    # 
    # _@param_ `bottom_right_x` — The x coordinate of the lower right corner of the region to grab.
    # 
    # _@param_ `bottom_right_y` — The x coordinate of the lower right corner of the region to grab.
    # 
    # ```ruby
    # dialog.write_image('c:/grab.jpg', 70, 0, 0, 100, 100)
    # dialog.write_image('c:/grab.png', 4, 0, 0, 100, 100)
    # ```
    def write_image: (
                       String image_path,
                       Integer option,
                       Integer top_left_x,
                       Integer top_left_y,
                       Integer bottom_right_x,
                       Integer bottom_right_y
                     ) -> untyped
  end

  # The Ruby HtmlDialog class allows you to create and interact with HTML dialog
  # boxes from Ruby. This is the best way to generate complex, embedded UIs
  # inside SketchUp, but it does generally require HTML and JavaScript expertise.
  # 
  # If your goal is to simple display a website to your users, consider using
  # {UI#openURL}, which will show them a web page in their default browser rather
  # than inside a dialog in SketchUp.
  # 
  # The left, top, width, height etc. dimensions of the dialog are in logical
  # units. This means you provide the units as if they where on a monitor with
  # "normal" DPI. The units given will be multiplied by the same factor as
  # returned by {UI.scale_factor}.
  # 
  # For usage examples, including how to migrate from the old WebDialog class,
  # see https://github.com/SketchUp/htmldialog-examples.
  # You may use the {https://sketchup.github.io/modus-for-sketchup-extensions Trimble Modus}
  # framework for a look and feel of your dialog that matches that of SketchUp's dialogs.
  # 
  # HtmlDialog uses the following versions of CEF (Chromium Embedded Framework):
  # 
  # [SketchUp 2021.1]
  #   CEF 88
  # [SketchUp 2019.0]
  #   CEF 64
  # [SketchUp 2018.0]
  #   CEF 56
  # [SketchUp 2017.0]
  #   CEF 52
  # 
  # @version SketchUp 2017
  class HtmlDialog
    CEF_VERSION: untyped
    CHROME_VERSION: untyped
    STYLE_DIALOG: untyped
    STYLE_UTILITY: untyped
    STYLE_WINDOW: untyped

    # The {#add_action_callback} method establishes a Ruby callback method that your
    # html dialog can call to perform some function.
    # 
    # Use the +sketchup.callback_method_name+ to invoke the callback method from your
    # html dialog. Your JavaScript in the html dialog will invoke the callback with
    # the same number of arguments.
    # 
    # The call is asynchronous. JavaScript call might return before Ruby callback
    # even called. Use +onCompleted+ callback to get notified for completion.
    # 
    # Basic types such as booleans, numbers, strings, arrays and hashes are
    # automatically converted between Ruby and JavaScript.
    # 
    # _@param_ `callback_name` — The name of the callback method to be invoked from the html dialog.
    # 
    # _@return_ — true if action added successfully, false
    # otherwise.
    # 
    # Ruby Code
    # ```ruby
    # dialog.add_action_callback("say") { |action_context, param1, param2|
    #   puts "JavaScript said #{param1} and #{param2}"
    # }
    # ```
    # 
    # JavaScript
    # ```ruby
    # sketchup.say('Hello World', 42);
    # ```
    # 
    # JavaScript with callback
    # ```ruby
    # sketchup.say('Hello World', 42, {
    #   onCompleted: function() {
    #     console.log('Ruby side done.');
    #   }
    # });
    # ```
    # 
    # _@note_ — When an HtmlDialog is closed, all callbacks to that instance are
    # cleared. Re-attach them if you need to open the dialog again.
    def add_action_callback: (String callback_name) ?{ (Object action_context, Object args) -> void } -> bool

    # The {#bring_to_front} method is used to bring the window to the front,
    # putting it on top of other windows even if its minimized.
    # 
    # ```ruby
    # dialog.bring_to_front
    # ```
    # 
    # _@see_ `Sketchup.focus`
    def bring_to_front: () -> void

    # The {#center} method is used to center the HtmlDialog relative to the active
    # model window. If there is no active model window, this function doesn't do
    # anything.
    # 
    # _@return_ — This always return true, never false.
    # 
    # ```ruby
    # dialog.center
    # ```
    def center: () -> bool

    # The {#close} method is used to close a dialog box.
    # 
    # ```ruby
    # dialog.close
    # ```
    def close: () -> void

    # The {#execute_script} method is used to execute a JavaScript string on the
    # html dialog asynchronously.
    # 
    # _@param_ `script` — The JavaScript script to execute on the HtmlDialog.
    # 
    # ```ruby
    # js_command = "document.getElementById('id').innerHTML = '<b>Hi!</b>'"
    # dialog.execute_script(js_command)
    # ```
    def execute_script: (String script) -> void

    # The {#get_content_size} method is used to get the content size of the HtmlDialog, in logical
    # pixels.
    # 
    # _@return_ — Content width and height of the HtmlDialog.
    # A nil value is returned if the HtmlDialog
    # is not visible.
    # 
    # ```ruby
    # width, height = dialog.get_content_size
    # ```
    def get_content_size: () -> [Integer, Integer]?

    # The {#get_position} method is used to get the position of the HtmlDialog
    # relative to the screen, in logical pixels.
    # 
    # _@return_ — Left and top position of the dialog.
    # A nil value is returned if the HtmlDialog
    # is not visible.
    # 
    # ```ruby
    # left, top = dialog.get_position
    # ```
    def get_position: () -> [Integer, Integer]?

    # The {#get_size} method is used to get the outer frame size of the HtmlDialog, in logical pixels.
    # 
    # _@return_ — Outer frame width and height of the HtmlDialog.
    # A nil value is returned if the HtmlDialog
    # is not visible.
    # 
    # ```ruby
    # width, height = dialog.get_size
    # ```
    def get_size: () -> [Integer, Integer]?

    # The new method is used to create a new HtmlDialog.
    # 
    # In SketchUp 2021.1 +use_content_size+ was added.
    # When set to +true+, +width+, +height+, +min_width+,
    # +max width+, +min_height+, +max_height+ will represent the size of the
    # content area of the window. This excludes the titlebar and the window frame.
    # When +use_content_size+ is set to +false+ (the default value),
    # the size dimensions will represent the outer frame size.
    # 
    # The +properties+ hash accepts an optional key +style+ where the value is
    # one of:
    # 
    # [+UI::HtmlDialog::STYLE_DIALOG+]   HtmlDialog stays at the top of SketchUp.
    # 
    # [+UI::HtmlDialog::STYLE_WINDOW+]   HtmlDialog can go behind SketchUp and
    #                                    doesn't disappear when SketchUp looses
    #                                    focus.
    # 
    # [+UI::HtmlDialog::STYLE_UTILITY+]  HtmlDialog is shown with small titlebar
    #                                    and stays on top of SketchUp.
    # 
    # _@param_ `properties` — A hash containing the initial properties of the newly created dialog.
    # 
    # With options Hash
    # ```ruby
    # dialog = UI::HtmlDialog.new(
    # {
    #   :dialog_title => "Dialog Example",
    #   :preferences_key => "com.sample.plugin",
    #   :scrollable => true,
    #   :resizable => true,
    #   :width => 600,
    #   :height => 400,
    #   :left => 100,
    #   :top => 100,
    #   :min_width => 50,
    #   :min_height => 50,
    #   :max_width =>1000,
    #   :max_height => 1000,
    #   :style => UI::HtmlDialog::STYLE_DIALOG
    # })
    # dialog.set_url("http://www.sketchup.com")
    # dialog.show
    # ```
    # 
    # With keyword style argument
    # ```ruby
    # dialog = UI::HtmlDialog.new(
    #   dialog_title: "Dialog Example",
    #   preferences_key: "my_name_my_extension_my_dialog",
    #   scrollable: true,
    #   resizable: true,
    #   width: 600,
    #   height: 400,
    #   left: 100,
    #   top: 100,
    #   min_width: 50,
    #   min_height: 50,
    #   max_width: 1000,
    #   max_height: 1000,
    #   style: UI::HtmlDialog::STYLE_DIALOG
    # )
    # dialog.set_url("https://www.sketchup.com")
    # dialog.show
    # ```
    # 
    # _@note_ — Prefix +preference_key+ with something unique to your extension.
    # 
    # _@note_ — If there is no reference kept to the HtmlDialog object, the window
    # will close once the garbage collection runs. This behavior can be confusing
    # in trivial test code but is usually not a concern in real life scenarios.
    # Typically a persistent reference, e.g. an instance variable, should be kept
    # to bring the dialog to front, rather than creating a duplicate, if the user
    # should request it a second time.
    def initialize: (::Hash[untyped, untyped] properties) -> void

    # The {#set_can_close} method is used to attach a block that is executed just
    # before closing, this block has to return a boolean, if the block returns
    # false the close will be canceled.
    # 
    # ```ruby
    # dialog.set_can_close { false }
    # ```
    def set_can_close: () ?{ () -> bool } -> bool

    # The {#set_content_size} method is used to set the content size of the HtmlDialog, in logical
    # pixels.
    # 
    # _@param_ `width` — Content width of the HtmlDialog.
    # 
    # _@param_ `height` — Content height of the HtmlDialog.
    # 
    # ```ruby
    # dialog.set_content_size(600, 400)
    # ```
    def set_content_size: (Integer width, Integer height) -> void

    # The {#set_file} method is used to identify a local HTML file to display in the
    # HtmlDialog.
    # 
    # _@param_ `filename` — The filename for the HtmlDialog file (HTML file)
    # 
    # ```ruby
    # dialog.set_file("c:/mypage.html")
    # ```
    def set_file: (String filename) -> void

    # The {#set_html} method is used to load a HtmlDialog with a string of provided
    # HTML.
    # 
    # _@param_ `html_string` — A string of valid html to display in your HtmlDialog.
    # 
    # ```ruby
    # html = '<b>Hello world!</b>'
    # dialog.set_html(html)
    # ```
    def set_html: (String html_string) -> void

    # The {#set_on_closed} method is used to attach a block that will be
    # executed when a dialog is already in the process of closing, do any last
    # minute operations within this block such as saving the current state.
    # 
    # ```ruby
    # dialog.set_on_closed { save_selection }
    # ```
    def set_on_closed: () -> bool

    # The {#set_position} method is used to set the position of the HtmlDialog
    # relative to the screen, in pixels.
    # 
    # _@param_ `left` — The number of pixels from the left.
    # 
    # _@param_ `top` — The number of pixels from the top of the screen.
    # 
    # _@return_ — This always return true, never false.
    # 
    # ```ruby
    # dialog.set_position(100, 50)
    # ```
    def set_position: (Integer left, Integer _top) -> bool

    # The {#set_size} method is used to set the outer frame size of the HtmlDialog, in pixels.
    # 
    # _@param_ `width` — Outer frame width of the HtmlDialog.
    # 
    # _@param_ `height` — Outer frame height of the HtmlDialog.
    # 
    # _@return_ — This always return true, never false.
    # 
    # ```ruby
    # dialog.set_size(320, 240)
    # ```
    def set_size: (Integer width, Integer height) -> bool

    # The {#set_url} method is used to load a HtmlDialog with the content at a
    # specific URL. This method allows you to load web sites in a HtmlDialog.
    # 
    # _@param_ `url` — The URL for a specific web site.
    # 
    # ```ruby
    # dialog.set_url("https://www.sketchup.com")
    # ```
    def set_url: (String url) -> void

    # The {#show} method is used to display a non-modal dialog box.
    # 
    # ```ruby
    # dialog.show
    # ```
    def show: () -> void

    # The {#show_modal} method is used to display a modal dialog box.
    # 
    # ```ruby
    # dialog.show_modal
    # ```
    def show_modal: () -> void

    # The {#visible?} method is useful to tell if the dialog is shown and still
    # alive, if the dialog is minimized or not visible on the screen this will
    # still return +true+.
    # 
    # _@return_ — Returns true if the dialog is open.
    # 
    # ```ruby
    # if dialog.visible?
    #   dialog.bring_to_front
    # else
    #   dialog = UI::HtmlDialog.new
    #   dialog.set_url("https://www.sketchup.com")
    #   dialog.show
    # end
    # ```
    def visible?: () -> bool
  end

  # {UI::Notification} objects allows you to show native notifications in the
  # desktop. Notifications can have a message, icon and accept and/or dismiss
  # buttons with callback blocks.
  # 
  # @example
  #   # For consistency, the accept (yes) and the dismiss (no) buttons
  #   # are always displayed in the same order.
  #   message = "A new version of pizza is available. Install now?"
  #   @notification = UI::Notification.new(sketchup_extension, message)
  #   @notification.on_accept("Pizza!") { puts "Pizza" }
  #   @notification.on_dismiss("No thanks") { puts "No pizza" }
  #   @notification.show
  # 
  #   # The two options are however not treated differently by SketchUp and can
  #   # also be used for questions with no strict yes/no answer.
  #   message = "Pizza clashes with health. Select which one to keep."
  #   @notification = UI::Notification.new(sketchup_extension, message)
  #   @notification.on_accept("Pizza") { puts "Pizza" }
  #   @notification.on_dismiss("Health") { puts "Salad" }
  #   @notification.show
  # 
  # @version SketchUp 2017
  class Notification
    # Gets the icon name, this is the path that will be used to get the icon from
    # the file system path.
    # 
    # ```ruby
    # @notification = UI::Notification.new(sketchup_extension, "Hello world", "/path/to/icon",
    #     "Icon Tooltip")
    # puts "Icon Name: #{@notification.icon_name}"
    # @notification.show
    # ```
    def icon_name: () -> String

    # Sets the icon path, this icon will be loaded from the path give, the path
    # has to be a local filesystem path.
    # 
    # _@param_ `icon_name` — String providing the icon filesystem path.
    # 
    # ```ruby
    # @notification = UI::Notification.new(sketchup_extension, "Hello world")
    # @notification.icon_name = "/path/to/icon"
    # @notification.show
    # ```
    def icon_name=: (String icon_name) -> bool

    # Gets the icon Tooltip, this is the string that appear when the mouse is over
    # the icon.
    # 
    # ```ruby
    # @notification = UI::Notification.new(sketchup_extension, "Hello world", "/path/to/icon",
    #     "Icon Tooltip")
    # puts "Tooltip: #{@notification.icon_tooltip}"
    # @notification.show
    # ```
    def icon_tooltip: () -> String

    # Sets the icon Tooltip, this string will appear when the mouse is over the
    # icon.
    # 
    # _@param_ `icon_tooltip` — String providing the new icon Tooltip.
    # 
    # ```ruby
    # @notification = UI::Notification.new(sketchup_extension, "Hello world")
    # @notification.icon_tooltip = "icon Tooltip"
    # @notification.show
    # ```
    def icon_tooltip=: (String icon_tooltip) -> bool

    # Creates a new {UI::Notification} object.
    # 
    # _@param_ `sketchup_extension` — {SketchupExtension} instance used to identify the source of the notification.
    # 
    # _@param_ `message` — Message to display.
    # 
    # _@param_ `icon_name` — Path to an icon to display along with the message.
    # 
    # _@param_ `icon_tooltip` — Tooltip for the icon.
    # 
    # ```ruby
    # @notification = UI::Notification.new(sketchup_extension, "Hello world", "/path/to/icon",
    #     "Icon Tooltip")
    # @notification.show
    # ```
    # 
    # _@note_ — In order to insert line breaks into the message you need to use +\\r\\n+.
    def initialize: (
                      SketchupExtension sketchup_extension,
                      ?String? message,
                      ?String? icon_name,
                      ?String? icon_tooltip
                    ) -> void

    # Gets the message as string.
    # 
    # ```ruby
    # @notification = UI::Notification.new(sketchup_extension)
    # puts "This is the current message: #{@notification.message}"
    # @notification.show
    # ```
    def message: () -> String

    # Sets a new message. Notifications are meant for quick and brief messages.
    # These message disappear automatically after a short while if they are not
    # interacted with.
    # 
    # _@param_ `message` — String providing the new message.
    # 
    # ```ruby
    # @notification = UI::Notification.new(sketchup_extension)
    # @notification.message = "Hello world"
    # @notification.show
    # ```
    # 
    # _@note_ — In order to insert line breaks into the message you need to use +\\r\\n+.
    def message=: (String message) -> bool

    # Shows a button in the notification with the given title and callback block,
    # both arguments are required.
    # 
    # _@param_ `title` — Sets the title of the button.
    # 
    # _@param_ `block` — Sets the action callback, this will be called when the user clicks on the dismiss button.
    # 
    # ```ruby
    # @notification = UI::Notification.new(sketchup_extension, "Hello world")
    # @notification.on_accept("Accept")  do |notification, title|
    #    puts "The user pressed [#{title}] with message #{notification.message}"
    # end
    # @notification.show
    # ```
    def on_accept: (String title, Proc block) -> bool

    # Returns the accept's button title.
    # 
    # ```ruby
    # @notification = UI::Notification.new(sketchup_extension, "Hello world")
    # @notification.on_accept("Accept")  do |notification, title|
    #    puts "The user pressed #{notification.on_accept_title}"
    # end
    # @notification.show
    # ```
    def on_accept_title: () -> String

    # Shows a button in the notification with the given title and callback block.
    # Both arguments are required. This callback is only called if you press the
    # Dismiss button, not when the time runs out and the notification automatically
    # disappears.
    # 
    # _@param_ `title` — Sets the title of the button.
    # 
    # _@param_ `block` — Sets the action callback, this will be called when the user clicks on the dismiss button.
    # 
    # ```ruby
    # @notification = UI::Notification.new(sketchup_extension, "Hello world")
    # @notification.on_dismiss("Close")  do |notification, title|
    #    puts "The user pressed [#{title}] with message #{notification.message}"
    # end
    # @notification.show
    # ```
    def on_dismiss: (String title, Proc block) -> bool

    # Returns the dismiss's button title.
    # 
    # ```ruby
    # @notification = UI::Notification.new(sketchup_extension, "Hello world")
    # @notification.on_dismiss("Close")  do |notification, title|
    #    puts "The user pressed #{notification.on_dismiss_title}"
    # end
    # @notification.show
    # ```
    def on_dismiss_title: () -> String

    # Shows the notification. If not interacted with, the notification will
    # disappear without calling any callbacks.
    # 
    # ```ruby
    # @notification = UI::Notification.new(sketchup_extension, "Hello world")
    # @notification.show
    # ```
    def show: () -> bool
  end
end

# The Geom module defines a number of Module methods that let you perform
# different geometric operations.
# 
# The methods in this module take lines
# and planes as arguments. There is no special class for representing lines or
# planes. Arrays are used for both.
# 
# A line can be represented as either an Array of a point and a
# vector, or as an Array of two points.
#   line1 = [Geom::Point3d.new(0, 0, 0), Geom::Vector3d.new(0, 0, 1)]
#   line2 = [Geom::Point3d.new(0, 0, 0), Geom::Point3d.new(0, 0, 100)]
# 
# A plane can be represented as either an Array
# of a point and a vector, or as an Array of 4 numbers that give the
# coefficients of a plane equation.
#   plane1 = [Geom::Point3d.new(0, 0, 0), Geom::Vector3d.new(0, 0, 1)]
#   plane2 = [0, 0, 1, 0]
# 
# There are several good books on 3D math if you are new to
# the concepts of a line, plane, and vector.
# 
# @note Lines and Planes are infinite.
# 
# @version SketchUp 6.0
module Geom
  # The {.closest_points} method is used to compute the closest points on two
  # lines.
  # 
  # line.
  # 
  # _@param_ `line1` — The first line to intersect
  # 
  # _@param_ `line2` — The second line to intersect
  # 
  # _@return_ — An array of two points. The
  # first point is on the first line and the second point is on the second
  # 
  # ```ruby
  # line1 = [Geom::Point3d.new(0, 2, 0), Geom::Vector3d.new(1, 0, 0)]
  # line2 = [Geom::Point3d.new(3, 0, 0), Geom::Vector3d.new(0, 1, 0)]
  # # This will return a point Point3d(3, 2, 0).
  # points = Geom.closest_points(line1, line2)
  # ```
  def self.closest_points: ([Geom::Point3d, Geom::Vector3d] line1, [Geom::Point3d, Geom::Vector3d] line2) -> [Geom::Point3d, Geom::Point3d]

  # sord omit - no YARD type given for "*args", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {.fit_plane_to_points} method is used to compute a plane that is a best
  # fit to an array of points. If more than three points are given some of the
  # points may not be on the plane.
  # 
  # The plane is returned as an {Array} of 4 numbers which are the
  # coefficients of the plane equation <code>Ax + By + Cz + D = 0</code>.
  # 
  # ```ruby
  # point1 = Geom::Point3d.new(0, 0, 0)
  # point2 = Geom::Point3d.new(10, 10, 10)
  # point3 = Geom::Point3d.new(25, 25, 25)
  # plane = Geom.fit_plane_to_points(point1, point2, point3)
  # ```
  def self.fit_plane_to_points: (*untyped args) -> untyped

  # The {.intersect_line_line} computes the intersection of two lines.
  # 
  # _@param_ `line1` — The first line to intersect.
  # 
  # _@param_ `line2` — The second line to intersect.
  # 
  # _@return_ — The intersection point. Returns +nil+ if they
  # do not intersect.
  # 
  # ```ruby
  # # Defines a line parallel to the Y axis, offset 20 units.
  # line1 = [Geom::Point3d.new(20, 0, 0), Geom::Vector3d.new(0, 1, 0)]
  # # Defines a line parallel to the X axis, offset 10 units.
  # line2 = [Geom::Point3d.new(0, 10, 0), Geom::Point3d.new(20, 10, 0)]
  # # This will return a point Point3d(20, 10, 0).
  # point = Geom.intersect_line_line(line1, line2)
  # ```
  # 
  # _@see_ `Geom` — The Geom module for alternative versions of defining a line.
  def self.intersect_line_line: ([Geom::Point3d, Geom::Vector3d] line1, [Geom::Point3d, Geom::Vector3d] line2) -> Geom::Point3d?

  # The {.intersect_line_plane} method is used to compute the intersection of a
  # line and a plane.
  # 
  # _@param_ `line`
  # 
  # _@param_ `plane`
  # 
  # _@return_ — A Point3d object. Returns +nil+ if they do not
  # intersect.
  # 
  # ```ruby
  # # Defines a line parallel to the X axis, offset 20 units.
  # line = [Geom::Point3d.new(-10, 20, 0), Geom::Vector3d.new(1, 0, 0)]
  # # Defines a plane with it's normal parallel to the x axis.
  # plane = [Geom::Point3d.new(10, 0 ,0), Geom::Vector3d.new(1, 0, 0)]
  # # This will return a point Point3d(10, 20, 0).
  # point = Geom.intersect_line_plane(line, plane)
  # ```
  # 
  # _@see_ `Geom` — The Geom module for alternative versions of defining lines and
  # planes.
  def self.intersect_line_plane: ([Geom::Point3d, Geom::Vector3d] line, [Geom::Point3d, Geom::Point3d] plane) -> Geom::Point3d?

  # The {.intersect_plane_plane} method is used to compute the intersection of
  # two planes.
  # 
  # _@param_ `plane1` — The first plane to intersect
  # 
  # _@param_ `plane2` — The second plane to intersect
  # 
  # _@return_ — A line where the planes
  # intersect if successful. Returns +nil+ if the planes do not intersect.
  # 
  # ```ruby
  # # Defines a plane with it's normal parallel to the x axis.
  # plane1 = [Geom::Point3d.new(10, 0 ,0), Geom::Vector3d.new(1, 0, 0)]
  # # Defines a plane with it's normal parallel to the y axis.
  # plane2 = [Geom::Point3d.new(0, 20 ,0), Geom::Vector3d.new(0, 1, 0)]
  # # This will return a line [Point3d(10, 20, 0), Vector3d(0, 0, 1)].
  # line = Geom.intersect_plane_plane(plane1, plane2)
  # ```
  def self.intersect_plane_plane: ([Geom::Point3d, Geom::Point3d] plane1, [Geom::Point3d, Geom::Point3d] plane2) -> [Geom::Point3d, Geom::Vector3d]

  # sord omit - no YARD type given for "weight1", using untyped
  # sord omit - no YARD type given for "pt_or_vect1", using untyped
  # sord omit - no YARD type given for "weight2", using untyped
  # sord omit - no YARD type given for "pt_or_vect2", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {.linear_combination} method is used to compute the linear combination of
  # points or vectors.
  # 
  # A linear combination is a standard term for vector math. It is defined as
  # vector = weight1 * vector1 + weight2 * vector2.
  # 
  # ```ruby
  # point1 = Geom::Point3d.new(1, 1, 1)
  # point2 = Geom::Point3d.new(10, 10, 10)
  # # Gets the point on the line segment connecting point1 and point2 that is
  # # 3/4 the way from point1 to point2: Point3d(7.75, 7.75, 7.75).
  # point = Geom.linear_combination(0.25, point1, 0.75, point2)
  # ```
  def self.linear_combination: (
                                 untyped weight1,
                                 untyped pt_or_vect1,
                                 untyped weight2,
                                 untyped pt_or_vect2
                               ) -> untyped

  # The {.point_in_polygon_2D} method is used to determine whether a point is
  # inside a polygon. The z component of both the point you're checking and
  # the points in the polygon are ignored, effectively making it a 2-d check.
  # 
  # _@param_ `point`
  # 
  # _@param_ `polygon` — An array of points that represent the corners of the polygon you are checking against.
  # 
  # _@param_ `check_border` — Pass true if a point on the border should be counted as inside the polygon.
  # 
  # _@return_ — +true+ if the point is inside the polygon.
  # 
  # ```ruby
  # # Create a point that we want to check. (Note that the 3rd coordinate,
  # # the z, is ignored for purposes of the check.)
  # point = Geom::Point3d.new(5, 0, 10)
  # 
  # # Create a series of points of a triangle we want to check against.
  # triangle = []
  # triangle << Geom::Point3d.new(0, 0, 0)
  # triangle << Geom::Point3d.new(10, 0, 0)
  # triangle << Geom::Point3d.new(0, 10, 0)
  # 
  # # Test to see if our point is inside the triangle, counting hits on
  # # the border as an intersection in this case.
  # hits_on_border_count = true
  # status = Geom.point_in_polygon_2D(point, triangle, hits_on_border_count)
  # ```
  def self.point_in_polygon_2D: (Geom::Point3d point, ::Array[Geom::Point3d] polygon, bool check_border) -> bool

  # Tessellates a polygon, represented as a collection of 3D points. Can include
  # holes by providing collections of points describing the inner loops. This is
  # intended to be used for planar polygons.
  # 
  # Useful to draw concave polygons using {Sketchup::View#draw} or
  # {Sketchup::View#draw2d}.
  # 
  # It can also be useful for importers where the input format describes only the
  # loops for a polygon and you want to work with a collection of triangles.
  # 
  # <b>Polygon with two holes, one empty and one filled:</b>
  # 
  # <i>(See "Drawing a polygon with holes from a custom tool" example)</i>
  # 
  # rdoc-image:images/geom-tesselation-polygon-with-holes.png
  # 
  # _@param_ `polygon_loop_points`
  # 
  # _@param_ `inner_loop_points`
  # 
  # _@return_ — an array of points with a stride of three
  # representing a set of triangles.
  # 
  # Iterate over each triangle in the returned set
  # ```ruby
  # polygon = [
  #   Geom::Point3d.new(0, 0, 0),
  #   Geom::Point3d.new(90, 0, 0),
  #   Geom::Point3d.new(60, 40, 0),
  #   Geom::Point3d.new(90, 90, 0),
  #   Geom::Point3d.new(30, 70, 0),
  # ]
  # triangles = Geom.tesselate(polygon)
  # triangles.each_slice(3) { |triangle|
  #   # Work with each triangle set...
  # }
  # # Or get an array of triangles:
  # triangles_set = triangles.each_slice(3).to_a
  # ```
  # 
  # Drawing a polygon with holes from a custom tool
  # ```ruby
  # class ExampleTool
  # 
  #   def initialize
  #     polygon = [
  #       Geom::Point3d.new(0, 0, 0),
  #       Geom::Point3d.new(90, 0, 0),
  #       Geom::Point3d.new(60, 40, 0),
  #       Geom::Point3d.new(90, 90, 0),
  #       Geom::Point3d.new(30, 70, 0),
  #     ] # Counter-clockwise order
  #     hole1 = [
  #       Geom::Point3d.new(20, 10, 0),
  #       Geom::Point3d.new(40, 10, 0),
  #       Geom::Point3d.new(45, 25, 0),
  #       Geom::Point3d.new(30, 20, 0),
  #       Geom::Point3d.new(25, 25, 0),
  #     ].reverse # Clockwise order - empty hole
  #     hole2 = [
  #       Geom::Point3d.new(30, 40, 0),
  #       Geom::Point3d.new(50, 40, 0),
  #       Geom::Point3d.new(50, 50, 0),
  #       Geom::Point3d.new(30, 50, 0),
  #     ].reverse # Counter-clockwise order - filled hole
  #     @triangles = Geom.tesselate(polygon, hole1, hole2)
  #   end
  # 
  #   def activate
  #     Sketchup.active_model.active_view.invalidate
  #   end
  # 
  #   def onMouseMove(flags, x, y, view)
  #     view.invalidate
  #   end
  # 
  #   def getExtents
  #     bounds = Geom::BoundingBox.new
  #     bounds.add(@triangles)
  #     bounds
  #   end
  # 
  #   def draw(view)
  #     view.drawing_color = Sketchup::Color.new(192, 0, 0)
  #     view.draw(GL_TRIANGLES, @triangles)
  #   end
  # 
  # end
  # 
  # Sketchup.active_model.select_tool(ExampleTool.new)
  # ```
  # 
  # _@note_ — The winding order of the polygons matter. The outer loop should be
  # in counter-clockwise order. To cut an empty hole the inner loops should be
  # in clockwise order, otherwise they will create a loop filled with
  # triangles.
  # 
  # _@note_ — The tesselation is using the same logic as SketchUp its rendering
  # pipeline. But the exact result is an implementation detail which may change
  # between versions. In particularly the results of degenerate polygons and
  # non-planar  polygons is undefined  as part of the API contract. Such
  # polygons are for example polygons where all points are colinear, polygons
  # with duplicate points, non-planar polygons.
  # 
  # _@note_ — If you want the triangles from an existing {Sketchup::Face} it's better
  # to use {Sketchup::Face#mesh}.
  # 
  # _@see_ `Sketchup::View#draw`
  # 
  # _@see_ `Sketchup::View#draw2d`
  def self.tesselate: (::Array[Geom::Point3d] polygon_loop_points, *::Array[::Array[Geom::Point3d]] inner_loop_points) -> ::Array[Geom::Point3d]

  # The UTM class lets you work with UTM map coordinates.
  # 
  # @note Valid ranges for {#zone_number} and {#zone_letter} are 1-60 and C-X
  #   (omitting I and O). Valid ranges for {#x} and {#y} are 100000-899999.
  # 
  # @version SketchUp 6.0
  class UTM
    # sord omit - no YARD type given for "*args", using untyped
    # The {#initialize} method is used to create a new UTM coordinate. You will
    # often create UTM objects by calling the method {Sketchup::Model#point_to_utm}
    # instead of calling this method.
    # 
    # ```ruby
    # # Create a copy of an existing UTM object.
    # utm = Geom::UTM.new(utm2)
    # 
    # # Create a new UTM object from scratch.
    # utm = Geom::UTM.new(13, "T", 475849.37521, 4429682.73749)
    # ```
    def initialize: (*untyped args) -> void

    # The {#to_a} method returns a UTM coordinate as a 4 element array. The Array
    # elements are the zone number, the zone letter, the x coordinate and the y
    # coordinate.
    # 
    # ```ruby
    # # Create a new UTM object from scratch.
    # utm = Geom::UTM.new(13, "T", 475849.37521, 4429682.73749)
    # a = utm.to_a
    # ```
    def to_a: () -> [Integer, String, Float, Float]

    # The {#to_latlong} method is used to convert UTM coordinates to latitude
    # and longitude. See the LatLong class for more information.
    # 
    # ```ruby
    # # Create a new UTM object from scratch.
    # utm = Geom::UTM.new(13, "T", 475849.37521, 4429682.73749)
    # ll = utm.to_latlong
    # ```
    def to_latlong: () -> Geom::LatLong

    # The {#to_s} method is used to retrieve a string representation of a UTM.
    # 
    # ```ruby
    # # Create a new UTM object from scratch.
    # utm = Geom::UTM.new(13, "T", 475849.37521, 4429682.73749)
    # string = utm.to_s
    # ```
    def to_s: () -> String

    # The {#x} method returns the UTM x coordinate.
    # 
    # ```ruby
    # # Create a new UTM object from scratch.
    # utm = Geom::UTM.new(13, "T", 475849.37521, 4429682.73749)
    # x = utm.x
    # ```
    def x: () -> Float

    # The {#y} method returns the UTM y coordinate.
    # 
    # ```ruby
    # # Create a new UTM object from scratch.
    # utm = Geom::UTM.new(13, "T", 475849.37521, 4429682.73749)
    # y = utm.y
    # ```
    def y: () -> Float

    # The {#zone_letter} method returns the UTM zone letter.
    # 
    # ```ruby
    # # Create a new UTM object from scratch.
    # utm = Geom::UTM.new(13, "T", 475849.37521, 4429682.73749)
    # zl = utm.zone_letter
    # ```
    def zone_letter: () -> String

    # The {#zone_number} method returns the UTM zone number.
    # 
    # ```ruby
    # # Create a new UTM object from scratch.
    # utm = Geom::UTM.new(13, "T", 475849.37521, 4429682.73749)
    # zn = utm.zone_number
    # ```
    def zone_number: () -> Integer
  end

  # The LatLong class contains various methods for creating and manipulating
  # latitude and longitude coordinates.
  # 
  # @version SketchUp 6.0
  class LatLong
    # sord omit - no YARD type given for "*args", using untyped
    # The new method creates a LatLong object.
    # 
    # ```ruby
    # ll = [40.01700, 105.28300]
    # latlong = Geom::LatLong.new(ll)
    # if (latlong)
    #   UI.messagebox(latlong)
    # else
    #   UI.messagebox("Failure")
    # end
    # ```
    def initialize: (*untyped args) -> void

    # The Latitude method retrieves the latitude coordinate from a LatLong object.
    # 
    # _@return_ — a latitude coordinate value
    # 
    # ```ruby
    # ll = [40.01700, 105.28300]
    # latlong = Geom::LatLong.new(ll)
    # latitude = latlong.latitude
    # if (latitude)
    #   UI.messagebox(latitude)
    # else
    #   UI.messagebox("Failure")
    # end
    # ```
    def latitude: () -> Float

    # The Latitude method retrieves the longitude coordinate from a LatLong
    # object.
    # 
    # _@return_ — a latitude coordinate value
    # 
    # ```ruby
    # ll = [40.01700, 105.28300]
    # latlong = Geom::LatLong.new(ll)
    # longitude = latlong.longitude
    # if (longitude)
    #   UI.messagebox(longitude)
    # else
    #   UI.messagebox("Failure")
    # end
    # ```
    def longitude: () -> Float

    # The {#to_a} method converts a LatLong object to an array of two values.
    # 
    # _@return_ — an array of latitude and longitude
    # 
    # ```ruby
    # latlong = Geom::LatLong.new([40.01700, 105.28300])
    # array = latlong.to_a
    # ```
    def to_a: () -> [Float, Float]

    # The {#to_s} method converts a LatLong object to a {String}.
    # 
    # ```ruby
    # latlong = Geom::LatLong.new([40.01700, 105.28300])
    # string = latlong.to_s
    # ```
    def to_s: () -> String

    # The to_utm method converts a LatLong object to a UTM object.
    # 
    # ```ruby
    # ll = [40.01700, 105.28300]
    # latlong = Geom::LatLong.new(ll)
    # utm = latlong.to_utm
    # if (utm)
    #   UI.messagebox(utm)
    # else
    #   UI.messagebox("Failure")
    # end
    # ```
    def to_utm: () -> Geom::UTM
  end

  # The {Geom::Point2d} class allows you to work with a point in 2D space.
  # {Geom::Point2d} is a series of values representing x and y coordinates.
  # 
  # The values are specified as +[x, y]+. For example [1, 1].
  # To create a point call +Geom::Point2d.new+, where the creation method
  # can take a variety of arguments:
  # 
  # @example
  #   # No arguments, creates a point at the origin [0, 0]
  #   pt1 = Geom::Point2d.new
  # 
  #   # Creates a point at x of 1, y of 2.
  #   pt2 = Geom::Point2d.new(1, 2)
  # 
  #   # You can also create a point directly by simply assigning the x, and y
  #   # values to a variable as an array:
  #   pt3 = [1, 2]
  # 
  # @version LayOut 2018
  class Point2d
    # The {#+} operator is a simple way to add to the current x and y values of the
    # {Geom::Point2d}, or to set the values of the {Geom::Point2d} by adding a
    # {Geom::Vector2d} to the {Geom::Point2d}.
    # 
    # _@param_ `vector`
    # 
    # ```ruby
    # pt = [1, 1]
    # # the result is a Point2d(2, 3)
    # pt2 = pt + [1, 2]
    # ```
    def +: ((Geom::Vector2d | [Numeric, Numeric]) vector) -> Geom::Point2d

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#-} operator is a simple way to subtract from the current x and y values
    # of the {Geom::Point2d}.
    # 
    # ```ruby
    # vec = Geom::Vector2d.new(1, 2)
    # # result is a Point2d(3, 0)
    # pt = [4, 2] - vec
    # # result is a Vector2d(1, 2)
    # vec2 = [4, 2] - pt
    # ```
    def -: (untyped arg) -> untyped

    # The {#==} method compares two points for equality. This uses the standard
    # SketchUp tolerance to determine if two points are the same.
    # 
    # _@param_ `point`
    # 
    # ```ruby
    # point1 = Geom::Point2d.new(1, 1)
    # point2 = Geom::Point2d.new(0, 1)
    # status = point1 == point2
    # ```
    def ==: ((Geom::Point2d | [Numeric, Numeric]) point) -> bool

    # The {#[]} method returns the value of the {Geom::Point2d} at the specified
    # index.
    # 
    # _@param_ `index` — The index for a specific x or y value in the {Geom::Point2d}
    # 
    # _@return_ — The new x or y value if successful
    # 
    # ```ruby
    # point = Geom::Point2d.new(1, 2)
    # 
    # # returns the y value of 2
    # yvalue = point[1]
    # ```
    def []: (Integer index) -> Length

    # The {#[]=} method sets the x or y value of the {Geom::Point2d} based on the
    # specific index of the value.
    # 
    # _@param_ `index` — The index for a specific x or y value in the {Geom::Point2d} to set
    # 
    # _@param_ `value` — The value to set for x or y
    # 
    # _@return_ — The new x or y value if successful
    # 
    # ```ruby
    # point = Geom::Point2d.new(1,2)
    # point[1] = 4
    # ```
    def []=: (Integer index, Numeric value) -> Numeric

    # The {#clone} method creates another point identical to the {Geom::Point2d}
    # being cloned.
    # 
    # _@return_ — the cloned {Geom::Point2d} object
    # 
    # ```ruby
    # point = Geom::Point2d.new(1, 2)
    # newpoint = point.clone
    # ```
    def clone: () -> Geom::Point2d

    # The {#distance} method computes the distance from the {Geom::Point2d} to
    # another {Geom::Point2d}.
    # 
    # _@param_ `point`
    # 
    # _@return_ — the distance between the points in the current units
    # 
    # ```ruby
    # point1 = Geom::Point2d.new(1, 1)
    # point2 = Geom::Point2d.new(1, 4)
    # # result is a value of 3
    # distance = point1.distance(point2)
    # ```
    def distance: ((Geom::Point2d | [Numeric, Numeric]) point) -> Numeric

    # sord omit - no YARD type given for "*args", using untyped
    # The {.new} method creates a new {Geom::Point2d}.
    # 
    # ```ruby
    # # No arguments, creates a point at the origin [0, 0]
    # pt1 = Geom::Point2d.new
    # 
    # # Creates a point at x of 1 and y of 2.
    # pt2 = Geom::Point2d.new(1, 2)
    # 
    # # You can also create a point directly by simply assigning the x and y
    # # values to a variable as an array:
    # pt3 = [1, 2]
    # ```
    def initialize: (*untyped args) -> void

    # The {#inspect} method formats the {Geom::Point2d} as a string.
    # 
    # ```ruby
    # point = Geom::Point2d.new(1, 2)
    # string = point.inspect
    # ```
    def inspect: () -> String

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#offset} method offsets the {Geom::Point2d} by a {Geom::Vector2d} and
    # returns a new {Geom::Point2d}. If distance is provided, it must be non-zero.
    # 
    # ```ruby
    # point = Geom::Point2d.new
    # vector = Geom::Vector2d.new(0, 2)
    # # result is a Point2d(0, 1)
    # point2 = point1.offset(vector, 1)
    # ```
    def offset: (*untyped args) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#offset!} method offsets the {Geom::Point2d} by a {Geom::Vector2d}.
    # The {Geom::Point2d} itself is modified. The length of the vector must not be
    # zero.
    # 
    # ```ruby
    # point = Geom::Point2d.new
    # vector = Geom::Vector2d.new(0, 2)
    # # result is a Point2d(0, 1)
    # point1.offset!(vector, 1)
    # ```
    def offset!: (*untyped args) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#set!} method sets the values of the {Geom::Point2d}.
    # 
    # ```ruby
    # point = Geom::Point2d.new(1, 2)
    # point = point.set!([4, 5])
    # ```
    def set!: (*untyped args) -> untyped

    # The {#to_a} method converts the {Geom::Point2d} to an array of 2 numbers.
    # 
    # _@return_ — an array of two numbers representing x, y
    # of the {Geom::Point2d}
    # 
    # ```ruby
    # point = Geom::Point2d.new(1, 2)
    # array = point.to_a
    # ```
    def to_a: () -> [Numeric, Numeric]

    # The {#to_s} method returns a string representation of the {Geom::Point2d}.
    # 
    # ```ruby
    # point = Geom::Point2d.new(1, 2)
    # str = point.to_s
    # ```
    def to_s: () -> String

    # The {#transform} method applies a transformation to a point, returning a new
    # point. The original point is unchanged by this method.
    # 
    # _@param_ `transform` — A Transformation object to apply to the point.
    # 
    # _@return_ — the transformed point
    # 
    # ```ruby
    # point = Geom::Point2d.new(4, 5)
    # transformation = Geom::Transformation2d.new([1, 0, 0, 1, 2, 3])
    # # pt will be (6, 8)
    # pt = point.transform(transformation)
    # ```
    def transform: (Geom::Transformation2d transform) -> Geom::Point2d

    # The {#transform!} method applies a transformation to a point. The point
    # itself is modified.
    # 
    # _@param_ `transform` — A Transformation object to apply to the point.
    # 
    # _@return_ — the transformed point
    # 
    # ```ruby
    # point = Geom::Point2d.new(4, 5)
    # transformation = Geom::Transformation2d.new([1, 0, 0, 1, 2, 3])
    # # point will be (6, 8)
    # point.transform!(transformation)
    # ```
    def transform!: (Geom::Transformation2d transform) -> Geom::Point2d

    # The {#vector_to} method returns the vector between points.
    # 
    # _@param_ `point`
    # 
    # ```ruby
    # pt1 = Geom::Point2d.new(1, 1)
    # pt2 = Geom::Point2d.new(3, 1)
    # 
    # # result is a Vector2d(2, 0)
    # vec = pt1.vector_to(pt2) # is equivalent to (pt2 - pt1)
    # ```
    def vector_to: (Geom::Point2d point) -> Geom::Vector2d

    # The {#x} method returns the x value of the {Geom::Point2d}.
    # 
    # _@return_ — the x value of the {Geom::Point2d}
    # 
    # ```ruby
    # point = Geom::Point2d.new(1, 2)
    # x = point.x
    # ```
    def x: () -> Length

    # The {#x=} method sets the x value of the {Geom::Point2d}.
    # 
    # _@param_ `x` — The desired x value of the {Geom::Point2d}
    # 
    # _@return_ — The new x value of the {Geom::Point2d}
    # 
    # ```ruby
    # point = Geom::Point2d.new(1, 2)
    # point.x = 7
    # ```
    def x=: (Numeric x) -> Numeric

    # The {#y} method returns the y value of the {Geom::Point2d}.
    # 
    # _@return_ — The y value of the {Geom::Point2d}
    # 
    # ```ruby
    # point = Geom::Point2d.new(1, 2)
    # y = point.y
    # ```
    def y: () -> Length

    # The {#y=} method sets the y value of the {Geom::Point2d}.
    # 
    # _@param_ `y` — The desired y value of the {Geom::Point2d}
    # 
    # _@return_ — The new y value of the {Geom::Point2d}
    # 
    # ```ruby
    # point = Geom::Point2d.new(1, 2)
    # point.y = 7
    # ```
    def y=: (Numeric y) -> Numeric
  end

  # The Point3d class allows you to work with a point in 3D space.
  # The point is basically just a series of values representing x, y and z
  # coordinates.
  # 
  # The values are specified as [x,y,z]. For example [100,200,300].
  # To create a point call Geom::Point3d.new, where the creation method
  # can take a variety of arguments:
  # 
  # In addition to the methods below, there are a series of geometry
  # related methods that are on the Array class, since Point3d objects
  # can also be represented as a 3-element Array. These Array-level methods are
  # for operations such as determining if a point is on a line, on a plane, etc.
  # See the Array class for details.
  # 
  # @example
  #   # No arguments, creates a point at the origin [0,0,0]
  #   pt1 = Geom::Point3d.new
  # 
  #   # Creates a point at x of 100, y of 200, z of 300.
  #   pt2 = Geom::Point3d.new(100,200,300)
  # 
  #   # You can also create a point directly by simply assigning the x, y and z
  #   # values to a variable as an array:
  #   pt3 = [100,200,300]
  # 
  # @version SketchUp 6.0
  class Point3d
    # The {.linear_combination} method is used to create a new point as a linear
    # combination of two points.
    # 
    # This method is generally used to get a point at
    # some percentage along a line connecting the two points.
    # 
    # A linear combination is a standard term for vector math. It is defined as
    # point = weight1 * point1 + weight2 * point2.
    # 
    # _@param_ `weight1`
    # 
    # _@param_ `point1`
    # 
    # _@param_ `weight2`
    # 
    # _@param_ `point2`
    # 
    # ```ruby
    # point1 = Geom::Point3d.new(1,1,1)
    # point2 = Geom::Point3d.new(10,10,10)
    # 
    # # Get the point that is half the way from point1 to point2.
    # points = Geom::Point3d.linear_combination(0.5, point1, 0.5, point2)
    # 
    # # Get the point that is 3/4 the way from point1 to point2.
    # point = Geom::Point3d.linear_combination(0.25, point1, 0.75, point2)
    # 
    # # Get the point that is 70% the way from point1 to point2.
    # percentage = 0.7
    # point = Geom::Point3d.linear_combination(1.0 - percentage, point1, percentage, point2)
    # ```
    def self.linear_combination: (
                                   Float weight1,
                                   Geom::Point3d point1,
                                   Float weight2,
                                   Geom::Point3d point2
                                 ) -> Geom::Point3d

    # The {#+} operator is a fast way to add to the current x, y and z values of
    # a vector.
    # 
    # _@param_ `vector`
    # 
    # Using vector
    # ```ruby
    # point1 = Geom::Point3d.new(1, 2, 3)
    # vector = Geom::Vector3d.new(4, 5, 6)
    # point2 = point1 + vector
    # ```
    # 
    # Using array
    # ```ruby
    # point1 = Geom::Point3d.new(1, 2, 3)
    # point2 = point1 + [10,10,10]
    # ```
    # 
    # Using point
    # ```ruby
    # point1 = Geom::Point3d.new(1, 2, 3)
    # point2 = Geom::Point3d.new(4, 5, 6)
    # # This works because SketchUp treats the array of triple numerics as
    # # a vector in this case.
    # point3 = point1 + point2.to_a
    # ```
    def +: (Geom::Vector3d vector) -> Geom::Point3d

    # The '-' operator is a fast way to subtract from the current x, y and z values
    # of a point.
    # 
    # _@param_ `point2` — A Point3d object.
    # 
    # ```ruby
    # pt2 = pt - vec
    # pt = pt - [10,10,10]
    # ```
    def -: (Geom::Point3d point2) -> Geom::Vector3d

    # The '<' operator is a fast way to determine if another point is closer to the
    # origin.
    # 
    # _@param_ `point2` — A Point3d object.
    # 
    # _@return_ — true if the point2 is closer to the origin.
    # 
    # ```ruby
    # pt1 = Geom::Point3d.new(10,10,10)
    # pt2 = Geom::Point3d.new(20,20,20)
    # result = pt1 < pt2
    # ```
    def <: (Geom::Point3d point2) -> bool

    # The == method is used to compare two points for equality.
    # 
    # This uses the standard SketchUp tolerance to determine if two points are the
    # same.
    # 
    # Points can be compared to one another or to an array representing
    # x, y and z coordinates, as in the following examples:
    # 
    # _@param_ `point2` — A Point3d object.
    # 
    # _@return_ — true if both points are equal; false if points are not
    # equal
    # 
    # ```ruby
    # if( pt1 == pt2 )
    #   UI.messagebox('equal')
    # end
    # 
    # # ... or ...
    # if( pt1 == [100,200,300] ) ...
    #   UI.messagebox('equal')
    # end
    # ```
    # 
    # ```ruby
    # point1 = Geom::Point3d.new(1,1,1)
    # point2 = Geom::Point3d.new(10,10,10)
    # status = point1 == point2
    # ```
    def ==: (Geom::Point3d point2) -> bool

    # The [] method is used to retrieve the value of the point at the specified
    # index.
    # 
    # _@param_ `index` — The index for a specific x, y, or z value within the Point3d.
    # 
    # _@return_ — an x, y, or z value if successful
    # 
    # ```ruby
    # point = Geom::Point3d.new(1, 2, 3)
    # 
    # # retrieves the y value of 2
    # yvalue = point[1]
    # ```
    def []: (Integer index) -> Length

    # The []= method is used to set the x, y, or z value of the point based on the
    # specific index of the value.
    # 
    # _@param_ `index` — The index for a specific x, y, or z value within the Point3d.
    # 
    # _@param_ `new_value` — New x, y, or z value.
    # 
    # _@return_ — the newly set x, y, or z value if successful
    # 
    # ```ruby
    # point = Geom::Point3d.new(1,2,3)
    # yvalue = point[1] = 4
    # ```
    def []=: (Integer index, Numeric new_value) -> Numeric

    # The clone method is used to create another point identical to the point
    # being cloned.
    # 
    # _@return_ — the cloned Point3d object
    # 
    # ```ruby
    # point = Geom::Point3d.new(1,2,3)
    # newpoint = point.clone
    # ```
    def clone: () -> Geom::Point3d

    # The distance method is used to compute the distance from a point to another
    # point.
    # 
    # _@param_ `point2` — The Point3d object to compute the distance to.
    # 
    # ```ruby
    # point1 = Geom::Point3d.new(1,1,1)
    # point2 = Geom::Point3d.new(10,10,10)
    # distance = point1.distance(point2)
    # ```
    def distance: (Geom::Point3d point2) -> Length

    # The distance_to_line method is used to compute the distance from a point to
    # a line.
    # 
    # See Geom module for how to specify a line.
    # 
    # _@param_ `line` — A line (see Geom for information on creating lines).
    # 
    # _@return_ — the distance between a point and line in
    # internal units if successful
    # 
    # ```ruby
    # point1 = Geom::Point3d.new(1,1,1)
    # line = [Geom::Point3d.new(0,0,0), Geom::Vector3d.new(0,0,1)]
    # distance = point1.distance_to_line(line)
    # ```
    # 
    # _@note_ — This function returns a `Float` value, not a `Length`.
    def distance_to_line: (untyped line) -> Float

    # The distance_to_plane method is used to compute the distance from the point
    # to a plane.
    # 
    # See module Geom for how to specify a plane.
    # 
    # _@param_ `plane` — A plane (see Geom for how to create a plane).
    # 
    # _@return_ — a distance between a point and a plane in
    # internal units if successful
    # 
    # ```ruby
    # distance = point.distance_to_plane(plane)
    # ```
    # 
    # _@note_ — This function returns a `Float` value, not a `Length`.
    def distance_to_plane: (untyped plane) -> Float

    # sord omit - no YARD type given for "*args", using untyped
    # The new method is used to create a new 3D point.
    # 
    # ```ruby
    # # No arguments, creates a point at the origin [0,0,0]
    # pt1 = Geom::Point3d.new
    # 
    # # Creates a point at x of 100, y of 200, z of 300.
    # pt2 = Geom::Point3d.new(100,200,300)
    # 
    # # You can also create a point directly by simply assigning the x, y and z
    # # values to a variable as an array:
    # pt3 = [100,200,300]
    # ```
    def initialize: (*untyped args) -> void

    # The inspect method is used to format a 3D point as a string.
    # 
    # You will not often use these function directly. Instead, they are called
    # automatically when an object is output using a print command like 'puts',
    # which writes to the Ruby console.
    # 
    # _@return_ — a string point representation
    # 
    # ```ruby
    # point = Geom::Point3d.new(10,10,10)
    # string = point.inspect
    # ```
    def inspect: () -> String

    # The offset method is used to offset a point by a vector and return a new
    # point. The length of the vector must not be zero.
    # 
    # _@param_ `vector` — A Vector3d object to offset the point by.
    # 
    # _@param_ `length` — the distance to offset. If not provided, the offset is my a distance equal to the vector length.
    # 
    # _@return_ — - a new Point3d object
    # 
    # ```ruby
    # point1 = Geom::Point3d.new(10,10,10)
    # vector = Geom::Vector3d.new(0, 0, 1)
    # point2 = point1.offset(vector)
    # ```
    def offset: (Geom::Vector3d vector, ?Numeric length) -> Geom::Point3d

    # The offset! method is used to offset a point by a vector. The point itself
    # is modified.
    # 
    # Unlike offset, the point itself is modified.
    # 
    # _@param_ `vector` — A Vector3d object to offset the point by.
    # 
    # _@param_ `length` — the distance to offset. If not provided, the offset is my a distance equal to the vector length.
    # 
    # _@return_ — a new Point3d object
    # 
    # ```ruby
    # point1 = Geom::Point3d.new(10,10,10)
    # vector = Geom::Vector3d.new(0,0,1)
    # point2 = point1.offset!(vector)
    # ```
    def offset!: (Geom::Vector3d vector, ?Numeric length) -> Geom::Point3d

    # The on_line? method is used to determine if the point is on a line.
    # 
    # See module Geom for the various ways to specify a line.
    # 
    # _@param_ `line` — A line (see Geom for how to create a line).
    # 
    # ```ruby
    # line = [Geom::Point3d.new(0,0,0), Geom::Vector3d.new(0,0,1)]
    # point = Geom::Point3d.new(10,10,10)
    # status = point.on_line?(line)
    # ```
    def on_line?: (untyped line) -> bool

    # The on_plane? method is used to determine if the point is on a plane.
    # 
    # See module Geom for the various ways to specify a plane.
    # 
    # _@param_ `plane`
    # 
    # ```ruby
    # plane = [Geom::Point3d.new(0,0,0), Geom::Vector3d.new(0,0,1)]
    # point = Geom::Point3d.new(10,10,10)
    # status = point.on_plane?(plane)
    # ```
    def on_plane?: (untyped plane) -> bool

    # The project_to_line method is used to retrieve the point on a line that is
    # closest to this point.
    # 
    # The line may be defined by either a point and a vector or by two points.
    # 
    # _@param_ `line` — see Geom for how to specify a line
    # 
    # _@return_ — the Point3d that is on a line closest to the
    # point
    # 
    # ```ruby
    # line = [Geom::Point3d.new(0,0,0), Geom::Vector3d.new(0,0,1)]
    # point = Geom::Point3d.new(10,10,10)
    # projected_point = point.project_to_line(line)
    # ```
    def project_to_line: (untyped line) -> Geom::Point3d

    # The project_to_plane method is used to retrieve the point on a plane that is
    # closest to the point.
    # 
    # The plane may be defined by either a point on the plane and a vector
    # perpendicular to the plane or by the coeficients to the plane equation AX +
    # BY + CZ + D = 0. See Geom for details.
    # 
    # _@param_ `plane` — A plane (see Geom for how to create a plane).
    # 
    # _@return_ — the Point3d that is on a plane closest to the
    # point
    # 
    # ```ruby
    # plane = [Geom::Point3d.new(0,0,0), Geom::Vector3d.new(0,0,1)]
    # point = Geom::Point3d.new(10,10,10)
    # projected_point = point.project_to_plane(plane)
    # ```
    def project_to_plane: (untyped plane) -> Geom::Point3d

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#set!} method is used to set the values of the Point3d.
    # 
    # ```ruby
    # point = Geom::Point3d.new(10,10,10)
    # point = point.set!(100,200,300)
    # ```
    def set!: (*untyped args) -> untyped

    # The to_a method is used to convert the point to an array of 3 numbers
    # 
    # _@return_ — an array of three numbers representing x,y,z of
    # the Point3d
    # 
    # ```ruby
    # point = Geom::Point3d.new(10,20,30)
    # array = point.to_a
    # 
    # pt = [100,200,300]
    # # outputs [100.0,200.0,300.0]
    # UI.messagebox(pt.to_a)
    # ```
    def to_a: () -> [Length, Length, Length]

    # The to_s method is used to retrieve a string representation of a point.
    # 
    # _@return_ — the string representation of the Point3d
    # 
    # ```ruby
    # point = Geom::Point3d.new(10,10,10)
    # str = point.to_s
    # ```
    def to_s: () -> String

    # Apply a Transformation to a point, returning a new point. The original
    # vector is unchanged by this method.
    # 
    # _@param_ `transform` — A Transformation object.
    # 
    # _@return_ — the newly transformed point
    # 
    # ```ruby
    # transform = Geom::Transformation.new(point2)
    # point2 = Geom::Point3d.new(100,200,300)
    # point1 = Geom::Point3d.new(10,10,10)
    # point3 = point1.transform(transform)
    # ```
    def transform: (Geom::Transformation transform) -> Geom::Point3d

    # Apply a Transformation to a point. The point itself is modified.
    # 
    # _@param_ `transform` — A Transformation object.
    # 
    # _@return_ — the transformed point
    # 
    # ```ruby
    # transform = Geom::Transformation.new(point2)
    # point2 = Geom::Point3d.new(100,200,300)
    # point1 = Geom::Point3d.new(10,10,10)
    # point1.transform!(transform)
    # ```
    def transform!: (Geom::Transformation transform) -> Geom::Point3d

    # The vector_to team method retrieves the vector between points.
    # 
    # _@param_ `point2` — A Point3d object.
    # 
    # _@return_ — a Vector object
    # 
    # ```ruby
    # point2 = Geom::Point3d.new(100,200,300)
    # point1 = Geom::Point3d.new(10,10,10)
    # vector = point1.vector_to(point2)
    # 
    # # Another example...
    # pt1 = [1,1,0]
    # pt2 = [3,1,0]
    # pt1.vector_to(pt2) # returns the vector (2,0,0)
    # pt1.vector_to(pt2) # is equivalent to (pt2 - pt1)
    # ```
    def vector_to: (Geom::Point3d point2) -> Geom::Vector3d

    # The x method retrieves the x value of the 3D point.
    # 
    # _@return_ — the x value
    # 
    # ```ruby
    # point = Geom::Point3d.new(1,2,3)
    # x = point.x
    # ```
    def x: () -> Length

    # The x= method is used to set the x value of a 3D point.
    # 
    # _@param_ `value` — The new x value.
    # 
    # _@return_ — the newly set x value
    # 
    # ```ruby
    # point = Geom::Point3d.new(1,2,3)
    # x = point.x = 2
    # ```
    def x=: (Numeric value) -> Numeric

    # The y method retrieves the y value of the 3D point.
    # 
    # _@return_ — the y value
    # 
    # ```ruby
    # point = Geom::Point3d.new(1,2,3)
    # y = point.y
    # ```
    def y: () -> Length

    # The y= method is used to set the y value of a 3D point.
    # 
    # _@param_ `value` — The new y value.
    # 
    # _@return_ — the newly set y value
    # 
    # ```ruby
    # point = Geom::Point3d.new(1,2,3)
    # y = point.y = 2
    # ```
    def y=: (Numeric value) -> Numeric

    # The z method retrieves the z value of the 3D point.
    # 
    # _@return_ — the z value
    # 
    # ```ruby
    # point = Geom::Point3d.new(1,2,3)
    # z = point.x
    # ```
    def z: () -> Length

    # The z= method is used to set the z value of a 3D point.
    # 
    # _@param_ `value` — The new z value.
    # 
    # _@return_ — the newly set z value
    # 
    # ```ruby
    # point = Geom::Point3d.new(1,2,3)
    # z = point.z = 2
    # ```
    def z=: (Numeric value) -> Numeric
  end

  # The bounds2d class represents an axis aligned bounding box represented by
  # two {Geom::Point2d} objects, upper left and lower right positions. The
  # units utilized in the creation and modification {Geom::Bounds2d} are inches.
  # 
  # @version LayOut 2018
  class Bounds2d
    # The {#==} method checks to see if the two {Geom::Bounds2d}s are equal. This
    # checks whether the point values are the same
    # 
    # _@param_ `other`
    # 
    # ```ruby
    # entity.bounds == entity.untransformed_bounds
    # ```
    def ==: (Geom::Bounds2d other) -> bool

    # The {#height} method returns the height of the {Geom::Bounds2d}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(0.0, 0.0, 1.0, 1.0)
    # height = bounds.height
    # ```
    def height: () -> Geom::Point2d

    # sord omit - no YARD type given for "*args", using untyped
    # The {#initialize} method creates a new {Geom::Bounds2d}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(0.0, 0.0, 1.0, 1.0)
    # ```
    def initialize: (*untyped args) -> void

    # The {#lower_right} method returns the {Geom::Point2d} of the lower right
    # corner of the {Geom::Bounds2d}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(0.0, 0.0, 1.0, 1.0)
    # l_r = bounds.lower_right
    # ```
    def lower_right: () -> Geom::Point2d

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#set!} method sets the {Geom::Bounds2d} to match another one.
    # The argument is anything that can be converted into a {Geom::Bounds2d}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(3.0, 3.0, 5.0, 5.0)
    # bounds.set!(Geom::Point2d.new(0.0, 0.0), Geom::Point2d.new(2.0, 2.0))
    # ```
    def set!: (*untyped args) -> untyped

    # The {#to_a} method returns an array which contains the {Geom::Point2d} that
    # define the {Geom::Bounds2d}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new
    # bounds.to_a.each { |point| p point.to_s }
    # ```
    def to_a: () -> [Geom::Point2d, Geom::Point2d]

    # The {#upper_left} method returns the {Geom::Point2d} of the upper left corner
    # of the {Geom::Bounds2d}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(0.0, 0.0, 1.0, 1.0)
    # u_l = bounds.upper_left
    # ```
    def upper_left: () -> Geom::Point2d

    # The {#width} method returns the width of the {Geom::Bounds2d}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(0.0, 0.0, 1.0, 1.0)
    # width = bounds.width
    # ```
    def width: () -> Geom::Point2d
  end

  # The {Geom::Vector2d} class represents vectors in a 2 dimensional space.
  # 
  # There are numerous tutorials on 2D vectors available on the internet.
  # 
  # @version LayOut 2018
  class Vector2d
    # The {#%} method returns the dot product between two {Geom::Vector2d}. This is
    # an alias of the dot method.
    # 
    # _@param_ `vector`
    # 
    # _@return_ — The dot product of the vectors
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(0, 2)
    # vector2 = Geom::Vector2d.new(1, 0)
    # d2 = vector % vector2
    # ```
    def %: (Geom::Vector2d vector) -> untyped

    # The {#*} method returns the cross product between two {Geom::Vector2d}. This
    # is an alias of the cross method.
    # 
    # _@param_ `vector`
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(1, 0)
    # vector2 = Geom::Vector2d.new(0, 1)
    # cross = vector * vector
    # ```
    def *: (Geom::Vector2d vector) -> Geom::Vector2d

    # The {#+} method adds a {Geom::Vector2d} to this one.
    # 
    # _@param_ `vector`
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(0, 2)
    # vector2 = Geom::Vector2d.new(1, 0)
    # new_vector = vector + vector2
    # ```
    def +: (Geom::Vector2d vector) -> Geom::Vector2d

    # The {#-} method subtracts a {Geom::Vector2d} from this one.
    # 
    # _@param_ `vector`
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(0, 2)
    # vector2 = Geom::Vector2d.new(1, 0)
    # new_vector = vector - vector2
    # ```
    def -: (Geom::Vector2d vector) -> Geom::Vector2d

    # The {#==} method returns whether two {Geom::Vector2d} are equal within
    # tolerance.
    # 
    # _@param_ `vector`
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(1, 0)
    # vector2 = Geom::Vector2d.new(0,1)
    # # Returns false
    # status = vector == vector2
    # ```
    def ==: (Geom::Vector2d vector) -> bool

    # The {#[]} method returns the value of the {Geom::Vector2d} at the specified
    # index.
    # 
    # _@param_ `index` — The index into an array of two coordinates.
    # 
    # _@return_ — The value for the x or y coordinate.
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(1, 2)
    # # retrieves the y value of 2
    # yvalue = vector[1]
    # ```
    def []: (Integer index) -> Numeric

    # The {#[]=} method sets the x or y value of the {Geom::Vector2d} based on the
    # specific index of the value.
    # 
    # _@param_ `index` — The index for a specific x or y value in the {Geom::Vector2d} to set
    # 
    # _@param_ `value` — The value to set for x or y
    # 
    # _@return_ — The new x or y value if successful
    # 
    # ```ruby
    # point = Geom::Vector2d.new(1,2)
    # point[1] = 4
    # ```
    def []=: (Numeric index, Numeric value) -> Numeric

    # The {#angle_between} method computes the angle in radians between
    # the {Geom::Vector2d} and another {Geom::Vector2d}.
    # 
    # _@param_ `vector`
    # 
    # _@return_ — The angle (in radians)
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(1, 0)
    # vector2 = Geom::Vector2d.new(-1, 0)
    # # returns PI
    # angle = vector.angle_between(vector2)
    # ```
    def angle_between: (Geom::Vector2d vector) -> Numeric

    # The {#clone} method makes a copy of the {Geom::Vector2d}. This method is
    # equivalent to vec2 = Geom::Vector2d.new(vec).
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(1, 0)
    # vector2 = vector.clone
    # ```
    def clone: () -> Geom::Vector2d

    # The {#*} method returns the cross product between two {Geom::Vector2d}. This
    # is an alias of the cross method.
    # 
    # _@param_ `vector`
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(1, 0)
    # vector2 = Geom::Vector2d.new(0, 1)
    # cross = vector * vector
    # ```
    def cross: (Geom::Vector2d vector) -> Geom::Vector2d

    # The {#%} method returns the dot product between two {Geom::Vector2d}. This is
    # an alias of the dot method.
    # 
    # _@param_ `vector`
    # 
    # _@return_ — The dot product of the vectors
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(0, 2)
    # vector2 = Geom::Vector2d.new(1, 0)
    # d2 = vector % vector2
    # ```
    def dot: (Geom::Vector2d vector) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # The {.new} method creates a new {Geom::Vector2d}.
    # 
    # ```ruby
    # # A vector that runs along the X axis.
    # vector = Geom::Vector2d.new(1, 0)
    # ```
    def initialize: (*untyped args) -> void

    # The {#inspect} method formats the {Geom::Vector2d} as a string.
    # 
    # _@return_ — the string representation of the {Geom::Vector2d}
    # 
    # ```ruby
    # point = Geom::Point2d.new(1, 2)
    # string = point.inspect
    # ```
    def inspect: () -> String

    # The {#length} method returns the length of the {Geom::Vector2d}.
    # 
    # _@return_ — The length of the {Geom::Vector2d}
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(0, 4)
    # # returns 4
    # l = vector.length
    # ```
    def length: () -> Length

    # The {#length=} method sets the length of the {Geom::Vector2d}. The new length
    # must not be 0.
    # 
    # _@param_ `length` — The new length for the {Geom::Vector2d}
    # 
    # _@return_ — The new length
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(0, 4)
    # l = vector.length
    # vector.length = 2
    # ```
    def length=: (Numeric length) -> Numeric

    # The {#normalize} method returns a {Geom::Vector2d} that is a unit vector
    # of the {Geom::Vector2d}.
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(0, 4)
    # # returns a new Vector2d(0, 1)
    # vector2 = vector.normalize
    # ```
    def normalize: () -> Geom::Vector2d

    # sord omit - no YARD return type given, using untyped
    # The {#normalize!} method converts a {Geom::Vector2d} vector into a unit
    # vector. Another way to do this is vector.length = 1
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(0, 4)
    # # modifies vector to be the Vector2d(0, 1)
    # vector.normalize!
    # ```
    def normalize!: () -> untyped

    # The {#parallel?} method determines if the {Geom::Vector2d} is parallel to
    # another {Geom::Vector2d} to within tolerance.
    # 
    # _@param_ `vector`
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(0, 1)
    # vector2 = Geom::Vector2d.new(1, 2)
    # # returns true
    # status = vector.parallel?(vector2)
    # ```
    def parallel?: (Geom::Vector2d vector) -> bool

    # The {#perpendicular?} method determines if the {Geom::Vector2d} is
    # perpendicular to another {Geom::Vector2d} to within tolerance.
    # 
    # _@param_ `vector`
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(0, 1)
    # vector2 = Geom::Vector2d.new(1, 2)
    # # returns false
    # status = vector.perpendicular?(vector2)
    # ```
    def perpendicular?: (Geom::Vector2d vector) -> bool

    # The {#reverse} method returns a new {Geom::Vector2d} that is the reverse of
    # the {Geom::Vector2d}, leaving the original unchanged.
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(1, 2)
    # # returns the Vector2d(-1, -2)
    # vector2 = vector.reverse
    # ```
    def reverse: () -> Geom::Vector2d

    # sord omit - no YARD return type given, using untyped
    # The {#reverse!} method reverses the {Geom::Vector2d} in place.
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(1, 2)
    # # modifies vector to be the Vector2d(-1, -2)
    # vector.reverse!
    # ```
    def reverse!: () -> untyped

    # The {#same_direction?} method determines if the {Geom::Vector2d} is parallel
    # to and in the same direction as another {Geom::Vector2d} within tolerance.
    # 
    # _@param_ `vector`
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(0, 1)
    # vector2 = Geom::Vector2d.new(1, 2)
    # # returns true
    # status = vector.sime_direction?(vector2)
    # ```
    def same_direction?: (Geom::Vector2d vector) -> bool

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#set!} method sets the values of the {Geom::Vector2d}.
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(1, 2)
    # vector = vector.set!([4, 5])
    # ```
    def set!: (*untyped args) -> untyped

    # The {#to_a} method retrieves the coordinates of the {Geom::Vector2d} in an
    # Array.
    # 
    # ```ruby
    # a = vector.to_a
    # ```
    def to_a: () -> [Numeric, Numeric]

    # The {#to_s} method returns a string representation of the {Geom::Vector2d}.
    # 
    # _@return_ — the string representation of the {Geom::Vector2d}
    # 
    # ```ruby
    # point = Geom::Vector2d.new(1, 2)
    # str = point.to_s
    # ```
    def to_s: () -> String

    # The {#transform} method applies a transformation to a vector, returning a new
    # vector. The original vector is unchanged by this method.
    # 
    # _@param_ `transform` — A transformation object to apply to the vector.
    # 
    # _@return_ — the newly transformed vector
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(4, 5)
    # transformation = Geom::Transformation2d.new([1, 0, 0, 1, 2, 3])
    # # vector2 will be (6, 8)
    # vector2 = vector.transform(transformation)
    # ```
    def transform: (Geom::Transformation2d transform) -> Geom::Vector2d

    # The {#transform!} method applies a transformation to a vector. The vector
    # itself is modified.
    # 
    # _@param_ `transform` — A Transformation object to apply to the vector.
    # 
    # _@return_ — the transformed vector
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(4, 5)
    # transformation = Geom::Transformation2d.new([1, 0, 0, 1, 2, 3])
    # # vector will be (6, 8)
    # vector.transform!(transformation)
    # ```
    def transform!: (Geom::Transformation2d transform) -> Geom::Vector2d

    # The {#unit_vector?} method returns whether the {Geom::Vector2d} is a unit
    # vector. This is equivalent to vector.length == 1.0
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(1, 0)
    # # returns true
    # status = vector.unit_vector
    # ```
    def unit_vector?: () -> bool

    # The {#valid?} method verifies if a {Geom::Vector2d} is valid. A
    # {Geom::Vector2d} is valid if its length is not zero.
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(0, 4)
    # status = vector.valid
    # ```
    def valid?: () -> bool

    # The {#x} method retrieves the x value of the {Geom::Vector2d}.
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(1, 2)
    # x = vector.x
    # ```
    def x: () -> Numeric

    # The {#x=} method sets the x coordinate of the {Geom::Vector2d}.
    # 
    # _@param_ `x` — The desired x value of the {Geom::Vector2d}
    # 
    # _@return_ — The new x value of the {Geom::Vector2d}
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(1, 2)
    # vector.x = 7
    # ```
    def x=: (Numeric x) -> Numeric

    # The {#y} method retrieves the y value of the {Geom::Vector2d}.
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(1, 2)
    # y = vector.y
    # ```
    def y: () -> Numeric

    # The {#y=} method sets the y coordinate of the {Geom::Vector2d}.
    # 
    # _@param_ `y` — The desired y value of the {Geom::Vector2d}
    # 
    # _@return_ — The new y value of the {Geom::Vector2d}
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(1, 2)
    # vector.y = 7
    # ```
    def y=: (Numeric y) -> Numeric
  end

  # The Vector3d class is used to represent vectors in a 3 dimensional space.
  # Vectors in SketchUp have a direction and a length, but not a starting point.
  # 
  # There are numerous tutorials on 3D vectors available on the internet.
  # 
  # @version SketchUp 6.0
  class Vector3d
    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {.linear_combination} method is used to create a new vector as a linear
    # combination of other vectors. This method is generally used to get a vector
    # at some percentage between two vectors.
    # 
    # A linear combination is a standard term for vector math. It is defined as
    # vector = weight1 * vector1 + weight2 * vector2.
    # 
    # ```ruby
    # # Create a vector that is a 50%/50% linear combination of two others.
    # vec1 = Geom::Vector3d.new 3,0,0
    # vec2 = Geom::Vector3d.new 0,3,0
    # new_vector = Geom::Vector3d.linear_combination(0.5, vec1, 0.5, vec2)
    # # new_vector will now contain a Vector3d(1.5, 1.5, 0)
    # ```
    def self.linear_combination: (*untyped args) -> untyped

    # The {#%} method is used to compute the dot product between two vectors.
    # 
    # This is an alias of the {#dot} method.
    # 
    # _@param_ `vector`
    # 
    # ```ruby
    # vector1 = Geom::Vector3d.new(0, 0, 1)
    # vector2 = Geom::Vector3d.new(0, 1, 0)
    # dot = vector1 % vector2
    # ```
    # 
    # _@see_ `#dot`
    def %: (Geom::Vector3d vector) -> Float

    # The {#*} method is used to compute the cross product between two vectors.
    # 
    # The cross product, also called the vector product, is an operation on two
    # vectors. The cross product of two vectors produces a third vector which is
    # perpendicular to the plane in which the first two lie.
    # 
    # This is an alias of the {#cross} method.
    # 
    # _@param_ `vector`
    # 
    # _@return_ — the cross of vector1 and vector2
    # 
    # ```ruby
    # vector1 = Geom::Vector3d.new(1, 0, 0)
    # vector2 = Geom::Vector3d.new(0, 1, 0)
    # vector3 = vector1 * vector2
    # ```
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(1, 0, 0)
    # vector2 = Geom::Vector3d.new(0, 1, 0)
    # vector3 = vector.cross(vector2)
    # ```
    # 
    # _@see_ `#cross`
    def *: (Geom::Vector3d vector) -> Geom::Vector3d

    # The - method is used to add a vector to this one.
    # 
    # _@param_ `vector2` — A Vector3d object.
    # 
    # _@return_ — the new vector.
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(0,0,2)
    # vector2 = Geom::Vector3d.new(0,1,0)
    # new_vector = vector + vector2
    # ```
    def +: (untyped vector2) -> Geom::Vector3d

    # The - method is used to subtract a vector from this one.
    # 
    # _@param_ `vector2` — A Vector3d object.
    # 
    # _@return_ — the new vector.
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(0,0,2)
    # vector2 = Geom::Vector3d.new(0,1,0)
    # new_vector = vector - vector2
    # ```
    def -: (untyped vector2) -> Geom::Vector3d

    # The < method is used to determine if a vector's x, y or z value is less
    # than another vector's x, y or z value.
    # 
    # _@param_ `vector2` — A Vector3d object.
    # 
    # _@return_ — true if the vector's x, y or z component is less
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(0,0,2)
    # vector2 = Geom::Vector3d.new(0,1,0)
    # lt = vector < vector2
    # ```
    def <: (untyped vector2) -> bool

    # The == method is used to determine if two vectors are equal to within
    # tolerance.
    # 
    # _@param_ `vector2` — A Vector3d object.
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(1,0,0)
    # vector2 = Geom::Vector3d.new(0,1,0)
    # status = vector == vector2
    # # Returns false
    # UI.messagebox status
    # ```
    def ==: (untyped vector2) -> bool

    # The [] method is used to access the coordinates of a vector as if it was an
    # Array. The index must be 0, 1 or 2.
    # 
    # The following are equivalent:
    # 
    # _@param_ `i` — An index into an array of three coordinates.
    # 
    # _@return_ — the value for the x, y, or z coordinate.
    # 
    # ```ruby
    # x = vector.x
    # x = vector[0]
    # ```
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(1,0,0)
    # value = vector[0]
    # if (value)
    #   UI.messagebox value
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def []: (Integer i) -> Length

    # The []= method is used to set the coordinates of a vector as if it was an
    # Array. The value of i must be 0, 1 or 2.
    # 
    # _@param_ `index` — The index for the x, y, or z coordinate.
    # 
    # _@param_ `value` — The value for the x, y, or z coordinate.
    # 
    # _@return_ — the newly set coordinate value
    # 
    # ```ruby
    # vector[i] = coordinate
    # ```
    def []=: (Integer index, Numeric value) -> Numeric

    # The angle_between method is used to compute the angle (in radians) between
    # this vector and another vector.
    # 
    # _@param_ `vector2` — A Vector3d object.
    # 
    # _@return_ — an angle (in radians)
    # 
    # ```ruby
    # vector1 = Geom::Vector3d.new(1,0,0)
    # vector2 = Geom::Vector3d.new(0,1,0)
    # angle = vector1.angle_between vector2
    # ```
    def angle_between: (Geom::Vector3d vector2) -> Float

    # The axes method is used to compute an arbitrary set of axes with the given
    # vector as the z-axis direction.
    # 
    # Returns an Array of three vectors [xaxis, yaxis, zaxis]
    # 
    # Vector3d objects
    # 
    # _@return_ — an Array object containing three
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(1,0,0)
    # a = vector.axes
    # ```
    def axes: () -> [Geom::Vector3d, Geom::Vector3d, Geom::Vector3d]

    # The clone method is used to make a copy of a vector.
    # 
    # This method is equivalent to vec2 = Geom::Vector3d.new(vec)
    # 
    # _@return_ — a Vector3d object which is the clone of
    # vector
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(1,0,0)
    # vector2 = vector.clone
    # ```
    def clone: () -> Geom::Vector3d

    # The {#cross} method is used to compute the cross product between two vectors.
    # 
    # The cross product, also called the vector product, is an operation on two
    # vectors. The cross product of two vectors produces a third vector which is
    # perpendicular to the plane in which the first two lie.
    # 
    # _@param_ `vector`
    # 
    # _@return_ — the cross of vector1 and vector2
    # 
    # ```ruby
    # vector1 = Geom::Vector3d.new(1, 0, 0)
    # vector2 = Geom::Vector3d.new(0, 1, 0)
    # vector3 = vector1 * vector2
    # ```
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(1, 0, 0)
    # vector2 = Geom::Vector3d.new(0, 1, 0)
    # vector3 = vector.cross(vector2)
    # ```
    # 
    # _@see_ `#*`
    def cross: (Geom::Vector3d vector) -> Geom::Vector3d

    # The {#dot} method is used to compute the dot product between two vectors.
    # 
    # _@param_ `vector`
    # 
    # ```ruby
    # vector1 = Geom::Vector3d.new(0, 0, 1)
    # vector2 = Geom::Vector3d.new(0, 1, 0)
    # dot = vector1.dot(vector2)
    # ```
    # 
    # _@see_ `#%`
    def dot: (Geom::Vector3d vector) -> Float

    # sord omit - no YARD type given for "*args", using untyped
    # The new method is used to create a new vector.
    # 
    # ```ruby
    # # A vector that runs up the Z axis.
    # vector = Geom::Vector3d.new(0,0,1)
    # if (vector)
    #   UI.messagebox vector
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def initialize: (*untyped args) -> void

    # The inspect method is used to inspect the contents of a vector as a
    # friendly string.
    # 
    # _@return_ — the Vector3d object
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(0,0,1)
    # out_string = vector.inspect
    # puts out_string
    # ```
    def inspect: () -> Geom::Vector3d

    # The length method is used to retrieve the length of the vector.
    # 
    # _@return_ — the length of the vector
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(0,0,1)
    # l = vector.length
    # ```
    def length: () -> Length

    # The length= method is used to set the length of the vector. The length must
    # be greater than 0.
    # 
    # _@param_ `length` — A length for the vector.
    # 
    # _@return_ — a newly set length
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(0,0,1)
    # l = vector.length
    # UI.messagebox(l)
    # newl = vector.length = 2
    # ```
    def length=: (Numeric length) -> Numeric

    # The normalize method is used to return a vector that is a unit vector
    # of another.
    # 
    # _@return_ — a new normalized Vector3d object
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(0,0,2)
    # vector2 = vector.normalize
    # ```
    def normalize: () -> Geom::Vector3d

    # The normalize! method is used to convert a vector into a unit vector,
    # in place.
    # 
    # Another way to do this is vec.length = 1
    # 
    # _@return_ — a normalized Vector3d object
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(0,0,2)
    # vector.normalize!
    # ```
    def normalize!: () -> Geom::Vector3d

    # The parallel method is used to determine if this vector is parallel to
    # another vector to within tolerance.
    # 
    # _@param_ `vector2` — A Vector3d object.
    # 
    # ```ruby
    # status = vector.parallel?(vector2)
    # ```
    def parallel?: (Geom::Vector3d vector2) -> bool

    # The perpendicular? method is used to determine if this vector is
    # perpendicular to another vector to within tolerance.
    # 
    # _@param_ `vector2` — A Vector3d object.
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(0,0,1)
    # vector2 = Geom::Vector3d.new(0,1,0)
    # status = vector.perpendicular?(vector2)
    # ```
    def perpendicular?: (Geom::Vector3d vector2) -> bool

    # The reverse method is used to return a new vector that is the reverse
    # of this vector, while leaving the original unchanged.
    # 
    # _@return_ — a Vector3d object that is the reverse of
    # vector
    # 
    # ```ruby
    # vector2 = vector.reverse
    # ```
    def reverse: () -> Geom::Vector3d

    # The reverse! method is used to reverse the vector in place.
    # 
    # _@return_ — a Vector3d object that is the reverse of
    # vector
    # 
    # ```ruby
    # vector.reverse!
    # ```
    def reverse!: () -> Geom::Vector3d

    # The samedirection? method is used to determine if this vector is parallel to
    # and in the same direction as another vector to within tolerance.
    # 
    # _@param_ `vector2` — A Vector3d object.
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(0,0,1)
    # vector2 = Geom::Vector3d.new(0,1,0)
    # status = vector.samedirection?(vector2)
    # ```
    def samedirection?: (Geom::Vector3d vector2) -> bool

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The set! method is used to set the coordinates of the vector.
    # 
    # This is a shortcut for writing:
    # ```ruby
    # vec.x = x
    # vec.y = y
    # vec.z = z
    # ```
    # 
    # You may also call this method with an array or another vector:
    # ```ruby
    # vec.set!(x, y, z)
    # vec.set!([x, y, z])
    # vec.set!(vec2)
    # ```
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(0,0,1)
    # vector.set! 1,0,0
    # ```
    def set!: (*untyped args) -> untyped

    # The to_a method retrieves the coordinates of the vector in an Array
    # [x, y, z].
    # 
    # _@return_ — the coordinates of the vector in an array
    # 
    # ```ruby
    # a = vector.to_a
    # ```
    def to_a: () -> [Length, Length, Length]

    # The to_s method is used to format the vector as a String.
    # 
    # _@return_ — a string representation of vector
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(0,0,1)
    # out_string = vector.to_s
    # puts out_string
    # ```
    def to_s: () -> String

    # Apply a Transformation to a vector, returning a new vector. The original
    # vector is unchanged by this method.
    # 
    # _@param_ `transform` — A Transformation object to apply to the vector.
    # 
    # _@return_ — the newly transformed vector
    # 
    # ```ruby
    # vector2 = vector.transform(transformation)
    # ```
    def transform: (Geom::Transformation transform) -> Geom::Vector3d

    # Apply a Transformation to a vector. The vector itself is modified.
    # 
    # _@param_ `transform` — A Transformation object to apply to the vector.
    # 
    # _@return_ — the transformed vector
    # 
    # ```ruby
    # vector.transform!(transformation)
    # ```
    def transform!: (Geom::Transformation transform) -> Geom::Vector3d

    # The unitvector? method is used to see if the vector is a unit vector.
    # 
    # This is equivalent to vec.length == 1.0
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(0,0,1)
    # status = vector.unitvector?
    # ```
    def unitvector?: () -> bool

    # The valid? method is used to verify if a vector is valid. A vector is valid
    # if its length is not zero.
    # 
    # ```ruby
    # # A zero length vector will be invalid
    # vector = Geom::Vector3d.new(0,0,0)
    # status = vector.valid?
    # # A non-zero length vector is valid
    # vector = Geom::Vector3d.new(0,0,1)
    # status = vector.valid?
    # ```
    def valid?: () -> bool

    # The x method is used to retrieve the x coordinate of the vector.
    # 
    # _@return_ — the x coordinate of the vector
    # 
    # ```ruby
    # x = vector.x
    # ```
    def x: () -> Length

    # The x= method is used to set the x coordinate of the vector.
    # 
    # _@param_ `x` — The x coordinate for the vector.
    # 
    # _@return_ — the newly set x coordinate for the vector
    # 
    # ```ruby
    # vector = Geom::Vector3d.new 1,2,3
    # x = vector.x = 10
    # ```
    def x=: (Numeric x) -> Numeric

    # The y method is used to retrieve the y coordinate of the vector.
    # 
    # _@return_ — the y coordinate of the vector
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(1,2,3)
    # y = vector.y
    # ```
    def y: () -> Length

    # Set the y coordinate of the vector.
    # 
    # _@param_ `y` — The y coordinate for the vector.
    # 
    # _@return_ — the newly set y coordinate for the vector
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(1,2,3)
    # y = vector.y = 10
    # ```
    def y=: (Numeric y) -> Numeric

    # Get the z coordinate of the vector.
    # 
    # _@return_ — the z coordinate of the vector
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(1,2,3)
    # z = vector.z
    # ```
    def z: () -> Length

    # Set the z coordinate of the vector.
    # 
    # _@param_ `z` — The z coordinate for the vector.
    # 
    # _@return_ — the newly set z coordinate for the vector
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(1,2,3)
    # z = vector.z = 10
    # ```
    def z=: (Numeric z) -> Numeric
  end

  # Bounding boxes are three-dimensional boxes (eight corners), aligned with the
  # axes, that surround entities within your model. There is a default
  # bounding box for any new model that will surround all entities,
  # including all groups and components. Additionally, there are
  # bounding boxes for Drawingelement objects, including components and groups.
  # Bounding boxes are only large enough to exactly bound the entities within
  # your model, group, or component.
  # 
  # You can also create arbitrary BoundingBox objects by calling BoundingBox.new.
  # 
  # @example
  #   # You can get the bounding box on a model.
  #   model = Sketchup.active_model
  #   model_bb = model.bounds
  # 
  #   # Or you can get the bounding box on any Drawingelement object.
  #   first_entity = model.entities[0]
  #   first_entity_bb = first_entity.bounds
  # 
  #   # Or you can create an empty bounding box of your own.
  #   boundingbox = Geom::BoundingBox.new
  # 
  # @note that the bounding box returned for face-me components is the center of
  #   its entire range of motion. This behavior changed in SketchUp 7.1. In 7.0
  #   and earlier, the .bounds method would return the bounds around the
  #   face-me component's current, visible center.
  # 
  # @version SketchUp 6.0
  class BoundingBox
    # sord omit - no YARD type given for "*args", using untyped
    # The add method is used to add a point, vertex, or other bounding boxes to the
    # bounding box. The size of the bounding box will increase as necessary to
    # accommodate the new items.
    # 
    # Adding one point to an empty bounding box does not increase the size of the
    # bounding box. You must add at least two points before methods such as
    # BoundingBox.diagonal will return a size greater than zero.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # boundingbox = model.bounds
    # point1 = Geom::Point3d.new(100, 200, 300)
    # point2 = Geom::Point3d.new(200, 400, 200)
    # boundingbox.add(point1, point2)
    # ```
    def add: (*untyped args) -> Geom::BoundingBox

    # The center method is used to retrieve the Point3d object at the center of
    # the bounding box.
    # 
    # _@return_ — the Point3d at the center of the bounding box
    # if successful
    # 
    # ```ruby
    # boundingbox = Geom::BoundingBox.new
    # boundingbox.add([100, 200, -400], [200, 400, 100])
    # # This will return a point Point3d(150, 300, -150).
    # point = boundingbox.center
    # ```
    def center: () -> Geom::Point3d

    # The clear method is used to clear a bounding box.
    # 
    # A cleared BoundingBox does not have a size greater than zero until you add
    # at least two points or another bounding box.
    # 
    # _@return_ — the BoundingBox object which was cleared
    # 
    # ```ruby
    # boundingbox = Geom::BoundingBox.new
    # boundingbox.add([100, 200, -400], [200, 400, 100])
    # 
    # # This will return false.
    # boundingbox.empty?
    # 
    # boundingbox.clear
    # # This will return true.
    # boundingbox.empty?
    # ```
    def clear: () -> Geom::BoundingBox

    # This method is used to determine if a bounding box contains a specific
    # Point3d or BoundingBox object.
    # 
    # _@param_ `point_or_bb`
    # 
    # ```ruby
    # boundingbox = Geom::BoundingBox.new
    # boundingbox.add([100, 200, -400], [200, 400, 100])
    # # This will return false.
    # boundingbox.contains?([300, 100, 400])
    # # This will return true.
    # boundingbox.contains?([150, 300, -200])
    # ```
    def contains?: ((Geom::Point3d | Geom::BoundingBox) point_or_bb) -> bool

    # The corner method is used to retrieve a point object at a specified corner
    # of the bounding box.
    # 
    # There are 8 corners to a bounding box, identified by the numbers 0 through 7.
    # Points are returned in the currently set units (inches, by default). These
    # are which index refers to which corner:
    # 
    #   - 0 = [0, 0, 0] (left front bottom)
    #   - 1 = [1, 0, 0] (right front bottom)
    #   - 2 = [0, 1, 0] (left back bottom)
    #   - 3 = [1, 1, 0] (right back bottom)
    #   - 4 = [0, 0, 1] (left front top)
    #   - 5 = [1, 0, 1] (right front top)
    #   - 6 = [0, 1, 1] (left back top)
    #   - 7 = [1, 1, 1] (right back top)
    # 
    # _@param_ `corner_index` — A number (from 0 to 7) representing point at the corner you want to retrieve.
    # 
    # _@return_ — a Point3d object if successful
    # 
    # ```ruby
    # boundingbox = Geom::BoundingBox.new
    # boundingbox.add([100, 200, -400], [200, 400, 100])
    # # This will return Point3d(100, 200, -400).
    # boundingbox.corner(0)
    # # This will return Point3d(100, 200, -400).
    # boundingbox.corner(6)
    # ```
    def corner: (Integer corner_index) -> Geom::Point3d

    # The {#depth} method is used to retrieve the Z extents of the bounding box.
    # 
    # ```ruby
    # boundingbox = Geom::BoundingBox.new
    # boundingbox.add([100, 200, -400], [200, 400, 100])
    # # This will return a Length of 500.0.
    # height = boundingbox.depth
    # ```
    # 
    # _@note_ — In SketchUp's coordinate system, this corresponds to the height.
    def depth: () -> Length

    # The {#diagonal} method is used to get the length of the diagonal of the
    # bounding box.
    # 
    # _@return_ — the size of the diagonal for the bounding
    # box
    # 
    # ```ruby
    # boundingbox = Geom::BoundingBox.new
    # boundingbox.add([100, 200, -400], [200, 400, 100])
    # # This will return a point a Length of ~547.72.
    # length = boundingbox.diagonal
    # ```
    def diagonal: () -> Length

    # The empty? method is used to determine if a bounding box is empty (such as
    # if the bounds have not been set.) This returns the opposite of the valid?
    # method.
    # 
    # ```ruby
    # boundingbox = Geom::BoundingBox.new
    # boundingbox.add([100, 200, -400], [200, 400, 100])
    # # This will return false.
    # boundingbox.empty?
    # ```
    def empty?: () -> bool

    # The {#height} method is used to retrieve the Y extent of the bounding box.
    # 
    # ```ruby
    # boundingbox = Geom::BoundingBox.new
    # boundingbox.add([100, 200, -400], [200, 400, 100])
    # # This will return a Length of 200.0.
    # depth = boundingbox.height
    # ```
    # 
    # _@note_ — In SketchUp's coordinate system, this corersponds to the depth.
    def height: () -> Length

    # The new method is used to create a new, empty, bounding box.
    # 
    # _@return_ — a BoundingBox object if successful
    # 
    # ```ruby
    # boundingbox = Geom::BoundingBox.new
    # ```
    def initialize: () -> void

    # The intersect method is used to retrieve a bounding box that is the result
    # of intersecting one bounding box with another.
    # 
    # _@param_ `boundingbox` — A second boundbox which might intersect boundingbox1.
    # 
    # _@return_ — the resulting BoundingBox object if
    # successful, an empty BoundingBox object if unsuccessful.
    # 
    # ```ruby
    # boundingbox1 = Geom::BoundingBox.new
    # boundingbox1.add([100, 200, -400], [200, 400, 300])
    # boundingbox2 = Geom::BoundingBox.new
    # boundingbox2.add([150, 350, 100], [200, 400, 500])
    # # The returned boundingbox is a result of the intersection of the two.
    # boundingbox = boundingbox1.intersect(boundingbox2)
    # ```
    # 
    # _@note_ — Prior to SU2015 this method would return incorrect result in some
    # cases. For correct result in these versions you must first check if the
    # boundingboxes actually overlap - then call this to get the resulting
    # boundingbox.
    def intersect: (Geom::BoundingBox boundingbox) -> Geom::BoundingBox

    # The max method is used to retrieve the Point3d object where x, y and z are
    # maximum in the bounding box.
    # 
    # If you attempt to call the max method on an empty bounding box, you will
    # receive a very large negative number.
    # 
    # _@return_ — a Point3d object representing the point where
    # x, y, and z are the maximum in the bounding box.
    # 
    # ```ruby
    # boundingbox = Geom::BoundingBox.new
    # boundingbox.add([100, 200, -400], [700, 900, 800], [200, 400, 100])
    # # This will return a point Point3d(700, 900, 800).
    # point = boundingbox.max
    # ```
    def max: () -> Geom::Point3d

    # The min method is used to retrieve the Point3d where x, y and z are minimum
    # in the bounding box.
    # 
    # _@return_ — a Point3d object representing the point where
    # x, y, and z are the maximum in the bounding box.
    # 
    # ```ruby
    # boundingbox = Geom::BoundingBox.new
    # boundingbox.add([100, 200, -400], [700, 900, 800], [200, 400, 100])
    # # This will return a point Point3d(100, 200, -400).
    # point = boundingbox.min
    # ```
    def min: () -> Geom::Point3d

    # The valid method is used to determine if a bounding box is valid (contains
    # points).
    # 
    # ```ruby
    # boundingbox = Geom::BoundingBox.new
    # boundingbox.add([100, 200, -400], [200, 400, 100])
    # # This will return true.
    # boundingbox.valid?
    # ```
    def valid?: () -> bool

    # The {#width} method is used to retrieve the X extent of the bounding box.
    # 
    # ```ruby
    # boundingbox = Geom::BoundingBox.new
    # boundingbox.add([100, 200, -400], [200, 400, 100])
    # # This will return a Length of 100.0.
    # width = boundingbox.width
    # ```
    def width: () -> Length
  end

  # The {#Geom::PolygonMesh} class contains methods to create polygon mesh
  # structures. This is useful if you need to write a custom importer/exporter in
  # Ruby that works at the level of triangulated polygons. For example, you can
  # determine the triangles that make up a 15-sided {#Sketchup::Face} by using
  # this class, or write a {#Sketchup::Importer} that reads a data file, creates
  # a mesh from it, and draws faces based on the mesh.
  # 
  # You can construct a mesh manually using the methods of this class, or you
  # can get a mesh from a face by calling the {Sketchup::Face#mesh} method. See
  # {Sketchup::Entities#add_faces_from_mesh} for an easy way to convert a mesh
  # back into faces.
  # 
  # @example
  #   entities = Sketchup.active_model.active_entities
  #   face = entities.grep(Sketchup::Face).first
  # 
  #   mesh = face.mesh
  # 
  #   group = entities.add_group
  #   group.entities.add_faces_from_mesh(mesh)
  # 
  # @note As of SketchUp 2022.0 the new {Sketchup::EntitiesBuilder} interface
  #   can be used to generate bulk geometry. It has similar performance as
  #   {Geom::PolygonMesh}, but with similar degree of per-entity control as
  #   {Sketchup::Entities}.
  # 
  # @see file:pages/generating_geometry.md
  #   Guide on Generating Geometry
  # 
  # @version SketchUp 6.0
  class PolygonMesh
    AUTO_SOFTEN: untyped
    HIDE_BASED_ON_INDEX: untyped
    NO_SMOOTH_OR_HIDE: untyped
    SMOOTH_SOFT_EDGES: untyped
    SOFTEN_BASED_ON_INDEX: untyped
    MESH_NORMALS: untyped
    MESH_POINTS: untyped
    MESH_UVQ_BACK: untyped
    MESH_UVQ_FRONT: untyped

    # The {#add_point} method is used to add a point to the mesh.
    # 
    # The returned index can be used for creating polygons.
    # 
    # _@param_ `point`
    # 
    # _@return_ — the index in the mesh for the point
    # 
    # ```ruby
    # mesh = Geom::PolygonMesh.new
    # point = Geom::Point3d.new(0, 1, 2)
    # index = mesh.add_point(point)
    # ```
    # 
    # _@note_ — In SketchUp 2021.1 this method was improved to be faster.
    # See {#initialize} for details.
    def add_point: (Geom::Point3d point) -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # The {#add_polygon} method is used for adding a polygon to a
    # {Geom::PolygonMesh}. All variations of this method require at least 3 elements
    # to define a polygon, although more may be given.
    # 
    # _@return_ — The index of the polygon in the mesh.
    # 
    # _@return_ — Invalid index. Returned if the method failed to create a
    # polygon.
    # 
    # _@note_ — In SketchUp 2021.1 this method was improved to be faster.
    # See {#initialize} for details.
    def add_polygon: (*untyped args) -> Integer

    # The {#count_points} method is used to count the number of points in a mesh.
    # 
    # _@return_ — the number of points in a mesh
    # 
    # ```ruby
    # mesh = Geom::PolygonMesh.new
    # point = Geom::Point3d.new(0, 1, 2)
    # mesh.add_point(point)
    # num = mesh.count_points
    # ```
    def count_points: () -> Integer

    # The {#count_polygons} count the number of polygons in the mesh.
    # 
    # _@return_ — the number of polygons in the mesh
    # 
    # ```ruby
    # mesh = Geom::PolygonMesh.new
    # point1 = Geom::Point3d.new(0, 1, 2)
    # point2 = Geom::Point3d.new(1, 0, 2)
    # point3 = Geom::Point3d.new(2, 0, 1)
    # mesh.add_polygon(point1, point2, point3)
    # nump = mesh.count_polygons
    # ```
    def count_polygons: () -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # Create a new empty polygon mesh.
    # 
    # The number of points and polygons are optional and are used as a hint to
    # decide how much space to pre-allocate to speed up adding points and polygons.
    # 
    # As of SketchUp 2021.1 the performance of looking up and inserting points is
    # significantly better provided the mesh was initialized with roughly the
    # correct number of total points.
    # 
    # ```ruby
    # mesh = Geom::PolygonMesh.new
    # ```
    # 
    # _@note_ — When creating a mesh with normals and/or UVQ data it's critical that
    # the number of points estimated is equal to or higher than the final number
    # of points added. If fewer points are estimated the normals and UVQ data
    # might end up out of sync.
    def initialize: (*untyped args) -> void

    # The {#normal_at} method is used to determine the vertex normal at a
    # particular index in the mesh. This only works for meshes retrieved from
    # {Sketchup::Face#mesh} with the +PolygonMeshNormals+ flag.
    # 
    # _@param_ `index` — The index in the mesh for the vertex normal to be retrieved
    # 
    # ```ruby
    # flags = 4 # PolygonMeshNormals
    # mesh = face.mesh(flags)
    # normal = mesh.normal_at(1)
    # ```
    # 
    # _@note_ — Index starts at 1.
    def normal_at: (Integer index) -> Geom::Vector3d?

    # The {#point_at} method is used to retrieve the point at a specific index in
    # the mesh.
    # 
    # _@param_ `index` — The index in the mesh for the point to be retrieved
    # 
    # ```ruby
    # mesh = Geom::PolygonMesh.new
    # point1 = Geom::Point3d.new(0, 1, 2)
    # point2 = Geom::Point3d.new(10, 20, 30)
    # mesh.add_point(point1)
    # mesh.add_point(point2)
    # point_from_index = mesh.point_at(1)
    # ```
    # 
    # _@note_ — Index starts at 1.
    def point_at: (Integer index) -> Geom::Point3d?

    # The {#point_index} method is used to retrieve the index of a point in the
    # mesh.
    # 
    # _@param_ `point`
    # 
    # _@return_ — the index in the mesh for the {Geom::Point3d} object
    # 
    # ```ruby
    # mesh = Geom::PolygonMesh.new
    # point1 = Geom::Point3d.new(0, 1, 2)
    # point2 = Geom::Point3d.new(10, 20, 30)
    # mesh.add_point(point1)
    # mesh.add_point(point2)
    # index = mesh.point_index(point2)
    # ```
    # 
    # _@note_ — Returns 0 if point is not found.
    def point_index: (Geom::Point3d point) -> Integer

    # The {#points} method is used to retrieve an array of points (vertices) in the
    # mesh
    # 
    # ```ruby
    # mesh = Geom::PolygonMesh.new
    # point1 = Geom::Point3d.new(0, 1, 2)
    # point2 = Geom::Point3d.new(10, 20, 30)
    # mesh.add_point(point1)
    # mesh.add_point(point2)
    # # Returns array of points in the mesh.
    # points = mesh.points
    # ```
    def points: () -> ::Array[Geom::Point3d]

    # The {#polygon_at} method is used to retrieve an array of vertex index values
    # for a polygon at a specific index.
    # 
    # _@param_ `index` — The index of the desired polygon.
    # 
    # ```ruby
    # mesh = Geom::PolygonMesh.new
    # point1 = Geom::Point3d.new(0, 1, 2)
    # point2 = Geom::Point3d.new(1, 0, 2)
    # point3 = Geom::Point3d.new(2, 0, 1)
    # index = mesh.add_polygon(point1, point2, point3)
    # polygon = mesh.polygon_at(index)
    # ```
    # 
    # _@note_ — Index starts at 1.
    # 
    # _@note_ — The returned array can contain negative
    # values with the sign indicating a hidden edge. For example, a return value
    # of +[-1, 2, 3]+ indicates that the edge from +1+ to +2+ is hidden. The
    # negative values should not be used as an index for {#point_at}, take the
    # absolute value of the index value in the polygon array.  So if you
    # get +[-1, 2,3]+ use +1+ as the argument to {#point_at}.
    def polygon_at: (Integer index) -> ::Array[Geom::Point3d]?

    # The {#polygon_points_at} method is used to retrieve the points for a polygon
    # that is at a specific index in the mesh.
    # 
    # _@param_ `index` — An index for a polygon in the mesh.
    # 
    # ```ruby
    # mesh = Geom::PolygonMesh.new
    # point1 = Geom::Point3d.new(0, 1, 2)
    # point2 = Geom::Point3d.new(1, 0, 2)
    # point3 = Geom::Point3d.new(2, 0, 1)
    # index = mesh.add_polygon(point1, point2, point3)
    # points = mesh.polygon_points_at(index)
    # ```
    # 
    # _@note_ — Index starts at 1.
    def polygon_points_at: (Integer index) -> ::Array[Geom::Point3d]?

    # The {#polygons} method is used to retrieve an array of all polygons in the
    # mesh.
    # 
    # The returned array contains an array that can have a negative value with the
    # sign indicating a hidden edge. For example, a return value of +[-1, 2, 3]+
    # indicates that the edge from +1+ to +2+ is hidden.
    # 
    # ```ruby
    # polygons = polygonmesh.polygons
    # ```
    def polygons: () -> ::Array[::Array[Integer]]

    # The {#set_point} method is used to set the point at a specific index in the
    # mesh.
    # 
    # _@param_ `index` — The index where the point will be set.
    # 
    # _@param_ `point` — A Point3d object to set at the index.
    # 
    # ```ruby
    # mesh = Geom::PolygonMesh.new
    # point1 = Geom::Point3d.new(0, 1, 2)
    # point2 = Geom::Point3d.new(10, 20, 30)
    # index = mesh.add_point(point1)
    # mesh.set_point(index, point2)
    # ```
    # 
    # _@note_ — Index starts at 1.
    def set_point: (Integer index, Geom::Point3d point) -> Geom::PolygonMesh

    # The {#set_uv} method is used to define UV mapping coordinates to points in
    # the mesh.
    # 
    # Beware that the polygons connected to the point will share UV coordiates so
    # UV mapping coordinates needs to be continuous across the polygon mesh.
    # 
    # When setting the UV for a point one need to make sure to have the correct
    # index for the point. It's therefore best to add the points using {#add_point}
    # and use the index it returns for following calls to set_uv and
    # {#add_polygon}.
    # 
    # If you are not able to calculate how many points there will be in your mesh
    # make sure to not specify an index in {#set_uv} higher than the number of
    # times you have called {#set_uv}.
    # 
    # _@param_ `index` — An Integer representing the UV index.
    # 
    # _@param_ `point` — A Point3d object representing UV coordinates.
    # 
    # _@param_ `front` — A boolean representing the front or back.
    # 
    # ```ruby
    # mesh = Geom::PolygonMesh.new(4)
    # # Create points for a triangle.
    # point1 = Geom::Point3d.new(0, 0, 0)
    # point2 = Geom::Point3d.new(9, 0, 0)
    # point3 = Geom::Point3d.new(9, 9, 0)
    # point4 = Geom::Point3d.new(0, 9, 0)
    # # Create UV mapping to tile 2x cross triangle.
    # uv1 = Geom::Point3d.new(0, 0, 0)
    # uv2 = Geom::Point3d.new(2, 0, 0)
    # uv3 = Geom::Point3d.new(2, 2, 0)
    # uv4 = Geom::Point3d.new(0, 2, 0)
    # # Add points and UV data to mesh.
    # index1 = mesh.add_point(point1)
    # index2 = mesh.add_point(point2)
    # index3 = mesh.add_point(point3)
    # index4 = mesh.add_point(point4)
    # mesh.set_uv(index1, uv1, true)
    # mesh.set_uv(index2, uv2, true)
    # mesh.set_uv(index3, uv3, true)
    # mesh.set_uv(index4, uv4, true)
    # # Add polygons.
    # mesh.add_polygon(index1, index2, index3)
    # mesh.add_polygon(index1, index3, index4)
    # ```
    # 
    # _@note_ — If you don't specify how many points you will be adding to the mesh
    # when you initiate it you may risk the UV data becoming out of sync.
    # 
    # _@note_ — Index starts at 1.
    def set_uv: (Integer index, Geom::Point3d point, bool front) -> void

    # The {#transform!} method is used to apply a transformation to a mesh.
    # 
    # _@param_ `transformation`
    # 
    # ```ruby
    # point1 = Geom::Point3d.new(100, 200, 300)
    # tr = Geom::Transformation.new(point1)
    # mesh = Geom::PolygonMesh.new
    # point2 = Geom::Point3d.new(0, 1, 2)
    # mesh.add_point(point2)
    # mesh.transform!(tr)
    # ```
    def transform!: (Geom::Transformation transformation) -> Geom::PolygonMesh

    # The {#uv_at} method is used to access a uv (texture coordinates) at a
    # specific index.
    # 
    # "UVs" is a way of referring to the u,v texture coordinates (as
    # opposed to the X, Y, and Z axis that you construct your meshes on), which
    # are points defining 1-by-1 positions within an image. These coordinates
    # connect to points in your 3D model, to position an image texture onto it's
    # surface (similar to virtual "thumb tacks")
    # 
    # These coordinates pin an exact spot on an image that you wish to use to
    # texture your model to a specific point on an object's surface. Between these
    # points, your software will stretch the image smoothly. This is what is
    # referred to as UV mapping.
    # 
    # _@param_ `index` — The index for the texture coordinate.
    # 
    # _@param_ `front` — Set to +true+ to get the UV for the front size, +false+ for the back side.
    # 
    # _@return_ — a Point3d object where the x equals the u
    # value and the y equals the v value.
    # Returns nil on failure.
    # 
    # ```ruby
    # point = mesh.uv_at(1, true)
    # ```
    # 
    # _@note_ — Index starts at 1.
    def uv_at: (Integer index, bool front) -> Geom::Point3d?

    # The {#uvs} method is used to retrieve an array of uv coordinates in the
    # mesh.
    # 
    # _@param_ `front`
    # 
    # ```ruby
    # # Get a mesh with front and back UVs.
    # mesh = face.mesh(1 | 2)
    # uvs = mesh.uvs(true)
    # ```
    def uvs: (bool front) -> ::Array[Geom::Point3d]
  end

  # Transformations are a standard construct in the 3D world for representing
  # the position, rotation, and sizing of a given entity. In the SketchUp
  # world, {Sketchup::ComponentInstance} and {Sketchup::Group} have a
  # +.transformation+ method that reports their current state and various methods
  # (+.move!+, +transformation=+, etc.) that allow them to be manipulated.
  # 
  # Use of the transformation class requires a knowledge of geometrical
  # transformations in 3 dimensions which is covered extensively on
  # the Internet.
  # 
  # @version SketchUp 6.0
  class Transformation
    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The axes method creates a transformation that goes from world coordinates
    # to an arbitrary coordinate system defined by an origin and three axis
    # vectors.
    # 
    # ```ruby
    # # Creates a transformation that "flips" the axes from XYZ to XZY. Something
    # # one often need for importers/exporters when dealing with applications
    # # that threat Y as "up".
    # tr = Geom::Transformation.axes(ORIGIN, X_AXIS, Z_AXIS, Y_AXIS.reverse)
    # ```
    def self.axes: (*untyped args) -> untyped

    # The interpolate method is used to create a new transformation that is the
    # result of interpolating between two other transformations.
    # 
    # Parameter is a weight (between 0.0 and 1.0) that identifies whether to favor
    # transformation1 or transformation2.
    # 
    # _@param_ `transform1`
    # 
    # _@param_ `transform2`
    # 
    # _@param_ `weight` — A value between 0.0 and 1.0 (see comments).
    # 
    # ```ruby
    # origin = Geom::Point3d.new(0, 0, 0)
    # x = Geom::Vector3d.new(0, 1, 0)
    # y = Geom::Vector3d.new(1, 0, 0)
    # z = Geom::Vector3d.new(0, 0, 1)
    # point = Geom::Point3d.new(10, 20, 30)
    # t1 = Geom::Transformation.new(point)
    # t2 = Geom::Transformation.axes(origin, x, y, z)
    # # This produce a transformation that is a mix of 75% t1 and 25% t2.
    # t3 = Geom::Transformation.interpolate(t1, t2, 0.25)
    # ```
    def self.interpolate: (Geom::Transformation transform1, Geom::Transformation transform2, Float weight) -> Geom::Transformation

    # The rotation method is used to create a transformation that does rotation
    # about an axis.
    # 
    # The axis is defined by a point and a vector. The angle is given in radians.
    # 
    # _@param_ `point`
    # 
    # _@param_ `vector`
    # 
    # _@param_ `angle` — The angle in radians.
    # 
    # ```ruby
    # point = Geom::Point3d.new(10, 20, 0)
    # vector = Geom::Vector3d.new(0, 0, 1)
    # angle = 45.degrees # Return 45 degrees in radians.
    # transformation = Geom::Transformation.rotation(point, vector, angle)
    # ```
    def self.rotation: (Geom::Point3d point, Geom::Vector3d vector, Float angle) -> Geom::Transformation

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The scaling method is used to create a transformation that does scaling.
    # 
    # ```ruby
    # point = Geom::Point3d.new(20, 30, 0)
    # scale = 10
    # tr = Geom::Transformation.scaling(point, scale)
    # ```
    def self.scaling: (*untyped args) -> untyped

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The translation method is used to create a transformation that does
    # translation.
    # 
    # ```ruby
    # vector = Geom::Vector3d.new(0, 1, 0)
    # tr = Geom::Transformation.translation(vector)
    # ```
    def self.translation: (untyped arg) -> untyped

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#*} method is used to do matrix multiplication using the transform.
    # 
    # ```ruby
    # point1 = Geom::Point3d.new(10, 20, 30)
    # point2 = Geom::Point3d.new(2, 2, 2)
    # tr = Geom::Transformation.new(point1)
    # # Returns Point3d(12, 22, 32)
    # point3 = tr * point2
    # ```
    def *: (untyped arg) -> untyped

    # The {#clone} method is used to create a copy of a transformation.
    # 
    # ```ruby
    # point = Geom::Point3d.new(10, 20, 30)
    # tr1 = Geom::Transformation.new(point)
    # tr2 = tr1.clone
    # ```
    def clone: () -> Geom::Transformation

    # The {#identity?} method is used to determine if a transformation is the
    # {IDENTITY} transform.
    # 
    # _@return_ — +true+ if the transformation is the identity
    # 
    # ```ruby
    # point = Geom::Point3d.new(10, 20, 30)
    # tr = Geom::Transformation.new(point)
    # # Returns false.
    # status = tr.identity?
    # ```
    # 
    # ```ruby
    # tr = Geom::Transformation.new(ORIGIN)
    # # Returns false.
    # status = tr.identity?
    # ```
    # 
    # ```ruby
    # tr = Geom::Transformation.new
    # # Returns true.
    # status = tr.identity?
    # ```
    # 
    # ```ruby
    # # Returns true.
    # status = IDENTITY.identity?
    # ```
    # 
    # _@note_ — As of SketchUp 2018, this now looks at the data to determine if the
    # transformation is identity. Prior to SU2018, this only looks at the flag to
    # see if the transform has not been modified. If the transform has been
    # changed, this will return false even if it is really the identity.
    def identity?: () -> bool

    # sord omit - no YARD type given for "*args", using untyped
    # The new method is used to create a new transformation.
    # 
    # You can use this method or one of the more specific methods for creating
    # specific kinds of Transformations.
    # 
    # ```ruby
    # point = Geom::Point3d.new(10, 20, 30)
    # tr = Geom::Transformation.new(point)
    # ```
    def initialize: (*untyped args) -> void

    # The {#inverse} method is used to retrieve the inverse of a transformation.
    # 
    # ```ruby
    # point = Geom::Point3d.new(10, 20, 30)
    # tr1 = Geom::Transformation.new(point)
    # tr2 = tr1.inverse
    # ```
    def inverse: () -> Geom::Transformation

    # The {#invert!} method sets the transformation to its inverse.
    # 
    # ```ruby
    # point = Geom::Point3d.new(10, 20, 30)
    # tr = Geom::Transformation.new(point)
    # tr.invert!
    # ```
    def invert!: () -> Geom::Transformation

    # The {#origin} method retrieves the origin of a rigid transformation.
    # 
    # _@return_ — the origin of the transformation.
    # 
    # ```ruby
    # point1 = Geom::Point3d.new(10, 20, 30)
    # tr = Geom::Transformation.new(point1)
    # point2 = tr.origin
    # ```
    def origin: () -> Geom::Point3d

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#set!} method is used to set this transformation to match another one.
    # 
    # The argument is anything that can be converted into a transformation.
    # 
    # ```ruby
    # point1 = Geom::Point3d.new(10, 20, 30)
    # tr1 = Geom::Transformation.new(point)
    # point2 = Geom::Point3d.new(60, 40, 70)
    # tr1.set!(point2)
    # ```
    def set!: (untyped arg) -> untyped

    # The {#to_a} method retrieves a 16 element array which contains the values that
    # define the transformation.
    # 
    # ```ruby
    # point = Geom::Point3d.new(10, 20, 30)
    # tr = Geom::Transformation.new(point)
    # # This splits the 16 items into a string of 4x4 elements for easier reading.
    # str4x4 = tr.to_a.each_slice(4).inject { |str, row| "#{str}\r\n#{row}" }
    # ```
    def to_a: () -> ::Array[Float]

    # The {#xaxis} method retrieves the x axis of a rigid transformation.
    # 
    # ```ruby
    # point = Geom::Point3d.new(10, 20, 30)
    # tr = Geom::Transformation.new(point)
    # x = tr.xaxis
    # ```
    def xaxis: () -> Geom::Vector3d

    # The {#yaxis} method retrieves the y axis of a rigid transformation.
    # 
    # ```ruby
    # point = Geom::Point3d.new(10, 20, 30)
    # tr = Geom::Transformation.new(point)
    # x = tr.yaxis
    # ```
    def yaxis: () -> Geom::Vector3d

    # The {#zaxis} method retrieves the z axis of a rigid transformation.
    # 
    # ```ruby
    # point = Geom::Point3d.new(10, 20, 30)
    # tr = Geom::Transformation.new(point)
    # x = tr.zaxis
    # ```
    def zaxis: () -> Geom::Vector3d
  end

  # The OrientedBounds2d class is a bounding box represented by four
  # {Geom::Point2d} objects, upper left, upper right, lower left and lower right
  # positions.
  # 
  # @version LayOut 2018
  class OrientedBounds2d
    # The {#==} method checks to see if the two {Geom::OrientedBounds2d}s are
    # equal. This checks whether the point values are the same.
    # 
    # _@param_ `other`
    # 
    # ```ruby
    # entity.bounds == entity.untransformed_bounds
    # ```
    def ==: (Geom::OrientedBounds2d other) -> bool

    # The {#lower_left} method returns the {Geom::Point2d} of the lower left
    # corner of the {Geom::OrientedBounds2d}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entity = doc.shared_enities.first
    # bounds = entity.drawing_bounds
    # l_l = bounds.lower_left
    # ```
    def lower_left: () -> Geom::Point2d

    # The {#lower_right} method returns the {Geom::Point2d} of the lower right
    # corner of the {Geom::OrientedBounds2d}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entity = doc.shared_enities.first
    # bounds = entity.drawing_bounds
    # l_r = bounds.lower_right
    # ```
    def lower_right: () -> Geom::Point2d

    # The {#to_a} method returns an array which contains the {Geom::Point2d} that
    # define the {Geom::OrientedBounds2d}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entity = doc.shared_enities.first
    # bounds = entity.drawing_bounds
    # bounds.to_a.each { |point| p point.to_s }
    # ```
    def to_a: () -> [Geom::Point2d, Geom::Point2d, Geom::Point2d, Geom::Point2d]

    # The {#upper_left} method returns the {Geom::Point2d} of the upper left corner
    # of the {Geom::OrientedBounds2d}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entity = doc.shared_enities.first
    # bounds = entity.drawing_bounds
    # u_l = bounds.upper_left
    # ```
    def upper_left: () -> Geom::Point2d

    # The {#upper_right} method returns the {Geom::Point2d} of the upper right
    # corner of the {Geom::OrientedBounds2d}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entity = doc.shared_enities.first
    # bounds = entity.drawing_bounds
    # u_r = bounds.upper_right
    # ```
    def upper_right: () -> Geom::Point2d
  end

  # 
  # @version LayOut 2018
  class Transformation2d
    # The {.rotation} method is used to create a transformation that does rotation
    # about a point.
    # 
    # _@param_ `point`
    # 
    # _@param_ `angle` — The angle in radians.
    # 
    # ```ruby
    # point = Geom::Point2d.new(10, 5)
    # angle = 45.degrees # Return 45 degrees in radians.
    # transformation = Geom::Transformation2d.rotation(point, angle)
    # ```
    def self.rotation: (Geom::Point2d point, Float angle) -> Geom::Transformation2d

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {.scaling} method is used to create a transformation that does scaling.
    # 
    # ```ruby
    # point = Geom::Point3d.new(20, 30, 0)
    # scale = 10
    # tr = Geom::Transformation2d.scaling(point, scale)
    # ```
    def self.scaling: (*untyped args) -> untyped

    # sord omit - no YARD type given for "vector", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {.translation} method is used to create a transformation that does
    # translation.
    # 
    # ```ruby
    # vector = Geom::Vector2d.new(0, 1)
    # tr = Geom::Transformation2d.translation(vector)
    # ```
    def self.translation: (untyped vector) -> untyped

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#*} method is used to do matrix multiplication using the transform.
    # 
    # ```ruby
    # point1 = Geom::Point2d.new(5, 10)
    # point2 = Geom::Point2d.new(2, 2)
    # tr = Geom::Transformation2d.new(point1)
    # # Returns Point2d(7, 12)
    # point3 = tr * point2
    # ```
    def *: (untyped arg) -> untyped

    # The {#==} method checks to see if the two {Geom::Transformation2d}s are equal.
    # This checks whether the values of the transformations are the same.
    # 
    # _@param_ `other`
    # 
    # ```ruby
    # tr = Geom::Transformation2d.new({1.0, 0.0, 0.0, 1.0, 1.0, 1.0})
    # tr == tr.clone
    # ```
    def ==: (Geom::Transformation2d other) -> bool

    # The {#clone} method creates a copy of the {Geom::Transformation2d}.
    # 
    # ```ruby
    # tr1 = Geom::Transformation2d.new
    # tr2 = tr1.clone
    # ```
    def clone: () -> Geom::Transformation2d

    # The {#identity?} method determines if the {Geom::Transformation2d} is the
    # {IDENTITY_2D} transform.
    # 
    # _@return_ — +true+ if the transform is the identity
    # 
    # ```ruby
    # array = {1.0, 0.0, 0.0, 1.0, 1.0, 0.0}
    # tr = Geom::Transformation2d.new(array)
    # # Returns false.
    # status = tr.identity?
    # ```
    # 
    # ```ruby
    # tr = Geom::Transformation2d.new
    # # Returns true.
    # status = tr.identity?
    # ```
    # 
    # ```ruby
    # # Returns true.
    # status = IDENTITY_2D.identity?
    # ```
    def identity?: () -> bool

    # sord omit - no YARD type given for "*args", using untyped
    # The {#initialize} method creates a new {Geom::Transformation2d}. You can use
    # this method or one of the more specific methods for creating specific kinds
    # of {Geom::Transformation2d}.
    # 
    # ```ruby
    # tr = Geom::Transformation2d.new({1.0, 0.0, 0.0, 1.0, 1.0, 1.0})
    # ```
    def initialize: (*untyped args) -> void

    # The {#inverse} method is used to retrieve the inverse of a transformation.
    # 
    # ```ruby
    # point = Geom::Point2d.new(5, 10)
    # tr1 = Geom::Transformation2d.new(point)
    # tr2 = tr1.inverse
    # ```
    def inverse: () -> Geom::Transformation2d

    # The {#invert!} method sets the transformation to its inverse.
    # 
    # ```ruby
    # point = Geom::Point2d.new(5, 10)
    # tr = Geom::Transformation2d.new(point)
    # tr.invert!
    # ```
    def invert!: () -> Geom::Transformation2d

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#set!} method sets the {Geom::Transformation2d} to match another one.
    # The argument is anything that can be converted into a {Geom::Transformation2d}.
    # 
    # ```ruby
    # tr1 = Geom::Transformation2d.new
    # array = {2.0, 0.0, 0.0, 2.0, 0.0, 0.0}
    # tr1.set!(array)
    # ```
    def set!: (untyped arg) -> untyped

    # The {#to_a} method returns a 6 element array which contains the values that
    # define the Transformation2d.
    # 
    # _@return_ — an array of 6 elements
    # 
    # ```ruby
    # tr = Geom::Transformation2d.new
    # tr.to_a.each_slice(2) {|a| p a}
    # ```
    def to_a: () -> ::Array[Float]
  end
end

# The SketchUp Array class adds additional methods to the standard Ruby Array
# class. Specifically, it contains methods allowing an
# array to behave just as a {Geom::Vector3d} or {Geom::Point3d} object
# (which can be thought of as arrays of 3 coordinate values). Therefore, you
# can use the Array class in place of a {Geom::Point3d} or {Geom::Vector3d} as
# a way to pass coordinate values.
# 
# @example
#   # An array of 3 values can represent a 1" long vector pointing straight
#   # up in the z-direction.
#   array = [0, 0, 1]
# 
#   # An array of 3 values can also represent a point 1" above the origin in
#   # the z direction. (Note that this is the exact same array.)
#   array = [0, 0, 1]
# 
#   # How it is interpreted is based on context. For example, this code will
#   # create a construction point at position 0, 0, 1, since in this context
#   # a Point3d is expected.
#   entities = Sketchup.active_model.entities
#   construction_point = entities.add_cpoint(array)
# 
#   # Whereas this will move our construction point 1" upward, since in this
#   # context a Vector3d is expected.
#   transformation = Geom::Transformation.new(array)
#   entities.transform_entities(transformation, construction_point)
# 
# @version SketchUp 6.0
class Array
  # sord omit - no YARD type given for "vector", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {#cross} method is used to compute the cross product between two vectors.
  # 
  # With 3d array
  # ```ruby
  # vector1 = Geom::Vector3d.new(0, 1, 0)
  # array = [1, 0, 0]
  # # This will return a new Vector3d
  # vector2 = array.cross(vector1)
  # ```
  # 
  # With 2d array
  # ```ruby
  # vector1 = Geom::Vector2d.new(0, 1)
  # array = [1, 0]
  # vector2 = array.cross(vector1)
  # 
  # vector1 = Geom::Vector3d.new(0, 1, 0)
  # array = [1, 0]
  # vector2 = array.cross(vector1) # This will force array to be [1, 0, 0]
  # ```
  def cross: (untyped vector) -> untyped

  # sord omit - no YARD type given for "point", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {#distance} method is used to compute the distance between two points.
  # 
  # With 3d array
  # ```ruby
  # point = Geom::Point3d.new(10, 10, 10)
  # array = [1, 1, 1]
  # # This will return a Length
  # distance = array.distance(point)
  # ```
  # 
  # With 2d array
  # ```ruby
  # point = Geom::Point2d.new(10, 10)
  # array = [1, 2]
  # distance = array.distance(point)
  # 
  # point = Geom::Point3d.new(10, 10, 10)
  # distance = array.distance(point)
  # ```
  def distance: (untyped point) -> untyped

  # sord omit - no YARD type given for "*args", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {#distance_to_line} method is used to compute the distance from a
  # {Geom::Point3d} object to a line.
  # 
  # ```ruby
  # line = [Geom::Point3d.new(0, 0, 0), Geom::Vector3d.new(0, 0, 1)]
  # array = [10, 10, 10]
  # # This will return a Length
  # distance = array.distance_to_line(line)
  # ```
  # 
  # _@see_ `Geom` — The Geom module for instructions on how to create a line.
  def distance_to_line: (*untyped args) -> untyped

  # sord omit - no YARD type given for "*args", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {#distance_to_plane} method is used to compute the distance from a
  # {Geom::Point3d} object to a plane.
  # 
  # ```ruby
  # plane = [Geom::Point3d.new(0, 0, 0), Geom::Vector3d.new(0, 0, 1)]
  # array = [10, 10, 10]
  # # This will return a Length
  # distance = array.distance_to_plane(plane)
  # ```
  # 
  # _@see_ `Geom` — The Geom module for instructions on how to create a plane.
  def distance_to_plane: (*untyped args) -> untyped

  # sord omit - no YARD type given for "vector", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {#dot} method is used to compute the dot product between two vectors.
  # 
  # With 3d array
  # ```ruby
  # vector = Geom::Vector3d.new(12, 12, 0)
  # array = [12, 0, 0]
  # # This will return a Float, in this case 144.0
  # dot_product = array.dot(vector)
  # ```
  # 
  # With 2d array
  # ```ruby
  # vector = Geom::Vector2d.new(12, 12)
  # array = [12, 0]
  # # This will return a float
  # dot_product = array.dot(vector)
  # ```
  def dot: (untyped vector) -> untyped

  # sord omit - no YARD return type given, using untyped
  # The {#normalize} method is used to normalize a vector (setting its
  # length to 1). It returns a new array rather than changing the original in
  # place.
  # 
  # With 3d array
  # ```ruby
  # array = [1, 2, 3]
  # # This will return a new Vector3d
  # normal_vector = array.normalize
  # ```
  # 
  # With 2d array
  # ```ruby
  # array = [1, 2]
  # normal_vector = array.normalize
  # ```
  # 
  # _@note_ — The arguments and return value will be converted to a floating point
  # value. (Unlike in the {Geom::Vector3d#normalize!} method.)
  def normalize: () -> untyped

  # sord omit - no YARD return type given, using untyped
  # The {#normalize!} method is used to normalize a vector in place (setting its
  # length to 1).
  # 
  # With 3d array
  # ```ruby
  # array = [1, 2, 3]
  # # This will modify 'array' in place
  # array.normalize!
  # ```
  # 
  # With 2d array
  # ```ruby
  # array = [1, 2]
  # array.normalize!
  # ```
  def normalize!: () -> untyped

  # sord omit - no YARD type given for "*args", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {#offset} method is used to offset a point by a vector. it returns a new
  # array rather than modifying the original in place.
  # 
  # With 3d array
  # ```ruby
  # array = [10, 10, 10]
  # vector = Geom::Vector3d.new(0, 0, 1)
  # # This will modify 'array' in place
  # length_array = array.offset(vector)
  # ```
  # 
  # With 2d array
  # ```ruby
  # array = [10, 10]
  # vector = Geom::Vector2d.new(0, 1)
  # length_array = array.offset(vector)
  # 
  # # Using Vector3d with a 2d array
  # array = [10, 10]
  # vector = Geom::Vector3d.new(0, 0, 1)
  # length_array = array.offset(vector)
  # ```
  def offset: (*untyped args) -> untyped

  # sord omit - no YARD type given for "*args", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {#offset!} method is used to offset a point by a vector. The array is
  # modified in place.
  # 
  # With 3d array
  # ```ruby
  # array = [10, 10, 10]
  # vector = Geom::Vector3d.new(0, 0, 1)
  # # This will modify 'array' in place
  # array.offset!(vector)
  # ```
  # 
  # With 2d array
  # ```ruby
  # array = [10, 10]
  # vector = Geom::Vector2d.new(0, 1)
  # array.offset!(vector)
  # 
  # # Using Vector3d with a 2d array
  # array = [10, 10]
  # vector = Geom::Vector3d.new(0, 0, 1)
  # array.offset!(vector)
  # ```
  def offset!: (*untyped args) -> untyped

  # sord omit - no YARD type given for "*args", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {#on_line?} method is used to determine if a {Geom::Point3d} object is on
  # a line.
  # 
  # ```ruby
  # line = [Geom::Point3d.new(0, 0, 0), Geom::Vector3d.new(0, 0, 1)]
  # array = [10, 10, 10]
  # # This will return a true or false value
  # on_plane = array.on_line?(line)
  # ```
  # 
  # _@see_ `Geom` — The Geom module for instructions on how to create a line.
  def on_line?: (*untyped args) -> untyped

  # sord omit - no YARD type given for "*args", using untyped
  # The {#on_plane?} method is used to determine if a {Geom::Point3d} object is
  # on a plane (to within SketchUp's standard floating point tolerance).
  # 
  # ```ruby
  # plane = [Geom::Point3d.new(0, 0, 0), Geom::Vector3d.new(0, 0, 1)]
  # array = [10, 10, 10]
  # # This will return a true or false value
  # on_plane = array.on_plane?(plane)
  # ```
  # 
  # _@see_ `Geom` — The Geom module for instructions on how to create a plane.
  def on_plane?: (*untyped args) -> bool

  # sord omit - no YARD type given for "*args", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {#project_to_line} method is used to retrieve the projection of a
  # {Geom::Point3d} object onto a line.
  # 
  # ```ruby
  # line = [Geom::Point3d.new(0, 0, 0), Geom::Vector3d.new(0, 0, 1)]
  # array = [10, 10, 10]
  # # This will return a new Array
  # point_on_line = array.project_to_line(line)
  # ```
  # 
  # _@see_ `Geom` — The Geom module for instructions on how to create a line.
  def project_to_line: (*untyped args) -> untyped

  # sord omit - no YARD type given for "*args", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {#project_to_plane} method retrieves the projection of a {Geom::Point3d}
  # onto a plane.
  # 
  # ```ruby
  # plane = [Geom::Point3d.new(0, 0, 0), Geom::Vector3d.new(0, 0, 1)]
  # array = [10, 10, 10]
  # point_on_plane = array.project_to_plane(plane)
  # ```
  # 
  # _@see_ `Geom` — The Geom module for instructions on how to create a plane.
  def project_to_plane: (*untyped args) -> untyped

  # sord omit - no YARD type given for "transform", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {#transform} method is used to apply a {Geom::Transformation} or
  # {Geom::Transformation2d} object to a {Geom::Point3d} or {Geom::Point2d} object
  # defined by an {Array} object.
  # 
  # This method returns a new {Array} object instead of modifying the original.
  # 
  # ```ruby
  # point1 = Geom::Point3d.new(10, 20, 30)
  # transform = Geom::Transformation.new(point1)
  # array = [1, 2, 3]
  # # This will return a new Array
  # point2 = array.transform(transform)
  # ```
  def transform: (untyped transform) -> untyped

  # sord omit - no YARD type given for "transform", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {#transform!} method is used to apply a {Geom::Transformation} object to
  # a {Geom::Point3d} object defined by an {Array} object.
  # 
  # ```ruby
  # point = Geom::Point3d.new(10, 20, 30)
  # transform = Geom::Transformation.new(point)
  # array = [1, 2, 3]
  # # This will modify 'array' in place
  # array.transform!(transform)
  # ```
  # 
  # _@note_ — This method modifies the original.
  def transform!: (untyped transform) -> untyped

  # sord omit - no YARD type given for "point", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {#vector_to} method is used to create an array as a vector from one point
  # to a second point.
  # 
  # With 3d array
  # ```ruby
  # point = Geom::Point3d.new(10, 20, 30)
  # array = [1, 2, 3]
  # # This will return a new Vector3d
  # vector = array.vector_to(point)
  # ```
  # 
  # With 2d array
  # ```ruby
  # point = Geom::Point2d.new(10, 20)
  # array = [1, 2]
  # # This will return a new Vector2d
  # vector = array.vector_to(point)
  # 
  # point = Geom::Point3d.new(10, 20)
  # # This will return a new Vector3d
  # vector = array.vector_to(point)
  # ```
  def vector_to: (untyped point) -> untyped

  # The {#x} method retrieves the x coordinate.
  # 
  # _@return_ — The x coordinate if successful
  # 
  # ```ruby
  # array = [1, 2, 3]
  # # This will return a Fixnum, in this case 1
  # x = array.x
  # 
  # array = [1.0, 2.0, 3.0]
  # # This will return a Float, in this case 1.0
  # x = array.x
  # ```
  def x: () -> Object?

  # The {#x=} method sets the x coordinate.
  # 
  # _@param_ `x` — The new x position.
  # 
  # _@return_ — The new x coordinate if successful
  # 
  # ```ruby
  # array = [1, 2, 3]
  # # This will initialize the x value as a Float
  # array.x = 2.5
  # # This will initialize the x value as a Fixnum
  # array.x = 5
  # ```
  def x=: (Object x) -> Object

  # The {#y} method retrieves the y coordinate.
  # 
  # _@return_ — The y coordinate if successful
  # 
  # ```ruby
  # array = [1, 2, 3]
  # # This will return a Fixnum, in this case 2
  # y = array.y
  # 
  # array = [1.0, 2.0, 3.0]
  # # This will return a Float, in this case 2.0
  # y = array.y
  # ```
  def y: () -> Object?

  # The {#y=} method sets the y coordinate.
  # 
  # _@param_ `y` — The new y position.
  # 
  # _@return_ — The new y coordinate if successful
  # 
  # ```ruby
  # array = [1, 2, 3]
  # # This will initialize the y value as a Float
  # array.y = 2.5
  # # This will initialize the y value as a Fixnum
  # array.y = 5
  # ```
  def y=: (Object y) -> Object

  # The {#z} method retrieves the z coordinate.
  # 
  # _@return_ — The z coordinate if successful
  # 
  # ```ruby
  # array = [1, 2, 3]
  # # This will return a Fixnum, in this case 3
  # z = array.z
  # 
  # array = [1.0, 2.0, 3.0]
  # # This will return a Float, in this case 3.0
  # z = array.z
  # ```
  def z: () -> Object?

  # The {#z=} method sets the z coordinate.
  # 
  # _@param_ `z` — The new z position.
  # 
  # _@return_ — The new z coordinate if successful
  # 
  # ```ruby
  # array = [1, 2, 3]
  # # This will initialize the z value as a Float
  # array.z = 2.5
  # # This will initialize the z value as a Fixnum
  # array.z = 5
  # ```
  def z=: (Object z) -> Object
end

# The LayOut module is the root of the LayOut Ruby API. Many of the classes in
# the API are implemented beneath this module.
# 
# @example
#   # Open an existing LayOut document.
#   doc = Layout::Document.open("C:/path/to/document.layout")
# 
#   # Grab other handles to commonly used collections inside the model.
#   layers = doc.layers
#   pages = doc.pages
#   entities = doc.shared_entities
# 
#   # Now that we have our handles, we can start pulling objects and making
#   # method calls that are useful.
#   first_entity = entities.first
# 
#   number_pages = pages.length
# 
# @version LayOut 2018
module Layout
  # Class that references a {Layout::Document}'s grid settings.
  # 
  # @version LayOut 2018
  class Grid
    # sord omit - no YARD return type given, using untyped
    # The {#clip_to_margins=} method sets whether or not the grid is clipped to the
    # page margins.
    # 
    # _@param_ `clip`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # grid.clip_to_margins = true
    # ```
    def clip_to_margins=: (bool clip) -> untyped

    # The {#clip_to_margins?} method returns whether or not the grid is clipped to
    # the page margins.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # in_front = grid.clip_to_margins?
    # ```
    def clip_to_margins?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#in_front=} method sets whether or not the grid is drawn on top of
    # entities.
    # 
    # _@param_ `in_front`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # grid.in_front = true
    # ```
    def in_front=: (bool in_front) -> untyped

    # The {#in_front?} method returns whether or not the grid is drawn on top of
    # entities.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # in_front = grid.in_front?
    # ```
    def in_front?: () -> bool

    # The {#major_color} method returns the {Sketchup::Color} for the major grid
    # lines.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # color = grid.major_color
    # ```
    def major_color: () -> Sketchup::Color

    # sord omit - no YARD return type given, using untyped
    # The {#major_color=} method sets the {Sketchup::Color} for the major grid
    # lines.
    # 
    # _@param_ `color`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # grid.major_color = Sketchup::Color.new(255, 0, 0)
    # grid.major_color = 255
    # grid.major_color = 0x0000ff
    # grid.major_color = "red"
    # grid.major_color = "#ff0000"
    # grid.major_color = [1.0, 0.0, 0.0]
    # grid.major_color = [255, 0, 0]
    # ```
    def major_color=: (Sketchup::Color color) -> untyped

    # The {#major_spacing} method returns the major space size of the
    # {Layout::Grid}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # major_spacing = grid.major_spacing
    # ```
    def major_spacing: () -> Numeric

    # sord omit - no YARD return type given, using untyped
    # The {#major_spacing=} method sets the major space size of the
    # {Layout::Grid}.
    # 
    # _@param_ `spacing` — The double specifying the space size for the {Layout::Grid}
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # grid.major_spacing = 1.25
    # ```
    def major_spacing=: (Float spacing) -> untyped

    # The {#minor_color} method returns the {Sketchup::Color} for the minor grid
    # lines.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # color = grid.minor_color
    # ```
    def minor_color: () -> Sketchup::Color

    # sord omit - no YARD return type given, using untyped
    # The {#minor_color=} method sets the {Sketchup::Color} for the minor grid
    # lines.
    # 
    # _@param_ `color`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # grid.minor_color = Sketchup::Color.new(255, 0, 0)
    # grid.minor_color = 255
    # grid.minor_color = 0x0000ff
    # grid.minor_color = "red"
    # grid.minor_color = "#ff0000"
    # grid.minor_color = [1.0, 0.0, 0.0]
    # grid.minor_color = [255, 0, 0]
    # ```
    def minor_color=: (Sketchup::Color color) -> untyped

    # The {#minor_divisions} method returns the number of minor divisions of the
    # {Layout::Grid}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # minor_divisions = grid.minor_divisions
    # ```
    def minor_divisions: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#minor_divisions=} method sets the number of minor divisions of the
    # {Layout::Grid}.
    # 
    # _@param_ `divisions` — The number of minor divisions for the {Layout::Grid}
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # grid.major_spacing = 1.25
    # ```
    def minor_divisions=: (Integer divisions) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#print=} method sets whether or not the {Layout::Grid} is
    # printed.
    # 
    # _@param_ `print`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # grid.print = false
    # ```
    def print=: (bool print) -> untyped

    # The {#print?} method returns whether or not the {Layout::Grid} is
    # printed.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # print = grid.print?
    # ```
    def print?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#show=} method sets whether or not the {Layout::Grid} is
    # visible.
    # 
    # _@param_ `show`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # grid.show = true
    # ```
    def show=: (bool show) -> untyped

    # The {#show?} method returns whether or not the {Layout::Grid} is
    # visible.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # show = grid.show?
    # ```
    def show?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#show_major=} method sets whether or not the major grid lines are
    # visible.
    # 
    # _@param_ `show`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # grid.show_major = true
    # ```
    def show_major=: (bool show) -> untyped

    # The {#show_major?} method returns whether or not the major grid lines are
    # visible.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # show_major = grid.show_major?
    # ```
    def show_major?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#show_minor=} method sets whether or not the minor grid lines are
    # visible.
    # 
    # _@param_ `show`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # grid.show_minor = false
    # ```
    def show_minor=: (bool show) -> untyped

    # The {#show_minor?} method returns whether or not the minor grid lines are
    # visible.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # show_minor = grid.show_minor?
    # ```
    def show_minor?: () -> bool
  end

  # Class for a single page in a LayOut document.
  # 
  # @version LayOut 2018
  class Page
    # The {#==} method checks to see if the two {Layout::Page}s are equal.
    # This checks whether the Ruby Objects are pointing to the same internal
    # object.
    # 
    # _@param_ `other`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # document = doc.pages.first.document
    # doc.pages.first == document.pages.first
    # ```
    def ==: (Layout::Page other) -> bool

    # The {#document} method returns the {Layout::Document} that the {Layout::Page}
    # belongs to.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # first_page = doc.pages.first
    # # page_doc should reference the same document as doc
    # page_doc = first_page.document
    # ```
    def document: () -> Layout::Document

    # The {#entities} method returns all {Layout::Entity}s that are on the
    # {Layout::Page}. This is the equivalent of iterating over all
    # {Layout::LayerInstance}s and using {Layout::LayerInstance.entities}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # first_page = doc.pages.first
    # entities = first_page.entities
    # ```
    def entities: () -> Layout::Entities

    # sord omit - no YARD return type given, using untyped
    # The {#in_presentation=} method sets whether the {Layout::Page} is included in
    # presentations.
    # 
    # _@param_ `in_presentation`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # first_page = doc.pages.first
    # first_page.in_presentation = true
    # ```
    def in_presentation=: (bool in_presentation) -> untyped

    # The {#in_presentation?} method returns whether the {Layout::Page} is included
    # in presentations.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # first_page = doc.pages.first
    # in_presentation = first_page.in_presentation?
    # ```
    def in_presentation?: () -> bool

    # The {#layer_instances} method returns an array of the {Layout::LayerInstance}s
    # for the {Layout::Page}.
    # 
    # ```ruby
    # # An example of page.layer_instances
    # ```
    def layer_instances: () -> ::Array[Layout::LayerInstance]

    # The {#layer_visible?} method returns whether a {Layout::Layer} is visible
    # on the {Layout::Page}.
    # 
    # _@param_ `layer`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # first_page = doc.pages.first
    # layer = doc.layers.first
    # visible = first_page.layer_visible?(layer)
    # ```
    def layer_visible?: (Layout::Layer layer) -> bool

    # The {#name} method returns the name of the {Layout::Page}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # pages = doc.pages
    # first_page_name = pages.first.name
    # ```
    def name: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#name=} method sets the name of a page.
    # 
    # _@param_ `name`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # pages = doc.pages
    # pages.first.name = "First page"
    # ```
    def name=: (String name) -> untyped

    # The {#nonshared_entities} method returns the {Layout::Entities}
    # unique to the {Layout::Page}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # first_page = doc.pages.first
    # entities = first_page.nonshared_entities
    # ```
    def nonshared_entities: () -> Layout::Entities

    # The {#set_layer_visibility} method sets whether a {Layout::Layer} is visible
    # on the {Layout::Page}.
    # 
    # _@param_ `layer`
    # 
    # _@param_ `visible`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # first_page = doc.pages.first
    # layer = doc.layers.first
    # first_page.set_layer_visibility(layer, false)
    # ```
    def set_layer_visibility: (Layout::Layer layer, bool visible) -> bool
  end

  # A path entity represents a continuous, multi-segment polyline or bezier
  # curve.
  # 
  # @version LayOut 2018
  class Path < Layout::Entity
    POINT_TYPE_ARC_CENTER: untyped
    POINT_TYPE_BEZIER_CONTROL: untyped
    POINT_TYPE_BEZIER_TO: untyped
    POINT_TYPE_CLOSE: untyped
    POINT_TYPE_LINE_TO: untyped
    POINT_TYPE_MOVE_TO: untyped
    PATH_WINDING_CLOCKWISE: untyped
    PATH_WINDING_COUNTER_CLOCKWISE: untyped
    PATH_WINDING_NONE: untyped

    # The {.new_arc} method creates a new arc-shaped {Layout::Path}.
    # 
    # _@param_ `center_point`
    # 
    # _@param_ `radius`
    # 
    # _@param_ `start_angle`
    # 
    # _@param_ `end_angle`
    # 
    # _@return_ — an arc path
    # 
    # ```ruby
    # center = Geom::Point2d.new(5, 5)
    # radius = 2.0
    # start_angle = 180.0
    # end_angle = 360.0
    # arc = Layout::Path.new_arc(center, radius, start_angle, end_angle)
    # ```
    def self.new_arc: (
                        Geom::Point2d center_point,
                        Float radius,
                        Float start_angle,
                        Float end_angle
                      ) -> Layout::Path

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#append_point} method appends a {Geom::Point2d} to the end of the
    # {Layout::Path}.
    # 
    # ```ruby
    # point = Geom::Point2d.new(2, 5)
    # path.append_point(point)
    # ```
    def append_point: (*untyped args) -> untyped

    # The {#arc} method returns the parameters of an arc from the {Layout::Path},
    # or +nil+ if path is not an arc.
    # 
    # _@return_ — The center point,
    # radius, start angle, and end angle
    # 
    # ```ruby
    # start_angle, radius, start, end = path.arc
    # ```
    def arc: () -> [Geom::Point2d, Float, Float, Float]?

    # The {#circle} method returns the parameters of a circle from the
    # {Layout::Path}, or +nil+ if path is not a circle.
    # 
    # _@return_ — The center point and the radius
    # 
    # ```ruby
    # center_point, radius = path.circle
    # ```
    def circle: () -> [Geom::Point2d, Float]?

    # sord omit - no YARD return type given, using untyped
    # The {#close} method closes the {Layout::Path}.
    # 
    # ```ruby
    # path.close
    # ```
    def close: () -> untyped

    # The {#closed?} method returns whether the {Layout::Path} is closed.
    # 
    # ```ruby
    # is_closed = path.closed?
    # ```
    def closed?: () -> bool

    # The {#end_arrow} method creates a new {Layout::Path} from an end arrow.
    # 
    # _@return_ — The end arrow
    # 
    # ```ruby
    # path = Layout::Path.end_arrow(path_with_end_arrow)
    # ```
    def end_arrow: () -> Layout::Path?

    # The {#end_point} method returns the end point of the {Layout::Path}.
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(2, 2)
    # path = Layout::Path.new(start_point, end_point)
    # # should be equal to end_point
    # endp = path.end_point
    # ```
    def end_point: () -> Geom::Point2d

    # sord omit - no YARD type given for "*args", using untyped
    # The {#initialize} method creates a new {Layout::Path} between a start point
    # and an end point, or from a provided {Layout::Rectangle} or
    # {Layout::Ellipse}.
    # 
    # ```ruby
    # start = Geom::Point2d.new(1, 1)
    # end = Geom::Point2d.new(2, 2)
    # new_path = Layout::Path.new(start, end)
    # ```
    # 
    # ```ruby
    # start = Geom::Point2d.new(1, 1)
    # control_1 = Geom::Point2d.new(1.5, 1)
    # control_2 = Geom::Point2d.new(1, 1.5)
    # end = Geom::Point2d.new(2, 2)
    # new_path = Layout::Path.new(start, control_1, control_2, end)
    # ```
    def initialize: (*untyped args) -> void

    # The {#parametric_length} method returns the parametric length for the
    # {Layout::Path}. The parametric length is the length with respect to the curve
    # of the {Layout::Path}.
    # 
    # ```ruby
    # length = path.parametric_length
    # ```
    def parametric_length: () -> Float

    # The {#point_at} method returns the {Geom::Point2d} at a given parametric
    # value.
    # 
    # _@param_ `parametric_value`
    # 
    # ```ruby
    # length = path.parametric_length
    # # Get the point halfway along the path
    # halfway_point = path.point_at(length/2)
    # ```
    def point_at: (Float parametric_value) -> Geom::Point2d

    # The {#point_types} method returns an array of point types corresponding to
    # the {Geom::Point2d}s in the {Layout::Path}.
    # 
    # A point type can be one of the following values:
    # [+POINT_TYPE_MOVE_TO+]
    # [+POINT_TYPE_LINE_TO+]
    # [+POINT_TYPE_BEZIER_TO+]
    # [+POINT_TYPE_ARC_CENTER+]
    # [+POINT_TYPE_BEZIER_CONTROL+]
    # [+POINT_TYPE_CLOSE+]
    # 
    # _@return_ — An array of integers that correspond with point types.
    # 
    # ```ruby
    # types = path.point_types
    # ```
    def point_types: () -> ::Array[Integer]

    # The {#points} method returns an array of {Geom::Point2d}s in the
    # {Layout::Path}.
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(2, 2)
    # new_path = Layout::Path.new(start_point, end_point)
    # # Should be an array with points [1, 1] and [2, 2]
    # points = new_path.points
    # ```
    def points: () -> ::Array[Geom::Point2d]

    # The {#start_arrow} method creates a new {Layout::Path} from a start
    # arrow.
    # 
    # _@return_ — The start arrow
    # 
    # ```ruby
    # start_arrow = path.start_arrow
    # ```
    def start_arrow: () -> Layout::Path?

    # The {#start_point} method returns the start point of the {Layout::Path}.
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(2, 2)
    # path = Layout::Path.new(start_point, end_point)
    # # should be equal to start_point
    # start = path.start_point
    # ```
    def start_point: () -> Geom::Point2d

    # The {#tangent_at} method returns the tangent {Geom::Vector2d} at the given
    # parametric value.
    # 
    # _@param_ `parametric_value`
    # 
    # ```ruby
    # length = path.parametric_length
    # # Get the tangent halfway along the path
    # halfway_tangent = path.tangent_at(length/2)
    # ```
    def tangent_at: (Float parametric_value) -> Geom::Vector2d

    # The {#winding} method returns the winding type of the {Layout::Path}.
    # 
    # A point type can be one of the following values:
    # [+PATH_WINDING_NONE+]
    # [+PATH_WINDING_CLOCKWISE+]
    # [+PATH_WINDING_COUNTER_CLOCKWISE+]
    # 
    # ```ruby
    # winding = path.winding
    # ```
    def winding: () -> Integer
  end

  # A group is a special type of {Layout::Entity} that does not belong to a
  # {Layout::Layer} and contains other {Layout::Entity}s as children. A
  # {Layout::Group}'s children may include other {Layout::Group}s, allowing for a
  # hierarchical tree structure of {Layout::Entity}s. A {Layout::Group} must
  # contain at least one child and will be automatically collapsed if an
  # operation is performed that results in the {Layout::Group} being empty.
  # 
  # @version LayOut 2018
  class Group < Layout::Entity
    RESIZE_BEHAVIOR_BOUNDS: untyped
    RESIZE_BEHAVIOR_BOUNDS_AND_FONTS: untyped
    RESIZE_BEHAVIOR_NONE: untyped

    # The {#entities} method returns the {Layout::Entities} that belong to the
    # {Layout::Group}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # group = doc.shared_entities.first
    # entities = group.entities
    # ```
    def entities: () -> Layout::Entities

    # The {#initialize} method creates a new {Layout::Group}.
    # 
    # _@param_ `entities`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.shared_entities
    # entities.each { |entity|
    #   entity_array.push(entity)
    # }
    # group = Layout::Group.new(entity_array)
    # ```
    def initialize: (::Array[Layout::Entity] entities) -> void

    # sord omit - no YARD return type given, using untyped
    # The {#remove_scale_factor} method removes the scale factor from the
    # {Layout::Group}.
    # 
    # The resize behavior can be one of the following values:
    # [+Layout::Group::RESIZE_BEHAVIOR_NONE+]
    # [+Layout::Group::RESIZE_BEHAVIOR_BOUNDS+]
    # [+Layout::Group::RESIZE_BEHAVIOR_BOUNDS_AND_FONTS+]
    # 
    # _@param_ `resize_behavior`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # group = doc.shared_entities.first
    # group.remove_scale_factor(true)
    # ```
    def remove_scale_factor: (Integer resize_behavior) -> untyped

    # The {#scale_factor} method returns the the scale factor associated with the
    # {Layout::Group}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # group = doc.shared_entities.first
    # scale = group.scale_factor
    # ```
    def scale_factor: () -> Float?

    # The {#scale_precision} method returns the precision used for the scale of the
    # {Layout::Group}.
    # 
    # _@return_ — the number specifying the precision for the {Layout::Group}
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # group = doc.shared_entities.first
    # precision = group.scale_precision
    # ```
    def scale_precision: () -> Float

    # sord omit - no YARD return type given, using untyped
    # The {#scale_precision=} method sets the precision for the scale of the
    # {Layout::Group}.
    # 
    # _@param_ `precision` — The double specifying the precision for the {Layout::Group}
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # group = doc.shared_entities.first
    # group.scale_precision = 0.0001
    # ```
    # 
    # _@note_ — LayOut only allows for a finite set of precision values for each units
    # setting, so it will set the precision to the closest valid setting for the
    # specified units. See the "Units" section of LayOut's "Document Setup"
    # dialog for a reference of the available precisions for each units setting.
    def scale_precision=: (Float precision) -> untyped

    # The {#scale_units} method returns the units format used in the scale for the
    # {Layout::Group}.
    # 
    # The units format can be any of the following values:
    # [Layout::Document::FRACTIONAL_INCHES]
    # [Layout::Document::DECIMAL_INCHES]
    # [Layout::Document::DECIMAL_FEET]
    # [Layout::Document::DECIMAL_MILLIMETERS]
    # [Layout::Document::DECIMAL_CENTIMETERS]
    # [Layout::Document::DECIMAL_METERS]
    # [Layout::Document::DECIMAL_POINTS]
    # 
    # _@return_ — units The units format of the scale factor
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # group = doc.shared_entities.first
    # units = group.scale_units
    # ```
    def scale_units: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#scale_units=} method sets the the units format for the scale of the
    # {Layout::Group}.
    # 
    # The units format can be any of the following values:
    # [Layout::Document::FRACTIONAL_INCHES]
    # [Layout::Document::DECIMAL_INCHES]
    # [Layout::Document::DECIMAL_FEET]
    # [Layout::Document::DECIMAL_MILLIMETERS]
    # [Layout::Document::DECIMAL_CENTIMETERS]
    # [Layout::Document::DECIMAL_METERS]
    # [Layout::Document::DECIMAL_POINTS]
    # 
    # _@param_ `units_format`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # group = doc.shared_entities.first
    # group.scale_units = Layout::Document::DECIMAL_FEET
    # ```
    def scale_units=: (Integer units_format) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#set_scale_factor} method sets the the scale factor for the
    # {Layout::Group}.
    # 
    # The units format can be any of the following values:
    # [Layout::Document::FRACTIONAL_INCHES]
    # [Layout::Document::DECIMAL_INCHES]
    # [Layout::Document::DECIMAL_FEET]
    # [Layout::Document::DECIMAL_MILLIMETERS]
    # [Layout::Document::DECIMAL_CENTIMETERS]
    # [Layout::Document::DECIMAL_METERS]
    # [Layout::Document::DECIMAL_POINTS]
    # 
    # The resize behavior can be one of the following values:
    # [+Layout::Group::RESIZE_BEHAVIOR_NONE+]
    # [+Layout::Group::RESIZE_BEHAVIOR_BOUNDS+]
    # [+Layout::Group::RESIZE_BEHAVIOR_BOUNDS_AND_FONTS+]
    # 
    # _@param_ `scale_factor`
    # 
    # _@param_ `units_format`
    # 
    # _@param_ `resize_behavior`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # group = doc.shared_entities.first
    # group.set_scale_factor(2.0, Layout::Group::RESIZE_BEHAVIOR_BOUNDS)
    # ```
    def set_scale_factor: (Float scale_factor, Integer units_format, Integer resize_behavior) -> untyped

    # The {#ungroup} method removes all {Layout::Entity}s from the {Layout::Group}
    # and deletes the {Layout::Group}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # group = doc.shared_entities.first
    # group.ungroup
    # ```
    def ungroup: () -> bool
  end

  # A raster image entity.
  # 
  # @example
  #   image = Layout::Image.new("my_image.png", [[1, 1], [3, 3]])
  #   clip_mask = image.clip_mask
  #   if clip_mask.is_a?(Layout::Rectangle)
  #     point1 = Geom::Point2d.new(1, 1)
  #     point2 = Geom::Point2d.new(2, 2)
  #     bounds = [point1, point2]
  #     image.clip_mask = Layout::Ellipse.new(bounds)
  #   end
  # 
  # @version LayOut 2018
  class Image < Layout::Entity
    # The {#clip_mask} method returns the clip mask of the {Layout::Image}, or
    # +nil+ if it does not have a clip mask.
    # 
    # _@return_ — The clip mask can be a {Layout::Path},
    # {Layout::Rectangle}, or {Layout::Ellipse}.
    # 
    # ```ruby
    # image = Layout::Image.new("my_image.png", [[1, 1], [3, 3]])
    # clip_mask = image.clip_mask
    # ```
    def clip_mask: () -> Layout::Entity

    # sord omit - no YARD return type given, using untyped
    # The {#clip_mask=} method sets the clip mask of the {Layout::Image}. clip_mask
    # can be a {Layout::Rectangle}, {Layout::Ellipse}, or {Layout::Path}, or +nil+,
    # and it must not currently exist in a {Layout::Document}, or {Layout::Group}.
    # 
    # _@param_ `clip_mask` — The clip mask can be a {Layout::Path}, {Layout::Rectangle}, {Layout::Ellipse}, or +nil+.
    # 
    # ```ruby
    # image = Layout::Image.new("my_image.png", [[1, 1], [3, 3]])
    # point1 = Geom::Point2d.new(1, 1)
    # point2 = Geom::Point2d.new(2, 2)
    # bounds = [point1, point2]
    # clip_mask = Layout::Rectangle.new(bounds)
    # image.clip_mask = clip_mask
    # ```
    # 
    # _@note_ — +clip_mask+ may be +nil+ as of LayOut 2020.1.
    def clip_mask=: (Layout::Entity? clip_mask) -> untyped

    # The {#initialize} method creates a new {Layout::Image} from a given image
    # file.
    # 
    # _@param_ `path` — The path to the file
    # 
    # _@param_ `bounds`
    # 
    # ```ruby
    # image = Layout::Image.new("my_image.png", [[1, 1], [3, 3]])
    # ```
    def initialize: (String path, Geom::Bounds2d bounds) -> void
  end

  # This is an interface to a label entity. A {Layout::Label} consists of a
  # {Layout::FormattedText} and the label leader {Layout::Path}. A
  # {Layout::Label} may be connected to another {Layout::Entity} via a
  # {Layout::ConnectionPoint}.
  # 
  # @version LayOut 2018
  class Label < Layout::Entity
    CONNECTION_TYPE_AUTO: untyped
    CONNECTION_TYPE_BOTTOM_LEFT: untyped
    CONNECTION_TYPE_BOTTOM_RIGHT: untyped
    CONNECTION_TYPE_CENTER_LEFT: untyped
    CONNECTION_TYPE_CENTER_RIGHT: untyped
    CONNECTION_TYPE_NONE: untyped
    CONNECTION_TYPE_REVERSE_AUTO: untyped
    CONNECTION_TYPE_TOP_LEFT: untyped
    CONNECTION_TYPE_TOP_RIGHT: untyped
    LEADER_LINE_TYPE_BEZIER: untyped
    LEADER_LINE_TYPE_SINGLE_SEGMENT: untyped
    LEADER_LINE_TYPE_TWO_SEGMENT: untyped
    LEADER_LINE_TYPE_UNKNOWN: untyped

    # sord omit - no YARD return type given, using untyped
    # The {#connect} method connects the {Layout::Label} to the given
    # {Layout::ConnectionPoint}. The leader line will be adjusted to point at the
    # {Layout::ConnectionPoint}. The {Layout::Label} must be in the same
    # {Layout::Document} as the {Layout::ConnectionPoint}. If both the
    # {Layout::Label} and the {Layout::ConnectionPoint}'s {Layout::Entity} are on
    # non-shared {Layout::Layer}s, they must be on the same {Layout::Page}.
    # 
    # _@param_ `connection_point`
    # 
    # ```ruby
    # text = "A label"
    # leader_type = Layout::Label::LEADER_LINE_TYPE_BEZIER
    # target_point = Geom::Point2d.new(1, 1)
    # bounds = Geom::Bounds2d.new(2, 1, 1, 1)
    # label = Layout::Label.new(text, leader_type, target_point, bounds)
    # rect = Layout::Rectangle.new([4, 4, 4, 4])
    # 
    # doc = Layout::Document.new
    # doc.add_entity(label, doc.layers.first, doc.pages.first)
    # doc.add_entity(rect, doc.layers.first, doc.pages.first)
    # 
    # point = Geom::Point2d.new(4, 4)
    # # Create a Connection Point to a LayOut Entity in the Document
    # cp = Layout::ConnectionPoint.new(rect, point)
    # label.connect(cp)
    # ```
    def connect: (Layout::ConnectionPoint connection_point) -> untyped

    # The {#connection_type} method returns the type of the text connection for the
    # {Layout::Label}.
    # 
    # The leader line type can be one of the following values:
    # [+Layout::Label::CONNECTION_TYPE_NONE+]
    # [+Layout::Label::CONNECTION_TYPE_AUTO+]
    # [+Layout::Label::CONNECTION_TYPE_REVERSE_AUTO+]
    # [+Layout::Label::CONNECTION_TYPE_TOP_LEFT+]
    # [+Layout::Label::CONNECTION_TYPE_CENTER_LEFT+]
    # [+Layout::Label::CONNECTION_TYPE_BOTTOM_LEFT+]
    # [+Layout::Label::CONNECTION_TYPE_TOP_RIGHT+]
    # [+Layout::Label::CONNECTION_TYPE_CENTER_RIGHT+]
    # [+Layout::Label::CONNECTION_TYPE_BOTTOM_RIGHT+]
    # 
    # ```ruby
    # text = "A label"
    # leader_type = Layout::Label::LEADER_LINE_TYPE_BEZIER
    # target_point = Geom::Point2d.new(1, 1)
    # bounds = Geom::Bounds2d.new(2, 1, 1, 1)
    # label_from_bounds = Layout::Label.new(text, leader_type, target_point,
    #   bounds)
    # text_connection_type = label_from_bounds.connection_type
    # ```
    def connection_type: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#connection_type=} method sets the type of the text connection for the
    # {Layout::Label}.
    # 
    # The leader line type can be one of the following values:
    # [+Layout::Label::CONNECTION_TYPE_NONE+]
    # [+Layout::Label::CONNECTION_TYPE_AUTO+]
    # [+Layout::Label::CONNECTION_TYPE_REVERSE_AUTO+]
    # [+Layout::Label::CONNECTION_TYPE_TOP_LEFT+]
    # [+Layout::Label::CONNECTION_TYPE_CENTER_LEFT+]
    # [+Layout::Label::CONNECTION_TYPE_BOTTOM_LEFT+]
    # [+Layout::Label::CONNECTION_TYPE_TOP_RIGHT+]
    # [+Layout::Label::CONNECTION_TYPE_CENTER_RIGHT+]
    # [+Layout::Label::CONNECTION_TYPE_BOTTOM_RIGHT+]
    # 
    # _@param_ `connection_type`
    # 
    # ```ruby
    # text = "A label"
    # leader_type = Layout::Label::LEADER_LINE_TYPE_BEZIER
    # target_point = Geom::Point2d.new(1, 1)
    # bounds = Geom::Bounds2d.new(2, 1, 1, 1)
    # label_from_bounds = Layout::Label.new(text, leader_type, target_point,
    #   bounds)
    # label_from_bounds.connection_type = Layout::Label::CONNECTION_TYPE_TOP_LEFT
    # ```
    def connection_type=: (Integer connection_type) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#disconnect} method disconnects the {Layout::Label} from its
    # {Layout::ConnectionPoint}. The leader line will not be adjusted by
    # disconnecting from a {Layout::ConnectionPoint}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # label = doc.pages.first.entities.first
    # label.disconnect
    # ```
    def disconnect: () -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#entities} method returns the {Layout::Entities} that represent the
    # {Layout::Label} in its exploded form.
    # 
    # ```ruby
    # text = "A label"
    # leader_type = Layout::Label::LEADER_LINE_TYPE_BEZIER
    # target_point = Geom::Point2d.new(1, 1)
    # bounds = Geom::Bounds2d.new(2, 1, 1, 1)
    # label_from_bounds = Layout::Label.new(text, leader_type, target_point,
    #   bounds)
    # entities = label_from_bounds.entities
    # ```
    def entities: (*untyped args) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # The {#initialize} method creates a new disconnected {Layout::Label}.
    # 
    # ```ruby
    # text = "A label"
    # leader_type = Layout::Label::LEADER_LINE_TYPE_BEZIER
    # target_point = Geom::Point2d.new(1, 1)
    # bounds = Geom::Bounds2d.new(2, 1, 1, 1)
    # label_from_bounds = Layout::Label.new(text, leader_type, target_point,
    #   bounds)
    # anchor_point = Geom::Point2d.new(2, 2)
    # anchor_type = Layout::FormattedText::ANCHOR_TYPE_TOP_RIGHT
    # label_from_point = Layout::Label.new(text, leader_type, target_point,
    #   anchor_point, anchor_type)
    # ```
    def initialize: (*untyped args) -> void

    # The {#leader_line} method returns a copy of the leader line.
    # 
    # ```ruby
    # text = "A label"
    # leader_type = Layout::Label::LEADER_LINE_TYPE_BEZIER
    # target_point = Geom::Point2d.new(1, 1)
    # bounds = Geom::Bounds2d.new(2, 1, 1, 1)
    # label_from_bounds = Layout::Label.new(text, leader_type, target_point,
    #   bounds)
    # leader = label_from_bounds.leader_line
    # ```
    def leader_line: () -> Layout::Path

    # sord omit - no YARD return type given, using untyped
    # The {#leader_line=} method sets the leader line.
    # 
    # _@param_ `leader_path`
    # 
    # ```ruby
    # text = "A label"
    # leader_type = Layout::Label::LEADER_LINE_TYPE_BEZIER
    # target_point = Geom::Point2d.new(1, 1)
    # bounds = Geom::Bounds2d.new(2, 1, 1, 1)
    # label_from_bounds = Layout::Label.new(text, leader_type, target_point,
    #   bounds)
    # path = Layout::Path.new(Geom::Point2d.new(1, 2), Geom::Point2d.new(2, 3))
    # label_from_bounds.leader_line = path
    # ```
    def leader_line=: (Layout::Path leader_path) -> untyped

    # The {#leader_line_type} method returns the type of the leader line for the
    # {Layout::Label}.
    # 
    # The leader line type can be one of the following values:
    # [+Layout::Label::LEADER_LINE_TYPE_SINGLE_SEGMENT+]
    # [+Layout::Label::LEADER_LINE_TYPE_TWO_SEGMENT+]
    # [+Layout::Label::LEADER_LINE_TYPE_BEZIER+]
    # [+Layout::Label::LEADER_LINE_TYPE_UNKNOWN+]
    # 
    # ```ruby
    # text = "A label"
    # leader_type = Layout::Label::LEADER_LINE_TYPE_BEZIER
    # target_point = Geom::Point2d.new(1, 1)
    # bounds = Geom::Bounds2d.new(2, 1, 1, 1)
    # label_from_bounds = Layout::Label.new(text, leader_type, target_point,
    #   bounds)
    # leader_type = label_from_bounds.leader_line_type
    # ```
    def leader_line_type: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#leader_line_type=} method sets the type of the leader line for the
    # {Layout::Label}.
    # 
    # The leader line type can be one of the following values:
    # [+Layout::Label::LEADER_LINE_TYPE_SINGLE_SEGMENT+]
    # [+Layout::Label::LEADER_LINE_TYPE_TWO_SEGMENT+]
    # [+Layout::Label::LEADER_LINE_TYPE_BEZIER+]
    # [+Layout::Label::LEADER_LINE_TYPE_UNKNOWN+]
    # 
    # _@param_ `leader_type`
    # 
    # ```ruby
    # text = "A label"
    # leader_type = Layout::Label::LEADER_LINE_TYPE_BEZIER
    # target_point = Geom::Point2d.new(1, 1)
    # bounds = Geom::Bounds2d.new(2, 1, 1, 1)
    # label_from_bounds = Layout::Label.new(text, leader_type, target_point,
    #   bounds)
    # label_from_bounds.leader_line_type = Layout::Label::LEADER_LINE_TYPE_BEZIER
    # ```
    def leader_line_type=: (Integer leader_type) -> untyped

    # The {#text} method returns a copy of the {Layout::FormattedText} of the
    # {Layout::Label}.
    # 
    # ```ruby
    # text = "A label"
    # leader_type = Layout::Label::LEADER_LINE_TYPE_BEZIER
    # target_point = Geom::Point2d.new(1, 1)
    # bounds = Geom::Bounds2d.new(2, 1, 1, 1)
    # label_from_bounds = Layout::Label.new(text, leader_type, target_point,
    #   bounds)
    # text = label_from_bounds.text
    # ```
    def text: () -> Layout::FormattedText

    # sord omit - no YARD return type given, using untyped
    # The {#text=} method sets the {Layout::FormattedText} of the {Layout::Label}.
    # 
    # _@param_ `new_text`
    # 
    # ```ruby
    # text = "A label"
    # leader_type = Layout::Label::LEADER_LINE_TYPE_BEZIER
    # target_point = Geom::Point2d.new(1, 1)
    # bounds = Geom::Bounds2d.new(2, 1, 1, 1)
    # label_from_bounds = Layout::Label.new(text, leader_type, target_point,
    #   bounds)
    # anchor = Geom::Point2d.new(1, 1)
    # anchor_type = Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT
    # text = Layout::FormattedText.new("Test", anchor, anchor_type)
    # label_from_bounds.text = text
    # ```
    def text=: (Layout::FormattedText new_text) -> untyped
  end

  # This is the interface to a LayOut Layer Definition. A layer definition
  # specifies the document-wide information about a layer. To access the entities
  # on a layer for a given page, use {Layout::LayerInstance}.
  # 
  # @example
  #   # Grab a handle to an existing LayOut document.
  #   doc = Layout::Document.open("C:/path/to/document.layout")
  # 
  #   new_layer = doc.layers.add(true)
  #   new_layer.name = "A new layer"
  # 
  # @version LayOut 2018
  class Layer
    SHARELAYERACTION_CLEAR: untyped
    SHARELAYERACTION_KEEPONEPAGE: untyped
    SHARELAYERACTION_MERGEALLPAGES: untyped
    UNSHARELAYERACTION_CLEAR: untyped
    UNSHARELAYERACTION_COPYTOALLPAGES: untyped
    UNSHARELAYERACTION_COPYTOONEPAGE: untyped

    # The {#==} method checks to see if the two {Layout::Layer}s are equal.
    # This checks whether the Ruby Objects are pointing to the same internal
    # object.
    # 
    # _@param_ `other`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # document = doc.pages.first.document
    # doc.layers.first == document.layers.first
    # ```
    def ==: (Layout::Layer other) -> bool

    # The {#document} method returns the {Layout::Document} that the {Layout::Layer}
    # belongs to.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # first_layer = doc.layers.first
    # # layer_doc should reference the same document as doc
    # layer_doc = first_layer.document
    # ```
    def document: () -> Layout::Document

    # sord omit - no YARD type given for "page", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#layer_instance} method returns a {Layout::LayerInstance} from the
    # {Layout::Layer}. If the {Layout::Layer} is shared, a {Layout::Page} does not
    # have to be provided.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # page = doc.pages.first
    # layer_instance = layers.first.layer_instance(page)
    # ```
    def layer_instance: (untyped page) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#locked=} method sets whether the {Layout::Layer} is locked.
    # 
    # _@param_ `locked` — +true+ to lock the {Layout::Layer}, +false+ to unlock it
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # layers.first.locked = false
    # ```
    def locked=: (bool locked) -> untyped

    # The {#locked?} method returns whether the {Layout::Layer} is locked.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # is_locked = layer.first.locked?
    # ```
    def locked?: () -> bool

    # The {#name} method returns the name of the {Layout::Layer}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # layer_name = layers.first.name
    # ```
    def name: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#name=} sets the name of the {Layout::Layer}.
    # 
    # _@param_ `name`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # layers.first.name = "Base layer"
    # ```
    def name=: (String name) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#set_nonshared} method sets the {Layout::Layer} to non-shared.
    # 
    # The unshare action can be one of the following values:
    # [+Layout::Layer::UNSHARELAYERACTION_CLEAR+]
    # [+Layout::Layer::UNSHARELAYERACTION_COPYTOONEPAGE+]
    # [+Layout::Layer::UNSHARELAYERACTION_COPYTOALLPAGES+]
    # 
    # _@param_ `page` — The {Layout::Page} with the {Layout::Layer} to be non-shared.
    # 
    # _@param_ `unshare_action` — The share action that specifies what to do with {Layout::Entity}s after the {Layout::Layer} is non-shared.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # page = doc.pages.first
    # layers.first.set_nonshared(page, Layout::Layer::UNSHARELAYERACTION_COPYTOONEPAGE);
    # ```
    def set_nonshared: (Layout::Page page, Integer unshare_action) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#set_shared} method sets the {Layout::Layer} to shared.
    # 
    # The share action can be one of the following values:
    # [+Layout::Layer::SHARELAYERACTION_CLEAR+]
    # [+Layout::Layer::SHARELAYERACTION_KEEPONEPAGE+]
    # [+Layout::Layer::SHARELAYERACTION_MERGEALLPAGES+]
    # 
    # _@param_ `page` — The {Layout::Page} with the {Layout::Layer} to be shared.
    # 
    # _@param_ `share_action` — The share action that specifies what to do with {Layout::Entity}s after the {Layout::Layer} is shared.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # page = doc.pages.first
    # layers.first.set_shared(page, Layout::Layer::SHARELAYERACTION_KEEPONEPAGE);
    # ```
    def set_shared: (Layout::Page page, Integer share_action) -> untyped

    # The {#shared?} method returns whether the {Layout::Layer} is shared.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # is_shared = layers.first.shared?
    # ```
    def shared?: () -> bool
  end

  # The Pages class is a container class for all pages in a {Layout::Document}.
  # 
  # @example
  #   # Grab a handle to an existing LayOut document's pages.
  #   doc = Layout::Document.open("C:/path/to/document.layout")
  #   pages = doc.pages
  # 
  #   # From here, we can add pages to or remove them from the document
  #   pages.add("New Page")
  #   pages.remove(pages[0])
  # 
  # @version LayOut 2018
  class Pages
    include Enumerable[Page]

    # The {#[]} method returns a value from the array of {Layout::Page}s.
    # 
    # _@param_ `index` — The index of the {Layout::Page} to return.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # pages = doc.pages
    # page = pages[2]
    # ```
    def []: (Integer index) -> Layout::Page

    # The {#add} method adds a new {Layout::Page} to the {Layout::Document}.
    # The newly added {Layout::Page} will be the last one in the {Layout::Document}.
    # 
    # _@param_ `name` — The name for the new page.
    # 
    # _@return_ — The newly added {Layout::Page}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # pages = doc.pages
    # new_page = pages.add
    # ```
    def add: (?String? name) -> Layout::Page

    # sord omit - no YARD return type given, using untyped
    # The {#each} method iterates through all of the {Layout::Page}s.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # pages = doc.pages
    # pages.each { |page|
    #   puts page.name
    # }
    # ```
    # 
    # _@note_ — Don't remove content from this collection while iterating over it with
    # {#each}. This would change the size of the collection and cause elements to
    # be skipped as the indices change. Instead copy the current collection to an
    # array using +to_a+ and then use +each+ on the array, when removing content.
    def each: () ?{ (Layout::Page page) -> void } -> untyped

    # The {#index} method returns the index of the {Layout::Page}, or +nil+ if
    # it doesn't exist in the {Layout::Document}.
    # 
    # _@param_ `page`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # pages = doc.pages
    # page_index = pages.index(pages.first) # Returns 0
    # ```
    def index: (Layout::Page page) -> Integer?

    # The {#initial} method returns the initial {Layout::Page} that will be
    # displayed the next time the {Layout::Document} is opened. This value will
    # change whenever the {Layout::Page} is changed in the {Layout::Document} in
    # LayOut.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # pages = doc.pages
    # page = pages.initial
    # ```
    def initial: () -> Layout::Page

    # sord infer - inferred type of parameter "page" as Layout::Page using getter's return type
    # sord omit - no YARD return type given, using untyped
    # The {#initial=} method sets the initial {Layout::Page} that will be
    # displayed the next time the {Layout::Document} is opened. This value will
    # change whenever the {Layout::Page} is changed in the {Layout::Document} in
    # LayOut.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # pages = doc.pages
    # pages.initial = doc.pages[0]
    # ```
    def initial=: (Layout::Page page) -> untyped

    # The {#length} method returns the number of {Layout::Page}s.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # pages = doc.pages
    # num_pages = pages.length
    # ```
    def length: () -> Integer

    # sord omit - no YARD type given for "page", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#remove} method deletes the given {Layout::Page} from the
    # {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # pages = doc.pages
    # pages.remove(pages[0])
    # ```
    def remove: (untyped page) -> untyped

    # sord omit - no YARD type given for "page", using untyped
    # sord omit - no YARD type given for "new_index", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#reorder} method moves a {Layout::Page} to a different index within
    # the {Layout::Document}'s list of pages. This will move the {Layout::Page}
    # such that its new index becomes new_index.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # pages = doc.pages
    # pages.reorder(pages[1], 3)
    # ```
    def reorder: (untyped page, untyped new_index) -> untyped
  end

  # References a collection of style attributes that determine the visual
  # appearance of {Layout::Entity}s. Style attributes are those attributes which
  # the user can manipulate in LayOut's inspector windows. For example, shape
  # style attributes that define stroke and fill, or text style attributes that
  # define the font for {Layout::FormattedText}. The {Layout::Document} maintains
  # a default style for various types of {Layout::Entity}s, and it is possible to
  # apply the style of one entity to another. {Layout::Style} objects are
  # transient and do not belong to a {Layout::Document}.
  # 
  # @version LayOut 2018
  class Style
    ALIGN_CENTER: untyped
    ALIGN_LEFT: untyped
    ALIGN_RIGHT: untyped
    ANCHOR_BOTTOM: untyped
    ANCHOR_CENTER: untyped
    ANCHOR_TOP: untyped
    ARCHITECTURAL_INCHES: untyped
    ARROW_FILLED_CIRCLE: untyped
    ARROW_FILLED_DIAMOND: untyped
    ARROW_FILLED_SKINNY_TRIANGLE: untyped
    ARROW_FILLED_SQUARE: untyped
    ARROW_FILLED_TRIANGLE: untyped
    ARROW_NONE: untyped
    ARROW_OPEN_ARROW_120: untyped
    ARROW_OPEN_ARROW_90: untyped
    ARROW_OPEN_CIRCLE: untyped
    ARROW_OPEN_DIAMOND: untyped
    ARROW_OPEN_SKINNY_TRIANGLE: untyped
    ARROW_OPEN_SQUARE: untyped
    ARROW_OPEN_TRIANGLE: untyped
    ARROW_OVERRUN: untyped
    ARROW_SLASH_LEFT: untyped
    ARROW_SLASH_RIGHT: untyped
    ARROW_STAR: untyped
    ARROW_T: untyped
    ARROW_UNDERRUN: untyped
    CAP_STYLE_FLAT: untyped
    CAP_STYLE_ROUND: untyped
    CAP_STYLE_SQUARE: untyped
    DIMENSION_TEXT_ABOVE: untyped
    DIMENSION_TEXT_BELOW: untyped
    DIMENSION_TEXT_CENTER: untyped
    DIMENSION_TEXT_HORIZONTAL: untyped
    DIMENSION_TEXT_OFFSET: untyped
    DIMENSION_TEXT_PARALLEL: untyped
    DIMENSION_TEXT_PERPENDICULAR: untyped
    DIMENSION_TEXT_VERTICAL: untyped
    DECIMAL_CENTIMETERS: untyped
    DECIMAL_FEET: untyped
    DECIMAL_INCHES: untyped
    DECIMAL_METERS: untyped
    DECIMAL_MILLIMETERS: untyped
    DECIMAL_POINTS: untyped
    DEGREES: untyped
    DIMENSION_END_EXTENSION_LINE: untyped
    DIMENSION_LEADER_LINE: untyped
    DIMENSION_LINE: untyped
    DIMENSION_START_EXTENSION_LINE: untyped
    DIMENSION_TEXT: untyped
    ENGINEERING_FEET: untyped
    FRACTIONAL_INCHES: untyped
    JOIN_STYLE_BEVEL: untyped
    JOIN_STYLE_MITER: untyped
    JOIN_STYLE_ROUND: untyped
    LABEL_LEADER_LINE: untyped
    LABEL_TEXT: untyped
    NORMAL_SCRIPT: untyped
    RADIANS: untyped
    STROKE_PATTERN_CENTER: untyped
    STROKE_PATTERN_DASH: untyped
    STROKE_PATTERN_DASH_DASH_DOT: untyped
    STROKE_PATTERN_DASH_DASH_DOT_DOT: untyped
    STROKE_PATTERN_DASH_DASH_DOT_DOT_DOT: untyped
    STROKE_PATTERN_DASH_DOT: untyped
    STROKE_PATTERN_DASH_DOT_DOT: untyped
    STROKE_PATTERN_DASH_DOT_DOT_DOT: untyped
    STROKE_PATTERN_DASH_SPACE: untyped
    STROKE_PATTERN_DOT: untyped
    STROKE_PATTERN_PHANTOM: untyped
    STROKE_PATTERN_SHORT_DASH: untyped
    STROKE_PATTERN_SOLID: untyped
    SUPER_SCRIPT: untyped
    SUB_SCRIPT: untyped
    UNDERLINE_DOUBLE: untyped
    UNDERLINE_NONE: untyped
    UNDERLINE_SINGLE: untyped

    # sord omit - no YARD type given for "arrow_type", using untyped
    # The {.arrow_type_filled?} method returns whether the specified arrow type is
    # filled or not.
    # 
    # The arrow type can be one of the following values:
    # [+Layout::Style::ARROW_NONE+]
    # [+Layout::Style::ARROW_FILLED_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_TRIANGLE+]
    # [+Layout::Style::ARROW_FILLED_SKINNY_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_SKINNY_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_ARROW_90+]
    # [+Layout::Style::ARROW_OPEN_ARROW_120+]
    # [+Layout::Style::ARROW_FILLED_CIRCLE+]
    # [+Layout::Style::ARROW_OPEN_CIRCLE+]
    # [+Layout::Style::ARROW_FILLED_SQUARE+]
    # [+Layout::Style::ARROW_OPEN_SQUARE+]
    # [+Layout::Style::ARROW_FILLED_DIAMOND+]
    # [+Layout::Style::ARROW_OPEN_DIAMOND+]
    # [+Layout::Style::ARROW_STAR+]
    # [+Layout::Style::ARROW_T+]
    # [+Layout::Style::ARROW_SLASH_RIGHT+]
    # [+Layout::Style::ARROW_SLASH_LEFT+]
    # [+Layout::Style::ARROW_UNDERRUN+]
    # [+Layout::Style::ARROW_OVERRUN+]
    # 
    # ```ruby
    # # Returns false
    # filled = Layout::Style.arrow_type_filled?(Layout::Style::ARROW_T)
    # # Returns true
    # filled = Layout::Style.arrow_type_filled?(Layout::Style::ARROW_FILLED_SQUARE)
    # ```
    def self.arrow_type_filled?: (untyped arrow_type) -> bool

    # The {#dimension_rotation_alignment} method returns the rotational text
    # alignment for {Layout::LinearDimension} text, or +nil+ if the {Layout::Style}
    # does not have a value for that setting.
    # 
    # The rotational alignment type can be one of the following values:
    # [+Layout::Style::DIMENSION_TEXT_HORIZONTAL+]
    # [+Layout::Style::DIMENSION_TEXT_VERTICAL+]
    # [+Layout::Style::DIMENSION_TEXT_PARALLEL+]
    # [+Layout::Style::DIMENSION_TEXT_PERPENDICULAR+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # dimension_alignment = style.dimension_rotation_alignment
    # ```
    def dimension_rotation_alignment: () -> Integer?

    # sord omit - no YARD return type given, using untyped
    # The {#dimension_rotation_alignment=} method sets the rotational text
    # alignment.
    # 
    # The rotational alignment type can be one of the following values:
    # [+Layout::Style::DIMENSION_TEXT_HORIZONTAL+]
    # [+Layout::Style::DIMENSION_TEXT_VERTICAL+]
    # [+Layout::Style::DIMENSION_TEXT_PARALLEL+]
    # [+Layout::Style::DIMENSION_TEXT_PERPENDICULAR+]
    # 
    # _@param_ `alignment_type`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.dimension_rotation_alignment = Layout::Style::DIMENSION_TEXT_HORIZONTAL
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def dimension_rotation_alignment=: (Integer alignment_type) -> untyped

    # The {#dimension_units} method returns the unit format and precision for
    # dimensions, or +nil+ if the {Layout::Style} does not have a value for that
    # setting. Units may be for either {Layout::LinearDimension}s or
    # {Layout::AngularDimension}s, but not both.
    # 
    # The units can be one of the following values:
    # [+Layout::Style::FRACTIONAL_INCHES+]
    # [+Layout::Style::ARCHITECTURAL_INCHES+]
    # [+Layout::Style::ENGINEERING_FEET+]
    # [+Layout::Style::DECIMAL_INCHES+]
    # [+Layout::Style::DECIMAL_FEET+]
    # [+Layout::Style::DECIMAL_MILLIMETERS+]
    # [+Layout::Style::DECIMAL_CENTIMETERS+]
    # [+Layout::Style::DECIMAL_METERS+]
    # [+Layout::Style::DECIMAL_POINTS+]
    # [+Layout::Style::DEGREES+]
    # [+Layout::Style::RADIANS+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # units, precision = style.dimension_units
    # ```
    def dimension_units: () -> [Integer, Float]?

    # The {#dimension_vertical_alignment} method returns the vertical text
    # alignment for {Layout::LinearDimension} text, or +nil+ if the {Layout::Style}
    # does not have a value for that setting.
    # 
    # The vertical alignment type can be one of the following values:
    # [+Layout::Style::DIMENSION_TEXT_ABOVE+]
    # [+Layout::Style::DIMENSION_TEXT_CENTER+]
    # [+Layout::Style::DIMENSION_TEXT_BELOW+]
    # [+Layout::Style::DIMENSION_TEXT_OFFSET+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # dimension_alignment = style.dimension_vertical_alignment
    # ```
    def dimension_vertical_alignment: () -> Integer?

    # sord omit - no YARD return type given, using untyped
    # The {#dimension_vertical_alignment=} method sets the vertical text
    # alignment for {Layout::LinearDimension} text.
    # 
    # The vertical alignment type can be one of the following values:
    # [+Layout::Style::DIMENSION_TEXT_ABOVE+]
    # [+Layout::Style::DIMENSION_TEXT_CENTER+]
    # [+Layout::Style::DIMENSION_TEXT_BELOW+]
    # [+Layout::Style::DIMENSION_TEXT_OFFSET+]
    # 
    # _@param_ `alignment_type`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.dimension_vertical_alignment = Layout::Style::DIMENSION_TEXT_ABOVE
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def dimension_vertical_alignment=: (Integer alignment_type) -> untyped

    # The {#end_arrow_size} method returns the size of the end arrow, or +nil+ if
    # the {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # arrow_size = style.start_arrow_size
    # ```
    def end_arrow_size: () -> Float?

    # sord omit - no YARD return type given, using untyped
    # The {#end_arrow_size=} method sets the size of the end arrow. The minimum
    # size is 0.25.
    # 
    # _@param_ `arrow_size`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.end_arrow_size = 2.0
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def end_arrow_size=: (Float arrow_size) -> untyped

    # The {#end_arrow_type} method returns the type of end arrow, or +nil+ if
    # the {Layout::Style} does not have a value for that setting.
    # 
    # The arrow type can be one of the following values:
    # [+Layout::Style::ARROW_NONE+]
    # [+Layout::Style::ARROW_FILLED_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_TRIANGLE+]
    # [+Layout::Style::ARROW_FILLED_SKINNY_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_SKINNY_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_ARROW_90+]
    # [+Layout::Style::ARROW_OPEN_ARROW_120+]
    # [+Layout::Style::ARROW_FILLED_CIRCLE+]
    # [+Layout::Style::ARROW_OPEN_CIRCLE+]
    # [+Layout::Style::ARROW_FILLED_SQUARE+]
    # [+Layout::Style::ARROW_OPEN_SQUARE+]
    # [+Layout::Style::ARROW_FILLED_DIAMOND+]
    # [+Layout::Style::ARROW_OPEN_DIAMOND+]
    # [+Layout::Style::ARROW_STAR+]
    # [+Layout::Style::ARROW_T+]
    # [+Layout::Style::ARROW_SLASH_RIGHT+]
    # [+Layout::Style::ARROW_SLASH_LEFT+]
    # [+Layout::Style::ARROW_UNDERRUN+]
    # [+Layout::Style::ARROW_OVERRUN+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # arrow_type = style.end_arrow_type
    # ```
    def end_arrow_type: () -> Integer?

    # sord omit - no YARD return type given, using untyped
    # The {#end_arrow_type=} method sets the type of end arrow.
    # 
    # The arrow type can be one of the following values:
    # [+Layout::Style::ARROW_NONE+]
    # [+Layout::Style::ARROW_FILLED_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_TRIANGLE+]
    # [+Layout::Style::ARROW_FILLED_SKINNY_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_SKINNY_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_ARROW_90+]
    # [+Layout::Style::ARROW_OPEN_ARROW_120+]
    # [+Layout::Style::ARROW_FILLED_CIRCLE+]
    # [+Layout::Style::ARROW_OPEN_CIRCLE+]
    # [+Layout::Style::ARROW_FILLED_SQUARE+]
    # [+Layout::Style::ARROW_OPEN_SQUARE+]
    # [+Layout::Style::ARROW_FILLED_DIAMOND+]
    # [+Layout::Style::ARROW_OPEN_DIAMOND+]
    # [+Layout::Style::ARROW_STAR+]
    # [+Layout::Style::ARROW_T+]
    # [+Layout::Style::ARROW_SLASH_RIGHT+]
    # [+Layout::Style::ARROW_SLASH_LEFT+]
    # [+Layout::Style::ARROW_UNDERRUN+]
    # [+Layout::Style::ARROW_OVERRUN+]
    # 
    # _@param_ `arrow_type`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.end_arrow_type = Layout::Style::ARROW_SLASH_LEFT
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def end_arrow_type=: (Integer arrow_type) -> untyped

    # The {#fill_color} method returns the solid file color, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # color = style.fill_color
    # ```
    def fill_color: () -> Sketchup::Color?

    # sord omit - no YARD return type given, using untyped
    # The {#fill_color=} method sets the solid fill color.
    # 
    # _@param_ `fill_color`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.solid_filled = true
    # style.fill_color = Sketchup::Color.new(0, 255, 0, 255)
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def fill_color=: (Sketchup::Color fill_color) -> untyped

    # The {#font_family} method returns the text font name, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # font_name = style.font_family
    # ```
    def font_family: () -> String?

    # sord omit - no YARD return type given, using untyped
    # The {#font_family=} method sets the text font name.
    # 
    # _@param_ `font_family`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.font_family = "Verdana"
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def font_family=: (String font_family) -> untyped

    # The {#font_size} method returns the font size, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # font_size = style.font_size
    # ```
    def font_size: () -> Float?

    # sord omit - no YARD return type given, using untyped
    # The {#font_size=} method sets the font size.
    # 
    # _@param_ `font_size`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.font_size = 12.0
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def font_size=: (Float font_size) -> untyped

    # The {#get_sub_style} method returns the {Layout::Style} for a sub-entity
    # from the {Layout::Style}. This would be used to get the current style of a
    # {Layout::LinearDimension}'s text, for example.
    # 
    # _@param_ `type`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # sub_style = style.get_sub_style(Layout::Style::DIMENSION_TEXT)
    # ```
    def get_sub_style: (Integer _type) -> Layout::Style

    # The {#initialize} method creates a new {Layout::Style}.
    # 
    # ```ruby
    # style = Layout::Style.new
    # ```
    def initialize: () -> void

    # The {#pattern_fill_origin} method returns the starting piont for the pattern
    # fill, or +nil+ if the {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # origin = style.pattern_fill_origin
    # ```
    def pattern_fill_origin: () -> Geom::Point2d?

    # sord omit - no YARD return type given, using untyped
    # The {#pattern_fill_origin=} method sets the starting point for the pattern
    # fill.
    # 
    # _@param_ `origin`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.pattern_filled = true
    # style.pattern_fill_path = "C:/path/to/pattern.png"
    # style.pattern_fill_origin = [2, 1]
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def pattern_fill_origin=: (Geom::Point2d origin) -> untyped

    # The {#pattern_fill_path} method returns the file path to the pattern fill
    # image, or +nil+ if the {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # path = style.pattern_fill_path
    # ```
    def pattern_fill_path: () -> String?

    # sord omit - no YARD return type given, using untyped
    # The {#pattern_fill_path=} method sets the path to the image to use for the
    # pattern fill.
    # 
    # _@param_ `path`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.pattern_filled = true
    # style.pattern_fill_path = "C:/path/to/pattern.png"
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def pattern_fill_path=: (String path) -> untyped

    # The {#pattern_fill_rotation} method returns the rotation of the pattern fill
    # image in degrees, or +nil+ if the {Layout::Style} does not have a value for
    # that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # rotation = style.pattern_fill_rotation
    # ```
    def pattern_fill_rotation: () -> Float?

    # sord omit - no YARD return type given, using untyped
    # The {#pattern_fill_rotation=} method sets the rotation in degrees of the
    # pattern fill image.
    # 
    # _@param_ `rotation`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.pattern_filled = true
    # style.pattern_fill_path = "C:/path/to/pattern.png"
    # style.pattern_fill_rotation = -90.0
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def pattern_fill_rotation=: (Float rotation) -> untyped

    # The {#pattern_fill_scale} method returns the pattern fill scale, or +nil+
    # if the {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # scale = style.pattern_fill_scale
    # ```
    def pattern_fill_scale: () -> Float?

    # sord omit - no YARD return type given, using untyped
    # The {#pattern_fill_scale=} method sets the pattern fill scale.
    # 
    # _@param_ `scale`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.pattern_filled = true
    # style.pattern_fill_path = "C:/path/to/pattern.png"
    # style.pattern_fill_scale = 2.0
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def pattern_fill_scale=: (Float scale) -> untyped

    # The {#pattern_filled} method returns whether the {Layout::Style} has a
    # pattern fill, or +nil+ if the {Layout::Style} does not have a value for that
    # setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # is_filled = style.pattern_filled
    # ```
    def pattern_filled: () -> bool?

    # sord omit - no YARD return type given, using untyped
    # The {#pattern_filled=} method sets whether the {Layout::Style} has a pattern
    # fill.
    # 
    # _@param_ `filled`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.pattern_filled = true
    # style.pattern_fill_path = "C:/path/to/pattern.png"
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def pattern_filled=: (bool filled) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#set_dimension_units} method sets the unit format and precision for
    # dimensions. Units may be for either {Layout::LinearDimension}s or
    # {Layout::AngularDimension}s, but not both.
    # 
    # The units can be one of the following values:
    # [+Layout::Style::FRACTIONAL_INCHES+]
    # [+Layout::Style::ARCHITECTURAL_INCHES+]
    # [+Layout::Style::ENGINEERING_FEET+]
    # [+Layout::Style::DECIMAL_INCHES+]
    # [+Layout::Style::DECIMAL_FEET+]
    # [+Layout::Style::DECIMAL_MILLIMETERS+]
    # [+Layout::Style::DECIMAL_CENTIMETERS+]
    # [+Layout::Style::DECIMAL_METERS+]
    # [+Layout::Style::DECIMAL_POINTS+]
    # [+Layout::Style::DEGREES+]
    # [+Layout::Style::RADIANS+]
    # 
    # _@param_ `units`
    # 
    # _@param_ `precision`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # precision = 0.0001
    # units = Layout::Style::DECIMAL_MILLIMETERS
    # style.set_dimension_units(units, precision)
    # ```
    def set_dimension_units: (Integer units, Float precision) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#set_sub_style} method adds a {Layout::Style} to apply to a
    # {Layout::Entity}'s sub-entity. This would be used to set the arrow type for
    # extension lines of a {Layout::LinearDimension}, for example.
    # 
    # _@param_ `type`
    # 
    # _@param_ `sub_style`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # sub_style = style.get_sub_style(Layout::Style::DIMENSION_TEXT)
    # sub_style.dimension_vertical_alignment = Layout::Style::DIMENSION_TEXT_BELOW
    # style.set_sub_style(Layout::Style::DIMENSION_TEXT, sub_style)
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def set_sub_style: (Integer _type, Layout::Style sub_style) -> untyped

    # The {#solid_filled} method returns whether the {Layout::Style} has a solid
    # fill, or +nil+ if the {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # is_filled = style.solid_filled
    # ```
    def solid_filled: () -> bool?

    # sord omit - no YARD return type given, using untyped
    # The {#solid_filled=} method sets whether the {Layout::Style} has a solid fill.
    # 
    # _@param_ `filled`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.solid_filled = true
    # style.fill_color = Sketchup::Color.new(0, 255, 0, 255)
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def solid_filled=: (bool filled) -> untyped

    # The {#start_arrow_size} method returns the size of the start arrow, or +nil+
    # if the {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # arrow_size = style.start_arrow_size
    # ```
    def start_arrow_size: () -> Float?

    # sord omit - no YARD return type given, using untyped
    # The {#start_arrow_size=} method sets the size of the start arrow. The minimum
    # size is 0.25.
    # 
    # _@param_ `arrow_size`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.start_arrow_size = 2.0
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def start_arrow_size=: (Float arrow_size) -> untyped

    # The {#start_arrow_type} method returns the type of start arrow, or +nil+ if
    # the {Layout::Style} does not have a value for that setting.
    # 
    # The arrow type can be one of the following values:
    # [+Layout::Style::ARROW_NONE+]
    # [+Layout::Style::ARROW_FILLED_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_TRIANGLE+]
    # [+Layout::Style::ARROW_FILLED_SKINNY_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_SKINNY_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_ARROW_90+]
    # [+Layout::Style::ARROW_OPEN_ARROW_120+]
    # [+Layout::Style::ARROW_FILLED_CIRCLE+]
    # [+Layout::Style::ARROW_OPEN_CIRCLE+]
    # [+Layout::Style::ARROW_FILLED_SQUARE+]
    # [+Layout::Style::ARROW_OPEN_SQUARE+]
    # [+Layout::Style::ARROW_FILLED_DIAMOND+]
    # [+Layout::Style::ARROW_OPEN_DIAMOND+]
    # [+Layout::Style::ARROW_STAR+]
    # [+Layout::Style::ARROW_T+]
    # [+Layout::Style::ARROW_SLASH_RIGHT+]
    # [+Layout::Style::ARROW_SLASH_LEFT+]
    # [+Layout::Style::ARROW_UNDERRUN+]
    # [+Layout::Style::ARROW_OVERRUN+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # arrow_type = style.start_arrow_type
    # ```
    def start_arrow_type: () -> Integer?

    # sord omit - no YARD return type given, using untyped
    # The {#start_arrow_type=} method sets the type of start arrow.
    # 
    # The arrow type can be one of the following values:
    # [+Layout::Style::ARROW_NONE+]
    # [+Layout::Style::ARROW_FILLED_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_TRIANGLE+]
    # [+Layout::Style::ARROW_FILLED_SKINNY_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_SKINNY_TRIANGLE+]
    # [+Layout::Style::ARROW_OPEN_ARROW_90+]
    # [+Layout::Style::ARROW_OPEN_ARROW_120+]
    # [+Layout::Style::ARROW_FILLED_CIRCLE+]
    # [+Layout::Style::ARROW_OPEN_CIRCLE+]
    # [+Layout::Style::ARROW_FILLED_SQUARE+]
    # [+Layout::Style::ARROW_OPEN_SQUARE+]
    # [+Layout::Style::ARROW_FILLED_DIAMOND+]
    # [+Layout::Style::ARROW_OPEN_DIAMOND+]
    # [+Layout::Style::ARROW_STAR+]
    # [+Layout::Style::ARROW_T+]
    # [+Layout::Style::ARROW_SLASH_RIGHT+]
    # [+Layout::Style::ARROW_SLASH_LEFT+]
    # [+Layout::Style::ARROW_UNDERRUN+]
    # [+Layout::Style::ARROW_OVERRUN+]
    # 
    # _@param_ `arrow_type`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.start_arrow_type = Layout::Style::ARROW_SLASH_RIGHT
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def start_arrow_type=: (Integer arrow_type) -> untyped

    # The {#stroke_cap_style} method returns the stroke cap style, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # The cap style can be one of the following:
    # [+Layout::Style::CAP_STYLE_FLAT+]
    # [+Layout::Style::CAP_STYLE_ROUND+]
    # [+Layout::Style::CAP_STYLE_SQUARE+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # cap_style = style.stroke_cap_style
    # ```
    def stroke_cap_style: () -> Integer?

    # sord omit - no YARD return type given, using untyped
    # The {#stroke_cap_style=} method sets the stroke cap style.
    # 
    # The cap style can be one of the following:
    # [+Layout::Style::CAP_STYLE_FLAT+]
    # [+Layout::Style::CAP_STYLE_ROUND+]
    # [+Layout::Style::CAP_STYLE_SQUARE+]
    # 
    # _@param_ `cap_style`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.stroke_cap_style = Layout::Style::CAP_STYLE_SQUARE
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def stroke_cap_style=: (Integer cap_style) -> untyped

    # The {#stroke_color} method returns the stroke color, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # color = style.stroke_color
    # ```
    def stroke_color: () -> Sketchup::Color?

    # sord omit - no YARD return type given, using untyped
    # The {#stroke_color=} method sets the stroke color.
    # 
    # _@param_ `stroke_color`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.stroke_color = Sketchup::Color.new(128, 128, 128, 255)
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def stroke_color=: (Sketchup::Color stroke_color) -> untyped

    # The {#stroke_join_style} method returns the stroke join style, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # The join style can be one of the following:
    # [+Layout::Style::JOIN_STYLE_MITER+]
    # [+Layout::Style::JOIN_STYLE_ROUND+]
    # [+Layout::Style::JOIN_STYLE_BEVEL+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # join_style = style.stroke_join_style
    # ```
    def stroke_join_style: () -> Integer?

    # sord omit - no YARD return type given, using untyped
    # The {#stroke_join_style=} method sets the stroke join style.
    # 
    # The join style can be one of the following:
    # [+Layout::Style::JOIN_STYLE_MITER+]
    # [+Layout::Style::JOIN_STYLE_ROUND+]
    # [+Layout::Style::JOIN_STYLE_BEVEL+]
    # 
    # _@param_ `join_style`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.stroke_join_style = Layout::Style::JOIN_STYLE_BEVEL
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def stroke_join_style=: (Integer join_style) -> untyped

    # The {#stroke_pattern} method returns the stroke pattern, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # The stroke pattern can be one of the following:
    # [+Layout::Style::STROKE_PATTERN_SOLID+]
    # [+Layout::Style::STROKE_PATTERN_DASH+]
    # [+Layout::Style::STROKE_PATTERN_DOT+]
    # [+Layout::Style::STROKE_PATTERN_DASH_DOT+]
    # [+Layout::Style::STROKE_PATTERN_DASH_DOT_DOT+]
    # [+Layout::Style::STROKE_PATTERN_DASH_SPACE+]
    # [+Layout::Style::STROKE_PATTERN_DASH_DOT_DOT_DOT+]
    # [+Layout::Style::STROKE_PATTERN_DASH_DASH_DOT+]
    # [+Layout::Style::STROKE_PATTERN_DASH_DASH_DOT_DOT+]
    # [+Layout::Style::STROKE_PATTERN_DASH_DASH_DOT_DOT_DOT+]
    # [+Layout::Style::STROKE_PATTERN_CENTER+]
    # [+Layout::Style::STROKE_PATTERN_PHANTOM+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # pattern = style.stroke_pattern
    # ```
    def stroke_pattern: () -> Integer?

    # sord omit - no YARD return type given, using untyped
    # The {#stroke_pattern=} method sets the stroke pattern.
    # 
    # The stroke pattern can be one of the following:
    # [+Layout::Style::STROKE_PATTERN_SOLID+]
    # [+Layout::Style::STROKE_PATTERN_DASH+]
    # [+Layout::Style::STROKE_PATTERN_DOT+]
    # [+Layout::Style::STROKE_PATTERN_DASH_DOT+]
    # [+Layout::Style::STROKE_PATTERN_DASH_DOT_DOT+]
    # [+Layout::Style::STROKE_PATTERN_DASH_SPACE+]
    # [+Layout::Style::STROKE_PATTERN_DASH_DOT_DOT_DOT+]
    # [+Layout::Style::STROKE_PATTERN_DASH_DASH_DOT+]
    # [+Layout::Style::STROKE_PATTERN_DASH_DASH_DOT_DOT+]
    # [+Layout::Style::STROKE_PATTERN_DASH_DASH_DOT_DOT_DOT+]
    # [+Layout::Style::STROKE_PATTERN_CENTER+]
    # [+Layout::Style::STROKE_PATTERN_PHANTOM+]
    # 
    # _@param_ `pattern`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.stroke_pattern = Layout::Style::CAP_STYLE_SQUARE
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def stroke_pattern=: (Integer pattern) -> untyped

    # The {#stroke_pattern_scale} method returns the stroke pattern scale, or +nil+
    # if the {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # pattern_scale = style.stroke_pattern_scale
    # ```
    def stroke_pattern_scale: () -> Float?

    # sord omit - no YARD return type given, using untyped
    # The {#stroke_pattern_scale=} method sets the stroke pattern scale.
    # 
    # _@param_ `scale`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.stroke_pattern_scale = 2.0
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def stroke_pattern_scale=: (Float scale) -> untyped

    # The {#stroke_width} method returns the stroke width, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # stroke_width = style.stroke_width
    # ```
    def stroke_width: () -> Float?

    # sord omit - no YARD return type given, using untyped
    # The {#stroke_width=} method sets the stroke width.
    # 
    # _@param_ `stroke_width`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.stroke_width = 2.0
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def stroke_width=: (Float stroke_width) -> untyped

    # The {#stroked} method returns whether the {Layout::Style} has a stroke, or
    # +nil+ if the {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # has_stroke = style.stroked
    # ```
    def stroked: () -> bool?

    # sord omit - no YARD return type given, using untyped
    # The {#stroked=} method sets whether the {Layout::Style} has a stroke.
    # 
    # _@param_ `stroked`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.stroked = true
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def stroked=: (bool stroked) -> untyped

    # The {#suppress_dimension_units} method returns whether the units for
    # dimensions are suppressed, or +nil+ if the {Layout::Style} does not have a
    # value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # suppressed = style.suppress_dimension_units
    # ```
    def suppress_dimension_units: () -> bool?

    # sord omit - no YARD return type given, using untyped
    # The {#suppress_dimension_units=} method sets whether the units for
    # dimensions are suppressed.
    # 
    # _@param_ `suppress`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.suppress_dimension_units = true
    # ```
    def suppress_dimension_units=: (bool suppress) -> untyped

    # The {#text_alignment} method returns the text alignment, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # The alignment type can be one of the following values:
    # [+Layout::Style::ALIGN_LEFT+]
    # [+Layout::Style::ALIGN_RIGHT+]
    # [+Layout::Style::ALIGN_CENTER+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # alignment = style.text_alignment
    # ```
    def text_alignment: () -> Integer?

    # sord omit - no YARD return type given, using untyped
    # The {#text_alignment=} method sets the text alignment.
    # 
    # The alignment type can be one of the following values:
    # [+Layout::Style::ALIGN_LEFT+]
    # [+Layout::Style::ALIGN_RIGHT+]
    # [+Layout::Style::ALIGN_CENTER+]
    # 
    # _@param_ `alignment_type`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.text_alignment = Layout::Style::ALIGN_CENTER
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def text_alignment=: (Integer alignment_type) -> untyped

    # The {#text_anchor} method returns the text anchor type, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # The anchor type can be one of the following values:
    # [+Layout::Style::ANCHOR_TOP+]
    # [+Layout::Style::ANCHOR_CENTER+]
    # [+Layout::Style::ANCHOR_BOTTOM+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # anchor_type = style.text_anchor
    # ```
    def text_anchor: () -> Integer?

    # sord omit - no YARD return type given, using untyped
    # The {#text_anchor=} method sets the text anchor type.
    # 
    # The anchor type can be one of the following values:
    # [+Layout::Style::ANCHOR_TOP+]
    # [+Layout::Style::ANCHOR_CENTER+]
    # [+Layout::Style::ANCHOR_BOTTOM+]
    # 
    # _@param_ `anchor_type`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.text_anchor = Layout::Style::ANCHOR_BOTTOM
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def text_anchor=: (Integer anchor_type) -> untyped

    # The {#text_bold} method returns whether text is bold, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # bold = style.text_bold
    # ```
    def text_bold: () -> bool?

    # sord omit - no YARD return type given, using untyped
    # The {#text_bold=} method sets whether text is bold.
    # 
    # _@param_ `bold`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.text_bold = true
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def text_bold=: (bool bold) -> untyped

    # The {#text_color} method returns the text color, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # color = style.text_color
    # ```
    def text_color: () -> Sketchup::Color?

    # sord omit - no YARD return type given, using untyped
    # The {#text_color=} method sets the text color.
    # 
    # _@param_ `color`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.text_color = Sketchup::Color.new(255, 0, 0, 255)
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def text_color=: (Sketchup::Color color) -> untyped

    # The {#text_elevation} method returns the text elevation, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # The elevation type can be one of the following values:
    # [+Layout::Style::NORMAL_SCRIPT+]
    # [+Layout::Style::SUPER_SCRIPT+]
    # [+Layout::Style::SUB_SCRIPT+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # elevation = style.text_elevation
    # ```
    def text_elevation: () -> Integer?

    # sord omit - no YARD return type given, using untyped
    # The {#text_elevation=} method sets the text elevation.
    # 
    # The elevation type can be one of the following values:
    # [+Layout::Style::NORMAL_SCRIPT+]
    # [+Layout::Style::SUPER_SCRIPT+]
    # [+Layout::Style::SUB_SCRIPT+]
    # 
    # _@param_ `elevation_type`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.text_elevation = Layout::Style::SUB_SCRIPT
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def text_elevation=: (Integer elevation_type) -> untyped

    # The {#text_italic} method returns whether text is italic, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # italic = style.text_italic
    # ```
    def text_italic: () -> bool?

    # sord omit - no YARD return type given, using untyped
    # The {#text_italic=} method sets whether text is italic.
    # 
    # _@param_ `italic`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.text_italic = true
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def text_italic=: (bool italic) -> untyped

    # The {#text_underline} method returns the text underline type, or +nil+ if the
    # {Layout::Style} does not have a value for that setting.
    # 
    # The underline type can be one of the following values:
    # [+Layout::Style::UNDERLINE_NONE+]
    # [+Layout::Style::UNDERLINE_SINGLE+]
    # [+Layout::Style::UNDERLINE_DOUBLE+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # underline_type = style.text_underline
    # ```
    def text_underline: () -> Integer?

    # sord omit - no YARD return type given, using untyped
    # The {#text_underline=} method sets the text underline type.
    # 
    # The underline type can be one of the following values:
    # [+Layout::Style::UNDERLINE_NONE+]
    # [+Layout::Style::UNDERLINE_SINGLE+]
    # [+Layout::Style::UNDERLINE_DOUBLE+]
    # 
    # _@param_ `underline_type`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page = doc.pages.first
    # entity = page.entities.first
    # style = entity.style
    # style.text_underline = Layout::Style::UNDERLINE_DOUBLE
    # # Set the style to apply changes
    # entity.style = style
    # ```
    def text_underline=: (Integer underline_type) -> untyped
  end

  # A {Layout::Table} is a series of rows and columns that holds data.
  # 
  # @example
  #   bounds = Geom::Bounds2d.new(1, 1, 4, 4)
  #   rows = 4
  #   columns = 4
  #   table = Layout::Table.new(bounds, rows, columns)
  #   doc = Layout::Document.open("C:/path/to/document.layout")
  #   doc.add_entity(table, doc.layers.first, doc.pages.first)
  #   anchor_type = Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT
  #   start_point = Geom::Point2d.new(1, 1)
  #   text = Layout::FormattedText.new("Hello LayOut", start_point, anchor_type)
  #   table[1, 1].data = text
  # 
  # @version LayOut 2018
  class Table < Layout::Entity
    include Enumerable[TableCell]

    # The {#[]} method returns the {Layout::TableCell} at the specified row and
    # column.
    # 
    # _@param_ `row_index`
    # 
    # _@param_ `column_index`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # cell = table[1, 2]
    # ```
    def []: (Integer row_index, Integer column_index) -> Layout::TableCell

    # The {#dimensions} method returns the number of rows and columns in a
    # {Layout::Table}.
    # 
    # _@return_ — The first value is the number of rows; the
    # second, the number of columns.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # r, c = table.dimensions
    # ```
    def dimensions: () -> [Integer, Integer]

    # sord omit - no YARD return type given, using untyped
    # The {#each} method iterates in column major order through all of the cells
    # in the {Layout::Table}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # table.each { |cell|
    #   puts cell.data.plain_text
    # }
    # ```
    def each: () ?{ (Layout::TableCell cell) -> void } -> untyped

    # The {#entities} method creates and returns the {Layout::Entities} that
    # represent the {Layout::Table} in its exploded form.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # entities = table.entities
    # ```
    def entities: () -> Layout::Entities

    # The {#get_column} method returns the {Layout::TableColumn} at the specified
    # index.
    # 
    # _@param_ `index`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # table_column = table.get_column(2)
    # ```
    def get_column: (Integer index) -> Layout::TableColumn

    # The {#get_row} method returns the {Layout::TableRow} at the specified index.
    # 
    # _@param_ `index`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # table_row = table.get_row(2)
    # ```
    def get_row: (Integer index) -> Layout::TableRow

    # The {#initialize} method creates a {Layout::Table} with a specified size, and
    # a specified number of rows and columns.
    # 
    # _@param_ `bounds`
    # 
    # _@param_ `rows`
    # 
    # _@param_ `columns`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # ```
    def initialize: (Geom::Bounds2d bounds, Integer rows, Integer columns) -> void

    # sord omit - no YARD return type given, using untyped
    # The {#insert_column} method inserts a new column at the specified index.
    # 
    # _@param_ `index`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # table.insert_column(2)
    # ```
    def insert_column: (Integer index) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#insert_row} method inserts a new row at the specified index.
    # 
    # _@param_ `index`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # table.insert_row(2)
    # ```
    def insert_row: (Integer index) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#merge} method merges a range of cells within a {Layout::Table}. Only
    # cells which are not already merged can be merged.
    # 
    # _@param_ `start_row`
    # 
    # _@param_ `start_column`
    # 
    # _@param_ `end_row`
    # 
    # _@param_ `end_column`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # table.merge(1, 1, 2, 2)
    # ```
    def merge: (
                 Integer start_row,
                 Integer start_column,
                 Integer end_row,
                 Integer end_column
               ) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#remove_column} method removes the column at the specified index.
    # 
    # _@param_ `index`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # table.remove_column(2)
    # ```
    def remove_column: (Integer index) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#remove_row} method removes the row at the specified index.
    # 
    # _@param_ `index`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # table.remove_row(2)
    # ```
    def remove_row: (Integer index) -> untyped
  end

  # An entity is an object shown on a page of a LayOut document.
  # 
  # @example
  #   doc = Layout::Document.open("C:/path/to/document.layout")
  #   # Get the shared entities in the document. If there are no shared layers,
  #   # the resulting array will be empty.
  #   entities = doc.shared_entities
  # 
  #   # Count how many of the shared entites are rectangles.
  #   rectangle_count = entities.grep(Layout::Rectangle).size
  # 
  # @version LayOut 2018
  class Entity
    # The {#==} method checks to see if the two {Layout::Entity}s are equal. This
    # checks whether the Ruby Objects are pointing to the same internal object.
    # 
    # _@param_ `other`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page_entities = doc.pages.first.entities
    # layer_entities = doc.layers.first.layer_instance(page).entities
    # page_entities.first == layer_entities.first
    # ```
    def ==: (Layout::Entity other) -> bool

    # The {#bounds} method returns the 2D rectangular bounds of the {Layout::Entity}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.pages.first.entities
    # bounds = entities.first.bounds
    # ```
    def bounds: () -> Geom::Bounds2d

    # The {#document} method returns the {Layout::Document} that the
    # {Layout::Entity} belongs to, or +nil+ if it is not in a {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.shared_entities
    # # entity_doc should be the same document as doc
    # entity_doc = entities.first.document
    # ```
    def document: () -> Layout::Document?

    # The {#drawing_bounds} method returns the 2D rectangular drawing bounds of the
    # {Layout::Entity}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.pages.first.entities
    # draw_bounds = entities.first.drawing_bounds
    # ```
    def drawing_bounds: () -> Geom::OrientedBounds2d

    # The {#group} method returns the {Layout::Group} the {Layout::Entity} belongs
    # to, or +nil+ if it is not in a {Layout::Group}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # pages = doc.pages
    # entities = pages.first.entities
    # group = entities.first.group
    # ```
    def group: () -> Layout::Group?

    # The {#layer_instance} method returns the {Layout::LayerInstance} that the
    # {Layout::Entity} is on, or +nil+ if it is not associated with a
    # {Layout::LayerInstance}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.pages.first.entities
    # entity_layer_instance = entities.first.layer_instance
    # ```
    # 
    # _@note_ — {Layout::Group}s are never associated with a {Layout::LayerInstance}.
    def layer_instance: () -> Layout::LayerInstance?

    # sord omit - no YARD return type given, using untyped
    # The {#locked=} method sets the {Layout::Entity} as locked or unlocked. When
    # locked, the {Layout::Entity} cannot be modified directly.
    # 
    # _@param_ `is_locked`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.pages.first.entities
    # entities.first.locked = true
    # ```
    def locked=: (bool is_locked) -> untyped

    # The {#locked?} method returns whether the {Layout::Entity} is locked or
    # unlocked.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.pages.first.entities
    # is_first_locked = entities.first.locked?
    # ```
    def locked?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#move_to_group} method moves the {Layout::Entity} into a {Layout::Group}.
    # If the {Layout::Entity} is already in a {Layout::Group}, it will be removed
    # from that {Layout::Group} prior to being added to the new one. If this action
    # results in the old {Layout::Group} containing only one {Layout::Entity}, the
    # old {Layout::Group} will be collapsed and the remaining {Layout::Entity} will
    # be moved to the old {Layout::Group}'s parent.
    # 
    # _@param_ `group`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.pages.first.entities
    # new_group = Layout::Group.new
    # entities.first.move_to_group(new_group)
    # ```
    def move_to_group: (Layout::Group group) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#move_to_layer} method moves the {Layout::Entity} to the given
    # {Layout::Layer}. If the {Layout::Layer} is non-shared and the
    # {Layout::Entity} is currently on a shared {Layout::Layer}, an array of
    # {Layout::Page}s must be provided to move the {Layout::Entity} to. In all other
    # cases, passing in an array of {Layout::Page}s is not necessary. The
    # {Layout::Entity} must belong to the same {Layout::Document} as the the
    # {Layout::Layer} and the {Layout::Page}s.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.pages.first.entities
    # layers = doc.layers
    # entities.last.move_to_layer(layers.first)
    # ```
    def move_to_layer: (*untyped args) -> untyped

    # The {#on_shared_layer?} method returns whether or not the {Layout::Entity} is
    # on a shared {Layout::Layer}. This function works for all {Layout::Entity}
    # types, including {Layout::Group}. {Layout::Group}s do not belong to a
    # specific {Layout::Layer}, but their children are all on either a shared
    # or non-shared {Layout::Layer}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.pages.first.entities
    # on_shared_layer = entities.first.on_shared_layer?
    # ```
    def on_shared_layer?: () -> bool

    # The {#page} method returns the {Layout::Page} that the {Layout::Entity}
    # belongs to, or +nil+ if it is on a shared {Layout::Layer} or not in a
    # {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # # page will be nil
    # page = doc.shared_entities.first.page
    # # page will be the first page of the document
    # page = doc.pages.first.nonshared_entities.first.page
    # ```
    def page: () -> Layout::Page?

    # The {#style} method returns the {Layout::Style} of the {Layout::Entity}. If
    # the {Layout::Entity} is a {Layout::Group}, +nil+ will be returned, as they
    # do not have a {Layout::Style}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.entities
    # style = entities.first.style
    # ```
    def style: () -> Layout::Style?

    # sord omit - no YARD return type given, using untyped
    # The {#style=} method sets the {Layout::Style} of the {Layout::Entity}.
    # 
    # _@param_ `style`
    def style=: (Layout::Style style) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#transform!} method transforms the {Layout::Entity} with a given
    # {Geom::Transformation2d}.
    # 
    # _@param_ `transformation`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.pages.first.entities
    # transform = Geom::Transformation2d.new([1.0, 0.0, 0.0, 1.0, 1.0, 1.0])
    # entity = entities.first.transform!(transform)
    # ```
    def transform!: (Geom::Transformation2d transformation) -> untyped

    # The {#transformation} method returns the explicit {Geom::Transformation2d}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.pages.first.entities
    # transform = entities.first.transformation
    # ```
    def transformation: () -> Geom::Transformation2d?

    # The {#untransformed_bounds} method returns the untransformed bounds of the
    # {Layout::Entity}. This is the bounds of the {Layout::Entity} before its
    # explicit {Geom::Transformation2d} is applied.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.pages.first.entities
    # bounds = entities.first.untransformed_bounds
    # ```
    def untransformed_bounds: () -> Geom::Bounds2d

    # sord omit - no YARD return type given, using untyped
    # The {#untransformed_bounds=} method sets the untransformed bounds of the
    # {Layout::Entity}. This is the bounds of the {Layout::Entity} before its
    # explicit {Geom::Transformation2d} is applied.
    # 
    # _@param_ `bounds`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.pages.first.entities
    # point1 = Geom::Point2d.new(1, 1)
    # point2 = Geom::Point2d.new(2, 2)
    # bounds = Geom::Bounds2d(point1, point2)
    # entities.first.untransformed_bounds = bounds
    # ```
    def untransformed_bounds=: (Geom::Bounds2d bounds) -> untyped
  end

  # The Layers class is a container class for all layers in a {Layout::Document}.
  # 
  # @example
  #   # Grab a handle to the currently active document's layers
  #   doc = Layout::Document.open("C:/path/to/document.layout")
  #   layers = doc.layers
  # 
  #   # From here, we can add layers to or remove them from the document
  #   layers.add("New Layer")
  #   layers.remove(layers[0])
  # 
  # @version LayOut 2018
  class Layers
    include Enumerable[Layout::Layer]

    # The {#[]} method returns a value from the array of {Layout::Layer}s.
    # 
    # _@param_ `index` — The index of the {Layout::Layer} to return.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # layer = layers[2]
    # ```
    def []: (Integer index) -> Layout::Layer

    # The {#active} method returns the active {Layout::Layer} in the
    # {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layer = doc.layers.active
    # ```
    def active: () -> Layout::Layer

    # sord infer - inferred type of parameter "layer" as Layout::Layer using getter's return type
    # sord omit - no YARD return type given, using untyped
    # The {#active=} method sets the active {Layout::Layer} that will be
    # displayed the next time the {Layout::Document} is opened. This value will
    # change whenever the {Layout::Layer} is changed in the {Layout::Document} in
    # LayOut.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # layers.active = layers[0]
    # ```
    def active=: (Layout::Layer layer) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#add} method adds a new {Layout::Layer} to the {Layout::Document}.
    # The newly added {Layout::Layer} will be the last one in the
    # {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # new_layer = doc.layers.add
    # ```
    def add: (*untyped args) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#each} method iterates through all of the {Layout::Layer}s.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # layers.each { |layer|
    #   puts layer.name
    # }
    # ```
    # 
    # _@note_ — Don't remove content from this collection while iterating over it with
    # {#each}. This would change the size of the collection and cause elements to
    # be skipped as the indices change. Instead copy the current collection to an
    # array using +to_a+ and then use +each+ on the array, when removing content.
    def each: () ?{ (Layout::Layer layer) -> void } -> untyped

    # The {#index} method returns the index of the {Layout::Layer}, or +nil+ if
    # it doesn't exist in the {Layout::Document}.
    # 
    # _@param_ `layer`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # layer_index = layers.index(layers.first) # Returns 0
    # ```
    def index: (Layout::Layer layer) -> Integer?

    # The {#length} method returns the number of {Layout::Layer}s.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # num_layers = layers.length
    # ```
    def length: () -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#remove} method deletes the given {Layout::Layer} from the
    # {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # layers.remove(layers[0])
    # ```
    def remove: (*untyped args) -> untyped

    # sord omit - no YARD type given for "layer", using untyped
    # sord omit - no YARD type given for "new_index", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#reorder} method moves a {Layout::Layer} to a different index
    # within the {Layout::Document}'s list of layers. This will move the
    # {Layout::Layer} such that its new index becomes new_index.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # layers.reorder(layers[1], 3)
    # ```
    def reorder: (untyped layer, untyped new_index) -> untyped
  end

  # A simple elliptical shape entity.
  # 
  # @version LayOut 2018
  class Ellipse < Layout::Entity
    # The {#initialize} method creates a new {Layout::Ellipse}.
    # 
    # _@param_ `bounds`
    # 
    # ```ruby
    # upper_left = Geom::Point2d.new(1, 1)
    # lower_right = Geom::Point2d.new(2, 2)
    # bounds = Geom::Bounds2d.new(upper_left, lower_right)
    # ellipse = Layout::Ellipse.new(bounds)
    # ```
    def initialize: (Geom::Bounds2d bounds) -> void
  end

  # This is the interface to a LayOut document. A {Layout::Document} is the 2D
  # drawing that the user is working with, and it serves as the "entry point" for
  # most Ruby API interactions. The {Layout::Document.open} method gives you a
  # handle to a {Layout::Document}, and from there you can use the
  # document-level methods to start getting information and making changes.
  # 
  # @example
  #   # Grab a handle to an existing LayOut document.
  #   doc = Layout::Document.open("C:/path/to/document.layout")
  # 
  #   # Grab other handles to commonly used collections inside the model.
  #   layers = doc.layers
  #   pages = doc.pages
  #   entities = doc.shared_entities
  # 
  #   # Now that we have our handles, we can start pulling objects and making
  #   # method calls that are useful.
  #   first_entity = entities[0]
  # 
  #   number_pages = pages.count
  # 
  # @version LayOut 2018
  class Document
    DECIMAL_CENTIMETERS: untyped
    DECIMAL_FEET: untyped
    DECIMAL_INCHES: untyped
    DECIMAL_METERS: untyped
    DECIMAL_MILLIMETERS: untyped
    DECIMAL_POINTS: untyped
    FRACTIONAL_INCHES: untyped
    VERSION_1: untyped
    VERSION_2: untyped
    VERSION_2013: untyped
    VERSION_2014: untyped
    VERSION_2015: untyped
    VERSION_2016: untyped
    VERSION_2017: untyped
    VERSION_2018: untyped
    VERSION_2019: untyped
    VERSION_2020: untyped
    VERSION_2021: untyped
    VERSION_2022: untyped
    VERSION_3: untyped
    VERSION_CURRENT: untyped

    # The {.open} method creates a new {Layout::Document} by loading an existing
    # .layout file.
    # 
    # _@param_ `path` — The path to the .layout file on disk.
    # 
    # _@return_ — The {Layout::Document} created from the .layout
    # file.
    # 
    # ```ruby
    # filename = File.join(ENV['Home'], 'Desktop', 'template.layout')
    # doc = Layout::Document.open(filename)
    # ```
    def self.open: (String path) -> Layout::Document

    # The {#==} method checks to see if the two {Layout::Document}s are equal.
    # This checks whether the Ruby Objects are pointing to the same internal
    # object.
    # 
    # _@param_ `other`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # document = doc.pages.first.document
    # doc == document
    # ```
    def ==: (Layout::Document other) -> bool

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#add_entity} method adds an {Layout::Entity} to the {Layout::Document}
    # and places it on the given {Layout::Layer} and {Layout::Page}. If layer is a
    # shared {Layout::Layer} then page may be ommitted. The {Layout::Entity} must
    # not already belong to a {Layout::Document}. If the {Layout::Entity} is a
    # {Layout::Group}, then the {Layout::Group} along with all of its children will
    # be added to the {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # rect = Layout::Rectangle.new([[1, 1], [2, 2]])
    # all_layers = doc.layers
    # all_pages = doc.pages
    # doc.add_entity(rect, all_layers.first, all_pages.first)
    # ```
    def add_entity: (*untyped args) -> untyped

    # The {#auto_text_definitions} method returns an array of
    # {Layout::AutoTextDefinition}'s in the {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # defs = doc.auto_text_definitions
    # ```
    def auto_text_definitions: () -> Layout::AutoTextDefinitions

    # sord omit - no YARD return type given, using untyped
    # The {#export} method exports the {Layout::Document} to a given file format.
    # It knows which format to export based on the file extension you place on the
    # file name. For example, a filename of "thing.pdf" will export a PDF file,
    # whereas "thing.png" will export a set of PNG images.
    # 
    # For LayOut version 2020.1, valid extensions include .pdf, .jpg, and .png.
    # 
    # _@param_ `file_path` — The file or image set to create. The directory path must already exist. The path must include the file extension.
    # 
    # _@param_ `options` — An optional hash of settings for the export.
    # 
    # PDF Export Examples
    # ```ruby
    # doc = Layout::Document.open("c:/path/to/document.layout")
    # 
    # # Export pdf file on a PC, with default settings.
    # status = doc.export("c:/my_export.pdf")
    # 
    # # Export pages one through three at high quality, compressing jpeg images
    # # at 0.75 compression quality (valid range is 0.0 - 1.0). Note that the
    # # first page of a {Layout::Document} is index 0.
    # options = { start_page: 1,
    #             end_page: 3,
    #             output_resolution: Layout::PageInfo::RESOLUTION_HIGH,
    #             compress_images: TRUE,
    #             compress_quality: 0.75 }
    # 
    # status = doc.export("c:/my_export.pdf", options)
    # ```
    # 
    # Image Set Export Examples
    # ```ruby
    # doc = Layout::Document.open("c:/path/to/document.layout")
    # 
    # # Export png files on macOS, with default settings.
    # status = doc.export('/Users/username/Desktop/pngs/page.png')
    # 
    # # Export pages one through three at 300 dpi as JPGs.
    # options = { start_page: 1,
    #             end_page: 3,
    #             dpi: 300 }
    # status = doc.export('c:/page.jpg', options)
    # ```
    def export: (String file_path, ?::Hash[untyped, untyped]? options) -> untyped

    # The {#grid} method returns the {Layout::Grid} for a {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # grid = doc.grid
    # ```
    def grid: () -> Layout::Grid

    # sord omit - no YARD return type given, using untyped
    # The {#grid_snap_enabled=} method sets whether or not grid snap is enabled in
    # the {Layout::Document}.
    # 
    # _@param_ `enabled` — +true+ for enabled +false+ for disabled
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.grid_snap_enabled = true
    # ```
    def grid_snap_enabled=: (bool enabled) -> untyped

    # The {#grid_snap_enabled?} method returns whether or not grid snap is enabled
    # in the {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # enabled = doc.grid_snap_enabled?
    # ```
    def grid_snap_enabled?: () -> bool

    # sord omit - no YARD type given for "*args", using untyped
    # The {#initialize} method creates a new {Layout::Document}. Passing a path to
    # an existing {Layout::Document} will use that file as a template. The new
    # {Layout::Document} won't have a path until it is saved for the first time.
    # 
    # ```ruby
    # doc = Layout::Document.new
    # doc2 = Layout::Document.new("/path/to/template.layout")
    # ```
    def initialize: (*untyped args) -> void

    # The {#layers} method returns the {Layout::Layers} of the {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # ```
    def layers: () -> Layout::Layers

    # sord omit - no YARD return type given, using untyped
    # The {#object_snap_enabled=} method enables or disables inference in the
    # {Layout::Document}.
    # 
    # _@param_ `enabled` — +true+ for enabled +false+ for disabled
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.object_snap_enabled = false
    # ```
    def object_snap_enabled=: (bool enabled) -> untyped

    # The {#object_snap_enabled?} method returns whether or not inference is
    # enabled in the {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # enabled = doc.object_snap_enabled?
    # ```
    def object_snap_enabled?: () -> bool

    # The {#page_info} method returns a reference to the {Layout::PageInfo}
    # settings of the {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page_info = doc.page_info
    # ```
    def page_info: () -> Layout::PageInfo

    # The {#pages} method returns the {Layout::Pages} of the {Layout::Document}.
    # 
    # 
    # @example:
    #   doc = Layout::Document.open("C:/path/to/document.layout")
    #   doc_pages = doc.pages
    # 
    # _@return_ — The {Layout::Pages} for the {Layout::Document}.
    def pages: () -> Layout::Pages

    # The {#path} method returns the full path of the {Layout::Document} file. An
    # empty string is returned for a new {Layout::Document} (one which has not
    # been saved and opened).
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # path = doc.path
    # ```
    def path: () -> String

    # The {#precision} method returns the precision for the {Layout::Document}.
    # 
    # _@return_ — the number specifying the precision for the
    # {Layout::Document}
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # precision = doc.precision
    # ```
    def precision: () -> Float

    # sord omit - no YARD return type given, using untyped
    # The {#precision=} method sets the precision for the {Layout::Document}.
    # 
    # _@param_ `precision` — The double specifying the precision for the {Layout::Document}
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.precision = 0.0001
    # ```
    # 
    # _@note_ — LayOut only allows for a finite set of precision values for each units
    # setting, so it will set the precision to the closest valid setting for the
    # specified units. See the "Units" section of LayOut's "Document Setup"
    # dialog for a reference of the available precisions for each units setting.
    def precision=: (Float precision) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#remove_entity} method removes an {Layout::Entity} from the
    # {Layout::Document}. If entity is a {Layout::Group}, then the {Layout::Group}
    # and all of its children will be removed from the {Layout::Document}.
    # 
    # _@param_ `entity` — The {Layout::Entity} to be removed
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # shared_entities = doc.shared_entities
    # # Remove the first entity in the document
    # doc.remove_entity(shared_entities.first)
    # ```
    def remove_entity: (Layout::Entity entity) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#save} method saves the {Layout::Document} to a file at the given path.
    # Passing an empty path string will save the {Layout::Document} at its current
    # path.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # # Save the model using the current Layout format
    # path = File.join(ENV['Home'], 'Desktop', 'mydoc.layout')
    # status = doc.save(path)
    # # Save the document to the current file using the current LayOut format
    # status = doc.save
    # # Save the document to the current file in LayOut 3 format
    # status = doc.save(Layout::Document::VERSION_3)
    # # Save the document in LayOut 2013 format
    # path = File.join(ENV['Home'], 'Desktop', 'mydoc_v2013.layout')
    # status = doc.save(path, Layout::Document::VERSION_2013)
    # ```
    def save: (*untyped args) -> untyped

    # The {#shared_entities} method returns the {Layout::Entities}
    # that exist on shared {Layout::Layer}s in the {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.shared_entities
    # ```
    def shared_entities: () -> Layout::Entities

    # The {#time_created} method returns the time when the {Layout::Document} was
    # created.
    # 
    # _@return_ — time when the {Layout::Document} was created
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # created_time = doc.time_created
    # ```
    def time_created: () -> Time

    # The {#time_modified} method returns the last time the {Layout::Document} was
    # modified.
    # 
    # _@return_ — time when the {Layout::Document} was last modified
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # mod_time = doc.time_modified
    # ```
    def time_modified: () -> Time

    # The {#time_published} method returns the time when the {Layout::Document} was
    # published.
    # 
    # _@return_ — time when the {Layout::Document} was published
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # pub_time = doc.time_published
    # ```
    def time_published: () -> Time

    # The {#units} method returns the units for the {Layout::Document}.
    # 
    # _@return_ — The unit format of the {Layout::Document}
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # units = doc.units
    # ```
    def units: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#units=} method sets the units for the {Layout::Document}.
    # 
    # _@param_ `units_format` — The format of the units in the {Layout::Document}
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # units_format = LAYOUT::DOCUMENT::DECIMAL_MILLIMETERS
    # doc.units = units_format
    # ```
    def units=: (Integer units_format) -> untyped
  end

  # The Entities class is a container class for {Layout::Entity}s. A
  # {Layout::Entities} object is different from a SketchUp::Entities object in
  # that it is read-only. Adding or removing {Layout::Entity}s from a
  # {Layout::Document} happens with the {Layout::Document#add_entity} and
  # {Layout::Document#remove_entity} methods.
  # 
  # The {Layout::Entities} from {Layout::AngularDimension#entities},
  # {Layout::Label#entities}, {Layout::LinearDimension#entities}, or
  # {Layout::Table#entities} contains the {Layout::Entity}s that represent the
  # {Layout::Entity} in its exploded form.
  # 
  # The {Layout::Entities} from {Layout::Group#entities} contains all the
  # {Layout::Entity}s that belong to the {Layout::Group}.
  # 
  # The {Layout::Entities} from {Layout::Page#entities} contains all of the
  # {Layout::Entity}s on both shared and non-shared {Layout::Layer}s. This class
  # is used to iterate through the {Layout::Entity}s in draw order or pick order
  # (reverse draw order) using the {#each} and {#reverse_each} methods.
  # 
  # The {Layout::Entities} from {Layout::Document#shared_entities} contains all
  # of the {Layout::Entity}s that belong on all shared {Layout::Layer}s.
  # 
  # The {Layout::Entities} from {Layout::Page#nonshared_entities} contains all of
  # the {Layout::Entity}s that belong to that {Layout::Page}.
  # 
  # The {Layout::Entities} from {Layout::LayerInstance#entities} contains all of
  # the {Layout::Entity}s that belong on that {Layout::LayerInstance}.
  # 
  # @example
  #   # Grab a handle to a pages entities
  #   doc = Layout::Document.open("C:/path/to/document.layout")
  #   entities = doc.pages.first.entities
  # 
  #   # From here, we can iterate over the entities in draw order or pick order
  #   entities.each { |entity|
  #     puts entity
  #   }
  #   entities.reverse_each(skip_locked: true) { |entity|
  #     puts entity
  #   }
  # 
  # @version LayOut 2018
  class Entities
    include Enumerable[Layout::Entity]

    # The {#[]} method returns the {Layout::Entity} at the given index. This method
    # is not valid for use when the {Layout::Entities} object came from a
    # {Layout::Page}.
    # 
    # _@param_ `index`
    # 
    # ```ruby
    # table = Layout::Table.new([1, 1, 4, 4], 4, 4)
    # entities = table.entities
    # entity = entities[10]
    # ```
    def []: (Integer index) -> Layout::Entity

    # sord omit - no YARD return type given, using untyped
    # The {#each} method iterates through all of the {Layout::Entity}s. When
    # iterating over a {Layout::LayerInstance}'s {Layout::Entities}, it is not
    # necessary to provide a flags Hash. When iterating over a {Layout::Page}'s
    # {Layout::Entities}, the flags Hash is optional; providing no Hash will
    # result in iterating over all {Layout::Entity}s, including those on hidden or
    # locked {Layout::Layer}s. Valid symbols for the Hash are +:skip_hidden+ and
    # +:skip_locked+.
    # 
    # _@param_ `flags` — A hash that allows skipping of {Layout::Entity}s on hidden or locked {Layout::Layers}
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # flags = { :skip_hidden => true }
    # entities = doc.pages.first.entities
    # entities.each(flags) { |entity|
    #   puts entity
    # }
    # ```
    # 
    # _@note_ — Don't remove content from this collection while iterating over it with
    # {#each}. This would change the size of the collection and cause elements to
    # be skipped as the indices change. Instead copy the current collection to an
    # array using +to_a+ and then use +each+ on the array, when removing content.
    def each: (?::Hash[Symbol, bool] flags) ?{ (Layout::Entity entity) -> void } -> untyped

    # The {#length} method returns the number of {Layout::Entity}s.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entities = doc.shared_entities
    # num_entities = entities.length
    # ```
    def length: () -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#reverse_each} method iterates through all of the {Layout::Entity}s in
    # reverse order. When iterating over a {Layout::LayerInstance}'s
    # {Layout::Entities}, it is not necessary to provide a flags Hash. When
    # iterating over a {Layout::Page}'s {Layout::Entities}, the flags Hash is
    # optional; providing no Hash will result in iterating over all
    # {Layout::Entity}s, including those on hidden or locked {Layout::Layer}s.
    # Valid symbols for the Hash are +:skip_hidden+ and +:skip_locked+.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # flags = { :skip_hidden => true, :skip_locked => true }
    # entities = doc.pages.first.entities
    # entities.reverse_each(flags) { |entity|
    #   puts entity
    # }
    # ```
    def reverse_each: (*untyped args) -> untyped
  end

  # This is the interface to a {Layout::Document}'s paper space information. The
  # paper size and margins, display resolution, and colors can all be accessed
  # and set through this class.
  # 
  # @example
  #   doc = Layout::Document.open("C:/path/to/document.layout")
  #   page_info = doc.page_info
  #   # Get the paper height and width and set the output resolution
  #   width = page_info.width
  #   height = page_info.height
  #   page_info.output_resolution = Layout::PageInfo::RESOLUTION_HIGH
  # 
  # @version LayOut 2018
  class PageInfo
    RESOLUTION_HIGH: untyped
    RESOLUTION_LOW: untyped
    RESOLUTION_MEDIUM: untyped

    # The {bottom_margin} method returns the paper's bottom margin in document
    # units.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # bottom_margin = doc.page_info.bottom_margin
    # ```
    def bottom_margin: () -> Numeric

    # sord omit - no YARD return type given, using untyped
    # The {#bottom_margin=} method sets the paper's bottom margin in document units.
    # 
    # _@param_ `margin`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.page_info.bottom_margin = 0.40
    # ```
    def bottom_margin=: (Numeric margin) -> untyped

    # The {#color} method returns the paper's color.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # paper_color = Layout.page_info.color
    # ```
    def color: () -> Sketchup::Color

    # sord omit - no YARD return type given, using untyped
    # The {#color=} method sets the paper's color.
    # 
    # _@param_ `new_color`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.page_info.color = Sketchup::Color.new(45, 45, 75, 255)
    # ```
    def color=: (Sketchup::Color new_color) -> untyped

    # The {#display_resolution} method returns the on screen rendering resolution
    # quality.
    # 
    # The resolution can be one of the following values:
    # [+Layout::PageInfo::RESOLUTION_LOW+]
    # [+Layout::PageInfo::RESOLUTION_MEDIUM+]
    # [+Layout::PageInfo::RESOLUTION_HIGH+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # display_resolution = doc.page_info.display_resolution
    # ```
    def display_resolution: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#display_resolution=} method sets the on screen rendering resolution
    # quality.
    # 
    # The resolution can be one of the following values:
    # [+Layout::PageInfo::RESOLUTION_LOW+]
    # [+Layout::PageInfo::RESOLUTION_MEDIUM+]
    # [+Layout::PageInfo::RESOLUTION_HIGH+]
    # 
    # _@param_ `resolution`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.page_info.display_resolution = Layout::PageInfo::RESOLUTION_MEDIUM
    # ```
    def display_resolution=: (Integer resolution) -> untyped

    # The {#height} method returns the paper height in document units.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # height = doc.page_info.height
    # ```
    def height: () -> Numeric

    # sord omit - no YARD return type given, using untyped
    # The {#height=} method sets the paper height in document units.
    # 
    # _@param_ `height`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.page_info.height = 8.5
    # ```
    def height=: (Numeric height) -> untyped

    # The {#left_margin} method returns the paper's left margin in document units.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # left_margin = doc.page_info.left_margin
    # ```
    def left_margin: () -> Numeric

    # sord omit - no YARD return type given, using untyped
    # The {#left_margin=} method sets the paper's left margin in document units.
    # 
    # _@param_ `margin`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.page_info.left_margin = 0.40
    # ```
    def left_margin=: (Numeric margin) -> untyped

    # The {#margin_color} method returns the color of the paper's margin.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # margin_color = doc.page_info.margin_color
    # ```
    def margin_color: () -> Sketchup::Color

    # sord omit - no YARD return type given, using untyped
    # The {#margin_color=} sets the color of paper's margin.
    # 
    # _@param_ `color`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # new_color = Sketchup::Color("Red")
    # doc.page_info.margin_color = new_color
    # ```
    def margin_color=: (Sketchup::Color color) -> untyped

    # The {#output_resolution} method returns the output rendering resolution
    # quality.
    # 
    # The resolution can be one of the following values:
    # [+Layout::PageInfo::RESOLUTION_LOW+]
    # [+Layout::PageInfo::RESOLUTION_MEDIUM+]
    # [+Layout::PageInfo::RESOLUTION_HIGH+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # output_resolution = doc.page_info.output_resolution
    # ```
    def output_resolution: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#output_resolution=} method sets the output rendering resolution
    # quality.
    # 
    # The resolution can be one of the following values:
    # [+Layout::PageInfo::RESOLUTION_LOW+]
    # [+Layout::PageInfo::RESOLUTION_MEDIUM+]
    # [+Layout::PageInfo::RESOLUTION_HIGH+]
    # 
    # _@param_ `resolution`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.page_info.output_resolution = Layout::PageInfo::RESOLUTION_MEDIUM
    # ```
    def output_resolution=: (Integer resolution) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#print_margins=} method sets whether to print the paper's margins.
    # 
    # _@param_ `print`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.page_info.print_margins=true
    # ```
    def print_margins=: (bool print) -> untyped

    # The {#print_margins?} method returns whether to print the paper's margins.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # margins_printed = doc.page_info.print_margins?
    # ```
    def print_margins?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#print_paper_color=} method sets whether or not the page color should be
    # printed.
    # 
    # _@param_ `print_paper_color`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.page_info.print_color = true
    # ```
    def print_paper_color=: (bool print_paper_color) -> untyped

    # The {#print_paper_color?} method returns whether or not the page color should
    # be printed.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # paper_color = doc.page_info.print_paper_color?
    # ```
    def print_paper_color?: () -> bool

    # The {#right_margin} method returns the paper's right margin in document units.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # right_margin = doc.page_info.right_margin
    # ```
    def right_margin: () -> Numeric

    # sord omit - no YARD return type given, using untyped
    # The {#right_margin=} sets the paper's right margin in document units.
    # 
    # _@param_ `margin`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.page_info.right_margin = 0.40
    # ```
    def right_margin=: (Numeric margin) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#show_margins=} method sets whether the paper's margins are visible.
    # 
    # _@param_ `margins_visible`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.page_info.show_margins = false
    # ```
    def show_margins=: (bool margins_visible) -> untyped

    # The {#show_margins?} method returns whether the paper's margins are visible.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # show_margins = doc.page_info.show_margins?
    # ```
    def show_margins?: () -> bool

    # The {#top_margin} method returns the paper's top margin in document units.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # top_margin = doc.page_info.top_margin
    # ```
    def top_margin: () -> Numeric

    # sord omit - no YARD return type given, using untyped
    # The {#top_margin} method sets the paper's top margin in document units.
    # 
    # _@param_ `margin`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.page_info.top_margin = 0.40
    # ```
    def top_margin=: (Numeric margin) -> untyped

    # The {#width} method returns the paper width in document units.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # width = doc.page_info.width
    # ```
    def width: () -> Numeric

    # sord omit - no YARD return type given, using untyped
    # The {#width=} method sets the paper width in document units.
    # 
    # _@param_ `width`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.page_info.width = 8.5
    # ```
    def width=: (Numeric width) -> untyped
  end

  # A {Layout::TableColumn} is a single row from a table.
  # 
  # @example
  #   bounds = Geom::Bounds2d.new(1, 1, 4, 4)
  #   rows = 4
  #   columns = 4
  #   table = Layout::Table.new(bounds, rows, columns)
  #   rows.times { |index|
  #     row = table.row(index)
  #   }
  # 
  # @version LayOut 2018
  class TableRow
    # The {#bottom_edge_style} method returns the {Layout::Style} of a
    # {Layout::TableRow}'s bottom edge.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # style = table.get_row(1).bottom_edge_style
    # ```
    def bottom_edge_style: () -> Layout::Style

    # sord omit - no YARD return type given, using untyped
    # The {#bottom_edge_style=} method sets the {Layout::Style} of a
    # {Layout::TableRow}'s bottom edge.
    # 
    # _@param_ `style`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # style = Layout::Style.new
    # style.stroke_width = 2.0
    # table.get_row(1).bottom_edge_style = style
    # ```
    def bottom_edge_style=: (Layout::Style style) -> untyped

    # The {#height} method returns the height of the {Layout::TableRow}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # height = table.get_row(1).height
    # ```
    def height: () -> Float

    # sord omit - no YARD return type given, using untyped
    # The {#height=} method sets the height of the {Layout::TableRow}.
    # 
    # _@param_ `height`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # table.get_row(1).height = 3.0
    # ```
    def height=: (Float height) -> untyped

    # The {#top_edge_style} method returns the {Layout::Style} of a
    # {Layout::TableRow}'s top edge.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # style = table.get_row(1).top_edge_style
    # ```
    def top_edge_style: () -> Layout::Style

    # sord omit - no YARD return type given, using untyped
    # The {#top_edge_style=} method sets the {Layout::Style} of a
    # {Layout::TableRow}'s top edge.
    # 
    # _@param_ `style`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # style = Layout::Style.new
    # style.stroke_width = 2.0
    # table.get_row(1).top_edge_style = style
    # ```
    def top_edge_style=: (Layout::Style style) -> untyped
  end

  # A simple rectangular shape entity.
  # 
  # @version LayOut 2018
  class Rectangle < Layout::Entity
    TYPE_BULGED: untyped
    TYPE_LOZENGE: untyped
    TYPE_NORMAL: untyped
    TYPE_ROUNDED: untyped

    # sord omit - no YARD type given for "*args", using untyped
    # The {#initialize} method creates a new normal, lozenge, bulged or rounded
    # {Layout::Rectangle}, depending on the type passed in.
    # 
    # The rectangle type can be one of the following values:
    # [+Layout::Rectangle::TYPE_NORMAL+]
    # [+Layout::Rectangle::TYPE_ROUNDED+]
    # [+Layout::Rectangle::TYPE_LOZENGE+]
    # [+Layout::Rectangle::TYPE_BULGED+]
    # 
    # ```ruby
    # upper_left = Geom::Point2d.new(1, 1)
    # lower_right = Geom::Point2d.new(2, 2)
    # bounds = Geom::Bounds2d.new(upper_left, lower_right)
    # # Creates a normal rectangle
    # rect = Layout::Rectangle.new(bounds)
    # rounded_rect = Layout::Rectangle.new_rounded(
    #     Layout::Rectangle::TYPE_ROUNDED, bounds, radius)
    # lozenge_rect = Layout::Rectangle.new_lozenge(
    #     Layout::Rectangle::TYPE_LOZENGE, bounds)
    # bulged_rect = Layout::Rectangle.new_bulged(Layout::Rectangle::TYPE_BULGED,
    #     bounds, bulge_distance)
    # ```
    def initialize: (*untyped args) -> void

    # The {#radius} method returns the radius of the {Layout::Rectangle}, or +nil+
    # if the {Layout::Rectangle} is not of type +Layout::Rectangle::TYPE_BULGED+ or
    # +Layout::Rectangle::TYPE_ROUNDED+
    # 
    # ```ruby
    # upper_left = Geom::Point2d.new(1, 1)
    # lower_right = Geom::Point2d.new(2, 2)
    # bounds = Geom::Bounds2d.new(upper_left, lower_right)
    # radius = 0.8
    # rect = Layout::Rectangle.new_rounded(bounds, radius)
    # # Should equal 0.8
    # r = rect.radius
    # ```
    def radius: () -> Float?

    # sord omit - no YARD return type given, using untyped
    # The {#radius=} method sets the radius of the {Layout::Rectangle}.
    # 
    # _@param_ `radius` — The new radius value to set
    # 
    # ```ruby
    # upper_left = Geom::Point2d.new(1, 1)
    # lower_right = Geom::Point2d.new(2, 2)
    # bounds = Geom::Bounds2d.new(upper_left, lower_right)
    # radius = 0.8
    # rect = Layout::Rectangle.new_rounded(bounds, radius)
    # rect.radius = 0.5
    # ```
    def radius=: (Float radius) -> untyped

    # The {#type} method returns the type of the {Layout::Rectangle}.
    # 
    # The type of a rectangle can be one of the following:
    # [+Layout::Rectangle::TYPE_NORMAL+]
    # [+Layout::Rectangle::TYPE_ROUNDED+]
    # [+Layout::Rectangle::TYPE_LOZENGE+]
    # [+Layout::Rectangle::TYPE_BULGED+]
    # 
    # _@return_ — integer that corresponds with a rectangle type
    # 
    # ```ruby
    # upper_left = Geom::Point2d.new(1, 1)
    # lower_right = Geom::Point2d.new(2, 2)
    # bounds = Geom::Bounds2d.new(upper_left, lower_right)
    # rect = Layout::Rectangle.new(bounds)
    # rect_type =rect.type
    # ```
    def type: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#type=} method sets the type of the {Layout::Rectangle}. If the type is
    # set to +Layout::Rectangle::TYPE_ROUNDED+ or +Layout::Rectangle::TYPE_BULGED+,
    # the [Layout::Rectangle]'s radius will be set to the default value of 0.25, if
    # the value had not previously been set.
    # 
    # The type of a {Layout::Rectangle} can be one of the following:
    # [+Layout::Rectangle::TYPE_NORMAL+]
    # [+Layout::Rectangle::TYPE_ROUNDED+]
    # [+Layout::Rectangle::TYPE_LOZENGE+]
    # [+Layout::Rectangle::TYPE_BULGED+]
    # 
    # _@param_ `type` — An integer that corresponds with a rectangle type
    # 
    # ```ruby
    # upper_left = Geom::Point2d.new(1, 1)
    # lower_right = Geom::Point2d.new(2, 2)
    # bounds = Geom::Bounds2d.new(upper_left, lower_right)
    # rect = Layout::Rectangle.new(bounds)
    # rect.type = Layout::Rectangle::TYPE_LOZENGE
    # ```
    def type=: (Integer _type) -> untyped
  end

  # A {Layout::TableCell} is a single cell from a table that contains data.
  # 
  # @example
  #   bounds = Geom::Bounds2d.new(1, 1, 4, 4)
  #   rows = 4
  #   columns = 4
  #   table = Layout::Table.new(bounds, rows, columns)
  #   table.each { |cell|
  #     puts cell.data.plain_text
  #   }
  # 
  # @version LayOut 2018
  class TableCell
    ROTATION_0: untyped
    ROTATION_180: untyped
    ROTATION_270: untyped
    ROTATION_90: untyped

    # sord omit - no YARD return type given, using untyped
    # The {#data} method creates a copy of the {Layout::FormattedText} for the
    # {Layout::TableCell}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # cell_entity = table[1, 2].data
    # ```
    def data: () -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#data=} method sets the {Layout::Entity} of a {Layout::TableCell}.
    # The text content and fill {Layout::Style} settings will be kept. The bounds
    # and other {Layout::Style} settings are controlled by the {Layout::Table}. If
    # the specified row and column is within a merged cell, then the merged cell
    # itself will be affected.
    # 
    # _@param_ `entity`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # anchor = Geom::Point2d.new(1, 1)
    # text_anchor_type = Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT
    # text = Layout::FormattedText.new("Test", anchor, text_anchor_type)
    # table[1, 2].data = text
    # ```
    # 
    # _@note_ — At the moment, this only works for {Layout::Entity}s that are
    # {Layout::FormattedText}s. However, future versions of LayOut may support
    # other types of {Layout::Entity}s for {Layout::TableCell}s, so this method
    # cannot be assumed to always fail with inputs of other {Layout::Entity}
    # types.
    def data=: (Layout::Entity entity) -> untyped

    # The {#rotation} method returns the rotation of a {Layout::TableCell}.
    # 
    # The rotation type can be one of the following values:
    # [+Layout::TableCell::ROTATION_0+]
    # [+Layout::TableCell::ROTATION_90+]
    # [+Layout::TableCell::ROTATION_180+]
    # [+Layout::TableCell::ROTATION_270+]
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # rotation = table[1, 1].rotation
    # ```
    def rotation: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#rotation=} method sets the rotation of a {Layout::TableCell}.
    # 
    # The rotation type can be one of the following values:
    # [+Layout::TableCell::ROTATION_0+]
    # [+Layout::TableCell::ROTATION_90+]
    # [+Layout::TableCell::ROTATION_180+]
    # [+Layout::TableCell::ROTATION_270+]
    # 
    # _@param_ `cell_rotation`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # table[1, 1].rotation = Layout::TableCell::ROTATION_180
    # ```
    def rotation=: (Integer cell_rotation) -> untyped

    # The {#span} method returns the row and column span of a {Layout::TableCell}.
    # If the values returned are both 1, then it is a normal, non-merged cell. If
    # either of the values are greater than 1, then it is a merged cell. If the
    # values are both 0, then it is an unused cell that resides within the inner
    # portion of another merged cell.
    # 
    # _@return_ — Row span and column span.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # row_span, column_span = table[1, 1].span
    # ```
    def span: () -> [Integer, Integer]
  end

  # A {Layout::TableColumn} is a single column from a table.
  # 
  # @example
  #   bounds = Geom::Bounds2d.new(1, 1, 4, 4)
  #   rows = 4
  #   columns = 4
  #   table = Layout::Table.new(bounds, rows, columns)
  #   columns.times { |index|
  #     column = table.column(index)
  #   }
  # 
  # @version LayOut 2018
  class TableColumn
    # The {#left_edge_style} method returns the {Layout::Style} of a
    # {Layout::TableColumn}'s left edge. If this is the first column of the table,
    # this method will return the style of the table border.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # style = table.get_column(1).edge_style
    # ```
    def left_edge_style: () -> Layout::Style

    # sord omit - no YARD return type given, using untyped
    # The {#left_edge_style=} method sets the {Layout::Style} of a
    # {Layout::TableColumn}'s left edge. If this is the first column of the table,
    # this method will set the style for the table border.
    # 
    # _@param_ `style`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # style = Layout::Style.new
    # style.stroke_width = 2.0
    # table.get_column(1).edge_style = style
    # ```
    def left_edge_style=: (Layout::Style style) -> untyped

    # The {#right_edge_style} method returns the {Layout::Style} of a
    # {Layout::TableColumn}'s right edge. If this is the last column of the table,
    # this method will return the style of the table border.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # style = table.get_column(1).edge_style
    # ```
    def right_edge_style: () -> Layout::Style

    # sord omit - no YARD return type given, using untyped
    # The {#right_edge_style=} method sets the {Layout::Style} of a
    # {Layout::TableColumn}'s right edge. If this is the last column of the table,
    # this method will set the style for the table border.
    # 
    # _@param_ `style`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # style = Layout::Style.new
    # style.stroke_width = 2.0
    # table.get_column(1).edge_style = style
    # ```
    def right_edge_style=: (Layout::Style style) -> untyped

    # The {#width} method returns the width of the {Layout::TableColumn}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # width = table.get_column(1).width
    # ```
    def width: () -> Float

    # sord omit - no YARD return type given, using untyped
    # The {#width=} method sets the width of the {Layout::TableColumn}.
    # 
    # _@param_ `width`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 4, 4)
    # rows = 4
    # columns = 4
    # table = Layout::Table.new(bounds, rows, columns)
    # table.get_column(1).width = 6.0
    # ```
    def width=: (Float width) -> untyped
  end

  # A formatted text entity.
  # 
  # @version LayOut 2018
  class FormattedText < Layout::Entity
    ANCHOR_TYPE_BOTTOM_CENTER: untyped
    ANCHOR_TYPE_BOTTOM_LEFT: untyped
    ANCHOR_TYPE_BOTTOM_RIGHT: untyped
    ANCHOR_TYPE_CENTER_CENTER: untyped
    ANCHOR_TYPE_CENTER_LEFT: untyped
    ANCHOR_TYPE_CENTER_RIGHT: untyped
    ANCHOR_TYPE_TOP_CENTER: untyped
    ANCHOR_TYPE_TOP_LEFT: untyped
    ANCHOR_TYPE_TOP_RIGHT: untyped
    GROW_MODE_BOUNDED: untyped
    GROW_MODE_UNBOUNDED: untyped

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {.new_from_file} method creates a new {Layout::FormattedText} from a text
    # file.
    # 
    # The anchor type can be one of the following values:
    # [+ANCHOR_TYPE_TOP_LEFT+]
    # [+ANCHOR_TYPE_CENTER_LEFT+]
    # [+ANCHOR_TYPE_BOTTOM_LEFT+]
    # [+ANCHOR_TYPE_TOP_RIGHT+]
    # [+ANCHOR_TYPE_CENTER_RIGHT+]
    # [+ANCHOR_TYPE_BOTTOM_RIGHT+]
    # [+ANCHOR_TYPE_TOP_CENTER+]
    # [+ANCHOR_TYPE_CENTER_CENTER+]
    # [+ANCHOR_TYPE_BOTTOM_CENTER+]
    # 
    # Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT)
    # 
    # ```ruby
    # anchor = Geom::Point2d.new(1, 1)
    # text = Layout::FormattedText.new("C:/Test.txt", anchor,
    # ```
    def self.new_from_file: (*untyped args) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#append_plain_text} method appends new text with a given style to the
    # end of the existing plain text of the {Layout::FormattedText}.
    # 
    # _@param_ `plain_text`
    # 
    # _@param_ `style`
    # 
    # ```ruby
    # anchor = Geom::Point2d.new(1, 1)
    # text = Layout::FormattedText.new("Test", anchor, Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT)
    # style = text.style(0)
    # text.append_plain_text("foo", style)
    # ```
    # 
    # _@note_ — This method does not support more than two different style runs in a
    # single text string.
    def append_plain_text: (String plain_text, Layout::Style style) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#apply_style} method sets the {Layout::Style} for the text starting at
    # the given character index, and running for the given number of characters.
    # 
    # _@param_ `style`
    # 
    # _@param_ `index`
    # 
    # _@param_ `length`
    # 
    # ```ruby
    # anchor = Geom::Point2d.new(1, 1)
    # text = Layout::FormattedText.new("Test", anchor, Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT)
    # style = text.style(0)
    # style.text_bold = true
    # text.apply_style(style, 2, 4)
    # ```
    def apply_style: (Layout::Style style, ?Integer index, ?Integer length) -> untyped

    # The {#display_text} method returns the display text representation of the
    # {Layout::FormattedText}.
    # 
    # Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT) doc.add_entity(text, doc.layers.first,
    # doc.pages.first) text = text.display_text(doc.pages.first)
    # 
    # _@param_ `page` — The {Layout::Page} to use to convert an auto-text tag to display text
    # 
    # ```ruby
    # anchor = Geom::Point2d.new(1, 1)
    # text = Layout::FormattedText.new("<PageNumber>", anchor,
    # ```
    # 
    # _@note_ — Passing an invalid {Layout::Page} will prevent an auto-text tag from
    # being substituted with its display representation.
    def display_text: (?Layout::Page? page) -> String

    # The {#grow_mode} method returns the mode for how the {Layout::FormattedText}
    # sizes itself.
    # 
    # The grow mode can be one of the following values:
    # [+Layout::FormattedText::GROW_MODE_BOUNDED+]
    # [+Layout::FormattedText::GROW_MODE_UNBOUNDED+]
    # 
    # _@return_ — grow_mode
    # 
    # ```ruby
    # anchor = Geom::Point2d.new(1, 1)
    # text = Layout::FormattedText.new("Test", anchor, Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT)
    # mode = text.grow_mode
    # ```
    def grow_mode: () -> Integer

    # sord infer - inferred type of parameter "grow_mode" as Integer using getter's return type
    # The {#grow_mode=} method sets the mode for how the {Layout::FormattedText}
    # sizes itself.
    # 
    # The grow mode can be one of the following values:
    # [+Layout::FormattedText::GROW_MODE_BOUNDED+]
    # [+Layout::FormattedText::GROW_MODE_UNBOUNDED+]
    # 
    # _@return_ — grow_mode
    # 
    # ```ruby
    # anchor = Geom::Point2d.new(1, 1)
    # text = Layout::FormattedText.new("Test", anchor, Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT)
    # text.grow_mode = GROW_MODE_UNBOUNDED
    # ```
    def grow_mode=: (Integer grow_mode) -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # The {#initialize} method creates a new {Layout::FormattedText}.
    # 
    # The anchor type can be one of the following values:
    # [+ANCHOR_TYPE_TOP_LEFT+]
    # [+ANCHOR_TYPE_CENTER_LEFT+]
    # [+ANCHOR_TYPE_BOTTOM_LEFT+]
    # [+ANCHOR_TYPE_TOP_RIGHT+]
    # [+ANCHOR_TYPE_CENTER_RIGHT+]
    # [+ANCHOR_TYPE_BOTTOM_RIGHT+]
    # [+ANCHOR_TYPE_TOP_CENTER+]
    # [+ANCHOR_TYPE_CENTER_CENTER+]
    # [+ANCHOR_TYPE_BOTTOM_CENTER+]
    # 
    # ```ruby
    # anchor = Geom::Point2d.new(1, 1)
    # text = Layout::FormattedText.new("Test", anchor, Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT)
    # ```
    def initialize: (*untyped args) -> void

    # The {#plain_text} method returns the plain text representation of the
    # {Layout::FormattedText}.
    # 
    # ```ruby
    # anchor = Geom::Point2d.new(1, 1)
    # text = Layout::FormattedText.new("Test", anchor, Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT)
    # text = text.plain_text
    # ```
    def plain_text: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#plain_text=} method sets the plain text representation of the
    # {Layout::FormattedText}.
    # 
    # _@param_ `plain_text`
    # 
    # ```ruby
    # anchor = Geom::Point2d.new(1, 1)
    # text = Layout::FormattedText.new("Test", anchor, Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT)
    # text.plain_text = "foo"
    # ```
    def plain_text=: (String plain_text) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#rtf} method returns the raw RTF representation of the
    # {Layout::FormattedText}.
    # 
    # ```ruby
    # anchor = Geom::Point2d.new(1, 1)
    # text = Layout::FormattedText.new("Test", anchor, Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT)
    # rtf_text = text.rtf
    # ```
    # 
    # _@note_ — Passing an invalid {Layout::Page} will prevent an auto-text tag from
    # being substituted with its display representation.
    def rtf: (*untyped args) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#rtf=} method sets the raw RTF representation of the
    # {Layout::FormattedText}.
    # 
    # text.\par}"
    # 
    # _@param_ `rtf_text`
    # 
    # ```ruby
    # anchor = Geom::Point2d.new(1, 1)
    # text = Layout::FormattedText.new("Test", anchor, Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT)
    # text.rtf = "{\rtf1\ansi{\fonttbl\f0\fswiss Helvetica;}\f0\pard This is some {\b bold}
    # ```
    def rtf=: (String rtf_text) -> untyped

    # The {#style} method returns a {Layout::Style} for the text starting at the
    # given character index, and running for the given length.
    # 
    # _@param_ `index`
    # 
    # _@param_ `length`
    # 
    # ```ruby
    # anchor = Geom::Point2d.new(1, 1)
    # text = Layout::FormattedText.new("Test", anchor, Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT)
    # style = text.style(0)
    # ```
    def style: (?Integer index, ?Integer length) -> Layout::Style
  end

  # References an instance of a {Layout::Layer}. A {Layout::LayerInstance}
  # provides access to the {Layout::Entity}s that are on it, as well as their
  # draw order. {Layout::Group}s are not included in the list of {Layout::Entity}s
  # associated with a {Layout::LayerInstance}, since the group hierarchy has no
  # effect on entity draw order. Each {Layout::Page} has one
  # {Layout::LayerInstance} for each {Layout::Layer} in the {Layout::Document}.
  # Non-shared {Layout::LayerInstance}s are unique per {Layout::Page}, while
  # shared {Layout::LayerInstance}s are shared across all {Layout::Page}s of the
  # {Layout::Document}.
  # 
  # @example
  #   doc = Layout::Document.open("C:/path/to/document.layout")
  #   layers = doc.layers
  #   pages = doc.pages
  #   layers.each do |layer|
  #     layer_instance = layer.layer_instance(pages.first)
  #     entities = layer_instance.entities
  #     entities.each do |entity|
  #       new_index = rand(entities.length - 1)
  #       layer_instance.reorder_entity(entity, new_index)
  #     end
  #   end
  # 
  # @version LayOut 2018
  class LayerInstance
    # The {#==} method checks to see if the two {Layout::LayerInstance}s are equal.
    # This checks whether the Ruby Objects are pointing to the same internal
    # object.
    # 
    # _@param_ `other`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # document = doc.pages.first.document
    # doc.page.layer_instances.first == document.page.layer_instances.first
    # ```
    def ==: (Layout::LayerInstance other) -> bool

    # The {#definition} method returns the {Layout::Layer} of the
    # {Layout::LayerInstance}.
    # 
    # ```ruby
    # layer_def = layer_instance.definition
    # ```
    def definition: () -> Layout::Layer

    # The {#entities} method returns the {Layout::Entities} on the
    # {Layout::LayerInstance}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # pages = doc.pages
    # first_layer = layers.first
    # entities = first_layer.layer_instance.entities
    # ```
    def entities: () -> Layout::Entities

    # The {#entity_index} method returns the index of the {Layout::Entity} on the
    # {Layout::LayerInstance}.
    # 
    # _@param_ `entity` — The entity to get the index of.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # pages = doc.pages
    # instance = layers.first.layer_instance
    # instance.entities.each_with_index { |entity, index|
    #   puts "#{index} == #{instance.entity_index(entity)}"
    # }
    # ```
    def entity_index: (Layout::Entity entity) -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#reorder_entity} method moves the {Layout::Entity} to the specified
    # index.
    # 
    # _@param_ `entity` — The {Layout::Entity} to reorder
    # 
    # _@param_ `index` — The desired index of the {Layout::Entity}
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # layers = doc.layers
    # pages = doc.pages
    # first_layer = layers.first
    # first_layer.set_shared(pages.first, SHARELAYERACTION_KEEPONEPAGE);
    # layer_instance = first_layer.layer_instance
    # entities = layer_instance.entities
    # # put the first entity into the back of the layer
    # layer_instance.reorder_entity(entities.first, (entities.length - 1))
    # ```
    def reorder_entity: (Layout::Entity entity, Integer index) -> untyped
  end

  # A SketchUp Model entity. This is an instance of a SketchUp Model that is
  # inserted into a .layout file. You can change the render mode, line weight,
  # and set the current scene for the SketchUp Model with this interface.
  # 
  # @example
  #   bounds = Geom::Bounds2d.new(1, 1, 3, 3)
  #   model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
  #   model.current_scene = 2
  #   model.view = Layout::SketchUpModel::FRONT_VIEW
  #   model.render_mode = Layout::SketchUpModel::VECTOR_RENDER
  #   model.render if model.render_needed?
  # 
  # @version LayOut 2018
  class SketchUpModel < Layout::Entity
    BOTTOM_RELATIVE_VIEW: untyped
    BOTTOM_VIEW: untyped
    BACK_VIEW: untyped
    CUSTOM_VIEW: untyped
    FRONT_VIEW: untyped
    HYBRID_RENDER: untyped
    ISO_VIEW: untyped
    LEFT_VIEW: untyped
    RASTER_RENDER: untyped
    RIGHT_VIEW: untyped
    TOP_RELATIVE_VIEW: untyped
    TOP_VIEW: untyped
    VECTOR_RENDER: untyped

    # The {#camera_modified?} method returns whether the camera of the
    # {Layout::SketchUpModel} has been modified.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # modified = model.camera_modified?
    # ```
    def camera_modified?: () -> bool

    # The {#clip_mask} method returns the clip mask entity for the
    # {Layout::SketchUpModel}, or +nil+ if it does not have one. clip_mask can be a
    # {Layout::Rectangle}, {Layout::Ellipse}, or {Layout::Path}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # clip_mask = model.clip_mask
    # ```
    def clip_mask: () -> Layout::Entity

    # sord omit - no YARD return type given, using untyped
    # The {#clip_mask=} method sets a clip mask for the {Layout::SketchUpModel}.
    # clip_mask can be a {Layout::Rectangle}, {Layout::Ellipse}, or {Layout::Path},
    # or +nil+, and it must not currently exist in a {Layout::Document},
    # or {Layout::Group}.
    # 
    # _@param_ `clip_mask` — The clip mask can be a {Layout::Path}, {Layout::Rectangle}, {Layout::Ellipse}, or +nil+.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # rect = Layout::Rectangle.new([[2, 2], [3, 3]]);
    # model.clip_mask = rect
    # ```
    # 
    # _@note_ — +clip_mask+ may be +nil+ as of LayOut 2020.1.
    def clip_mask=: (Layout::Entity? clip_mask) -> untyped

    # The {#current_scene} method returns the index of the most recently
    # selected scene of the {Layout::SketchUpModel}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # scene_index = model.current_scene
    # ```
    def current_scene: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#current_scene=} method sets the scene of the {Layout::SketchUpModel}.
    # 
    # _@param_ `index` — The index into the list of available scenes.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.current_scene = 1
    # ```
    # 
    # _@note_ — LayOut automatically adds the scene "Last Saved SketchUp View" to each
    # {Layout::SketchUpModel}. This means that the {Sketchup::Model}'s scenes
    # start with index 1.
    def current_scene=: (Integer index) -> untyped

    # The {#current_scene_modified?} method returns whether the most recently
    # selected scene of the {Layout::SketchUpModel} has been modified.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # modified = model.current_scene_modified?
    # ```
    def current_scene_modified?: () -> bool

    # The {#dash_scale} method returns the dash scale for the
    # {Layout::SketchUpModel}. A scale value of 0.0 means the dashes are scaled
    # based on the line weight.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # dash_scale = model.dash_scale
    # ```
    def dash_scale: () -> Float

    # sord omit - no YARD return type given, using untyped
    # The {#dash_scale=} method sets the dash scale for the {Layout::SketchUpModel}.
    # A scale value of 0.0 or lower will "auto" scale the dashes based on the line
    # weight.
    # 
    # _@param_ `dash_scale`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.dash_scale = 2.5
    # ```
    def dash_scale=: (Float dash_scale) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#display_background=} method sets whether the background is displayed
    # for the {Layout::SketchUpModel}.
    # 
    # _@param_ `display`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.display_background = false
    # ```
    def display_background=: (bool display) -> untyped

    # The {#display_background?} method returns whether the background is displayed
    # for the {Layout::SketchUpModel}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # displayed = model.display_background?
    # ```
    def display_background?: () -> bool

    # The {#effects_modified?} method returns whether the shadow or fog settings
    # of the {Layout::SketchUpModel} have been modified.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # modified = model.effects_modified?
    # ```
    def effects_modified?: () -> bool

    # The {#entities} method returns the {Layout::Group} that represents the
    # {Layout::SketchUpModel} in its exploded form. The {Layout::Group} will
    # contain a {Layout::Image} for raster and hybrid-rendered models, and
    # will contain a {Layout::Group} of LayOut entities for
    # vector and hybrid-rendered models.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # entities = model.entities
    # ```
    def entities: () -> Layout::Entity

    # The {#initialize} method creates a new {Layout::SketchUpModel}.
    # 
    # _@param_ `path` — The path to a .skp file
    # 
    # _@param_ `bounds`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # ```
    def initialize: (String path, Geom::Bounds2d bounds) -> void

    # The {#layers_modified?} method returns whether the layers of the
    # {Layout::SketchUpModel} has been modified.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # modified = model.layers_modified?
    # ```
    # 
    # _@note_ — In SketchUp 2020, SketchUp "layers" were renamed to "tags". For
    # consistency with the SketchUp API, this will continue to refer to
    # "tags" as "layers".
    def layers_modified?: () -> bool

    # The {#line_weight} method returns the line weight for the
    # {Layout::SketchUpModel}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # line_weight = model.line_weight
    # ```
    def line_weight: () -> Float

    # sord omit - no YARD return type given, using untyped
    # The {#line_weight=} method sets the line weight for the
    # {Layout::SketchUpModel}. Line weight must be at least 0.01.
    # 
    # _@param_ `line_weight`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.line_weight = 2.5
    # ```
    def line_weight=: (Float line_weight) -> untyped

    # The {#model_to_paper_point} method converts the {Geom::Point3d} in the
    # {Layout::SketchUpModel} to a {Geom::Point2d} in paper space.
    # 
    # _@param_ `model_point`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # point_3d = [200, 100, 100]
    # point_2d = model.model_to_paper_point(point_3d)
    # ```
    def model_to_paper_point: (Geom::Point3d model_point) -> Geom::Point2d

    # sord omit - no YARD return type given, using untyped
    # The {#perspective=} method sets whether the {Layout::SketchUpModel}'s view
    # is perspective or orthographic.
    # 
    # _@param_ `perspective`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.perspective = false
    # ```
    def perspective=: (bool perspective) -> untyped

    # The {#perspective?} method returns whether the {Layout::SketchUpModel}'s view
    # is perspective or orthographic.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # perspective = model.perspective?
    # ```
    def perspective?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#preserve_scale_on_resize=} method sets whether the scale is preserved
    # when the {Layout::SketchUpModel} is resized.
    # 
    # _@param_ `preserve_scale`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.preserve_scale_on_resize = true
    # ```
    def preserve_scale_on_resize=: (bool preserve_scale) -> untyped

    # The {#preserve_scale_on_resize?} method returns whether the scale is
    # preserved when the {Layout::SketchUpModel} is resized.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # will_scale = model.preserve_scale_on_resize?
    # ```
    def preserve_scale_on_resize?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#render} method renders the {Layout::SketchUpModel}. If the model
    # belongs to a {Layout::Document}, then the render will be performed at the
    # quality set in document.page_info (see {Layout::Document} and
    # {Layout::PageInfo}). Otherwise, the render will be performed at Low quality.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.render if model.render_needed?
    # ```
    def render: () -> untyped

    # The {#render_mode} method returns the render mode of the
    # {Layout::SketchUpModel}.
    # 
    # The render mode can be one of the following:
    # [+Layout::SketchUpModel::RASTER_RENDER+]
    # [+Layout::SketchUpModel::HYBRID_RENDER+]
    # [+Layout::SketchUpModel::VECTOR_RENDER+]
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # render_mode = model.render_mode
    # ```
    def render_mode: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#render_mode=} method sets the render mode of the
    # {Layout::SketchUpModel}.
    # 
    # The render mode can be one of the following:
    # [+Layout::SketchUpModel::RASTER_RENDER+]
    # [+Layout::SketchUpModel::HYBRID_RENDER+]
    # [+Layout::SketchUpModel::VECTOR_RENDER+]
    # 
    # _@param_ `render_mode`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.render_mode = Layout::SketchUpModel::RASTER_RENDER
    # ```
    def render_mode=: (Integer render_mode) -> untyped

    # The {#render_needed?} method returns whether the {Layout::SketchUpModel}
    # needs to be rendered.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.render if model.render_needed?
    # ```
    def render_needed?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#reset_camera} method resets the {Layout::SketchUpModel}'s camera to
    # the scene's setting.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.reset_camera if model.camera_modified?
    # ```
    def reset_camera: () -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#reset_effects} method resets the {Layout::SketchUpModel}'s shadow and
    # fog settings to the scene's settings.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.reset_effects if model.effects_modified?
    # ```
    def reset_effects: () -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#reset_layers} method resets the {Layout::SketchUpModel}'s layers to
    # the scene's setting.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.reset_layers if model.layers_modified?
    # ```
    # 
    # _@note_ — In SketchUp 2020, SketchUp "layers" were renamed to "tags". For
    # consistency with the SketchUp API, this will continue to refer to
    # "tags" as "layers".
    def reset_layers: () -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#reset_style} method resets the {Layout::SketchUpModel}'s style to
    # the scene's setting.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.reset_style if model.style_modified?
    # ```
    def reset_style: () -> untyped

    # The {#scale} method returns the scale of the {Layout::SketchUpModel}.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # scale = model.scale
    # ```
    def scale: () -> Float

    # sord omit - no YARD return type given, using untyped
    # The {#scale=} method sets the scale of the {Layout::SketchUpModel}. Scale
    # must be at least 0.0000001, and the view must be orthographic.
    # 
    # _@param_ `scale`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.scale = 2.0
    # ```
    def scale=: (Float scale) -> untyped

    # The {#scenes} method returns an array of scene names that are available
    # for the {Layout::SketchUpModel}. The first scene will always be the default
    # scene, called "Last saved SketchUp View".
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # scene_names = model.scenes
    # ```
    def scenes: () -> ::Array[String]

    # The {#style_modified?} method returns whether the style of the
    # {Layout::SketchUpModel} has been modified.
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # modified = model.style_modified?
    # ```
    def style_modified?: () -> bool

    # The {#view} method returns the standard view of the {Layout::SketchUpModel}.
    # 
    # The standard view can be one of the following values:
    # [+Layout::SketchUpModel::CUSTOM_VIEW+]
    # [+Layout::SketchUpModel::TOP_VIEW+]
    # [+Layout::SketchUpModel::TOP_RELATIVE_VIEW+]
    # [+Layout::SketchUpModel::BOTTOM_VIEW+]
    # [+Layout::SketchUpModel::BOTTOM_RELATIVE_VIEW+]
    # [+Layout::SketchUpModel::FRONT_VIEW+]
    # [+Layout::SketchUpModel::BACK_VIEW+]
    # [+Layout::SketchUpModel::LEFT_VIEW+]
    # [+Layout::SketchUpModel::RIGHT_VIEW+]
    # [+Layout::SketchUpModel::ISO_VIEW+]
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # view = model.view
    # ```
    def view: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#view=} method sets the standard view of the {Layout::SketchUpModel}.
    # 
    # The standard view can be one of the following values:
    # [+Layout::SketchUpModel::TOP_VIEW+]
    # [+Layout::SketchUpModel::TOP_RELATIVE_VIEW+]
    # [+Layout::SketchUpModel::BOTTOM_VIEW+]
    # [+Layout::SketchUpModel::BOTTOM_RELATIVE_VIEW+]
    # [+Layout::SketchUpModel::FRONT_VIEW+]
    # [+Layout::SketchUpModel::BACK_VIEW+]
    # [+Layout::SketchUpModel::LEFT_VIEW+]
    # [+Layout::SketchUpModel::RIGHT_VIEW+]
    # [+Layout::SketchUpModel::ISO_VIEW+]
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # bounds = Geom::Bounds2d.new(1, 1, 3, 3)
    # model = Layout::SketchUpModel.new("C:/Path/to/model.skp", bounds)
    # model.view = Layout::SketchUpModel::FRONT_VIEW
    # ```
    def view=: (Integer view) -> untyped
  end

  # This is the interface to a LayOut Connection Point. A
  # {Layout::ConnectionPoint} defines a target point to which a {Layout::Label}
  # or {Layout::LinearDimension} can connect.
  # 
  # @example
  #   doc = Layout::Document.open("C:/path/to/document.layout")
  #   entity = doc.pages.first.entities.first
  #   point = [2, 2]
  #   # Create a Connection Point to LayOut Entity in the document
  #   cp = Layout::ConnectionPoint.new(entity, point)
  #   # If the entity is a [Layout::SketchUpModel], then we can use a 3D point
  #   # in model space along with the PID of the entity in the model to make a
  #   # deep connection.
  #   point3D = [100, 200, 300]
  #   pid = "1345"
  #   cp2 = Layout::ConnectionPoint.new(entity, point3D, pid)
  #   # This point can then be used to connect a label or linear dimension to
  #   # the entity.
  #   leader_type = Layout::Label::LEADER_LINE_TYPE_BEZIER
  #   target_point = Geom::Point2d.new(1, 1)
  #   bounds = Geom::Bounds2d.new(2, 1, 1, 1)
  #   label = Layout::Label.new(text, leader_type, target_point, bounds)
  #   label.connect(cp)
  # 
  # @version LayOut 2018
  class ConnectionPoint
    # sord omit - no YARD type given for "*args", using untyped
    # The {#initialize} method creates a new {Layout::ConnectionPoint}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # entity = doc.pages.first.entities.first
    # point = [2, 2]
    # # Create a Connection Point to LayOut Entity in the document
    # cp = Layout::ConnectionPoint.new(entity, point)
    # ```
    def initialize: (*untyped args) -> void
  end

  # References a linear dimension entity. A {Layout::LinearDimension} is composed
  # of the following sub-entities:
  # - two 'extension lines' that connect to the {Layout::Entity} being
  #   dimensioned.
  # - a 'dimension line' connecting the ends of the leaders. This may be
  #   represented by one or two {Layout::Path}s depending on appearance.
  # - an optional 'leader line' that is used for small {Layout::LinearDimension}s.
  # - a 'dimension text' that displays the {Layout::LinearDimension}'s text.
  # 
  # There are six points that may be modified for a {Layout::LinearDimension}:
  # - two 'connection points' that define the start and end of the
  #   {Layout::LinearDimension}.
  # - two 'extent points' that define the start and end of the dimension line and
  #   are the ends of the two extension lines.
  # - two 'offset points' that define the starting points of the extension lines.
  # 
  # @version LayOut 2018
  class LinearDimension < Layout::Entity
    LEADER_LINE_TYPE_BEZIER: untyped
    LEADER_LINE_TYPE_HIDDEN: untyped
    LEADER_LINE_TYPE_SINGLE_SEGMENT: untyped
    LEADER_LINE_TYPE_TWO_SEGMENT: untyped

    # sord omit - no YARD return type given, using untyped
    # The {#auto_scale=} method sets whether the scale for the
    # {Layout::LinearDimension} is set automatically.
    # 
    # _@param_ `uses_auto_scale`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # dim.auto_scale = true
    # ```
    def auto_scale=: (bool uses_auto_scale) -> untyped

    # The {#auto_scale?} method returns whether the scale for the
    # {Layout::LinearDimension} is set automatically.
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # uses_auto_scale = dim.auto_scale?
    # ```
    def auto_scale?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#connect} method connects the {Layout::LinearDimension} to one or two
    # {Layout::Entity}s using the provided {Layout::ConnectionPoint}s. The
    # {Layout::LinearDimension} must be in the same {Layout::Document} as the
    # {Layout::Entity}s, and on the same {Layout::Page} if the {Layout::Entity}s
    # are on non-shared {Layout::Layer}s.
    # 
    # _@param_ `start_connection`
    # 
    # _@param_ `end_connection`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # point_1 = Geom::Point2d.new(5, 7.5)
    # point_2 = Geom::Point2d.new(8.5, 9)
    # table = Layout::Rectangle.new([point_1, point_2])
    # doc.add_entity(table, doc.layers.first, doc.pages.first)
    # start_point = Layout::ConnectionPoint.new(table, point_1)
    # end_point = Layout::ConnectionPoint.new(table, point_2)
    # height = 1.0
    # dim = Layout::LinearDimension.new(Geom::Point2d.new(1, 1),
    #   Geom::Point2d.new(5, 5), height)
    # dim.connect(start_point, end_point)
    # ```
    def connect: (Layout::ConnectionPoint start_connection, Layout::ConnectionPoint end_connection) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#custom_text=} method sets whether the {Layout::LinearDimension} uses
    # custom text. When +true+, the {Layout::LinearDimension} will display a custom
    # string that doesn't change. When +false+, it will display the length
    # measurement and will update automatically.
    # 
    # _@param_ `uses_custom_text`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # dim.custom_text = true
    # ```
    def custom_text=: (bool uses_custom_text) -> untyped

    # The {#custom_text?} method returns whether the {Layout::LinearDimension}
    # uses custom text. When +true+, the {Layout::LinearDimension} will display a
    # custom string that doesn't change. When +false+, it will display the length
    # measurement and will update automatically.
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # # returns false
    # uses_custom_text = dim.custom_text?
    # ```
    def custom_text?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#disconnect} method disconnects the {Layout::LinearDimension} from its
    # {Layout::ConnectionPoint}s. The dimension will not be adjusted by
    # disconnecting from its {Layout::ConnectionPoint}s.
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # dim.disconnect
    # ```
    def disconnect: () -> untyped

    # The {#end_connection_point} method returns the paper space location for the
    # second connection.
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # end_connection = dim.end_connection_point
    # ```
    def end_connection_point: () -> Geom::Point2d

    # sord omit - no YARD return type given, using untyped
    # The {#end_connection_point=} method sets the paper space location for the
    # second connection.
    # 
    # _@param_ `end_point`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # dim.end_connection_point = Geom::Point2d.new(6, 6)
    # ```
    def end_connection_point=: (Geom::Point2d end_point) -> untyped

    # The {#end_extent_point} method returns the paper space location for the
    # end of the dimension line.
    # 
    # _@return_ — end_extent
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # end_ext_point = dim.end_extent_point
    # ```
    def end_extent_point: () -> Geom::Point2d

    # sord omit - no YARD return type given, using untyped
    # The {#end_extent_point=} method sets the paper space location for the
    # end of the dimension line.
    # 
    # _@param_ `end_extent`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # end_ext_point = Geom::Point2d.new(5, 6)
    # dim.end_extent_point = end_ext_point
    # ```
    def end_extent_point=: (Geom::Point2d end_extent) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#end_offset_length=} method sets the length of the offset from the
    # second {Layout::ConnectionPoint} to the start of the second extension line.
    # The {Layout::ConnectionPoint} and extent point will not move.
    # 
    # _@param_ `offset_length`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # end_ext_point = Geom::Point2d.new(5, 6)
    # dim.end_offset_length = 0.5
    # ```
    def end_offset_length=: (Numeric offset_length) -> untyped

    # The {#end_offset_point} method returns the paper space location for the
    # end of the first extension line. The first extension line runs from this
    # offset point to the end extent point.
    # 
    # _@return_ — end_offset
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # end_offset = dim.end_offset_point
    # ```
    def end_offset_point: () -> Geom::Point2d

    # The {#entities} method returns the {Layout::Entities} that represent the
    # {Layout::LinearDimension} in its exploded form. Depending on the appearance
    # of the {Layout::LinearDimension}, this may return anywhere from four to six
    # {Layout::Entity}s: start extension line, end extension line, one or two
    # dimension lines, dimension text, and optionally the leader line.
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # entites = dim.entities
    # ```
    def entities: () -> Layout::Entities

    # The {#initialize} method creates a new disconnected {Layout::LinearDimension}.
    # 
    # _@param_ `start_point`
    # 
    # _@param_ `end_point`
    # 
    # _@param_ `height` — Distance from the start and end points to the dimension line
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # ```
    def initialize: (Geom::Point2d start_point, Geom::Point2d end_point, Numeric height) -> void

    # The {#leader_line_type} method returns the type of leader line the
    # {Layout::LinearDimension} is using.
    # 
    # The leader line type can be one of the following:
    # [+Layout::LinearDimension::LEADER_LINE_TYPE_SINGLE_SEGMENT+]
    # [+Layout::LinearDimension::LEADER_LINE_TYPE_TWO_SEGMENT+]
    # [+Layout::LinearDimension::LEADER_LINE_TYPE_BEZIER+]
    # [+Layout::LinearDimension::LEADER_LINE_TYPE_HIDDEN+]
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # type = dim.leader_line_type
    # ```
    def leader_line_type: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#leader_line_type=} method sets the type of leader line the
    # {Layout::LinearDimension} is using.
    # 
    # The leader line type can be one of the following:
    # [+Layout::LinearDimension::LEADER_LINE_TYPE_SINGLE_SEGMENT+]
    # [+Layout::LinearDimension::LEADER_LINE_TYPE_TWO_SEGMENT+]
    # [+Layout::LinearDimension::LEADER_LINE_TYPE_BEZIER+]
    # [+Layout::LinearDimension::LEADER_LINE_TYPE_HIDDEN+]
    # 
    # _@param_ `type` — The leader line type
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # dim.leader_line_type = Layout::LinearDimension::LEADER_LINE_TYPE_BEZIER
    # ```
    def leader_line_type=: (Integer _type) -> untyped

    # The {#scale} method returns the scale being used for the
    # {Layout::LinearDimension}.
    # 
    # _@return_ — scale
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # scale = dim.scale
    # ```
    def scale: () -> Numeric

    # sord omit - no YARD return type given, using untyped
    # The {#scale=} method sets the scale being used for the
    # {Layout::LinearDimension}.
    # 
    # _@param_ `scale`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # dim.scale = 1.5
    # ```
    def scale=: (Numeric scale) -> untyped

    # The {#start_connection_point} method returns the paper space location for the
    # first connection.
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # start_connection = dim.start_connection_point
    # ```
    def start_connection_point: () -> Geom::Point2d

    # sord omit - no YARD return type given, using untyped
    # The {#start_connection_point=} method sets the paper space location for the
    # first connection.
    # 
    # _@param_ `start_point`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # dim.start_connection_point = Geom::Point2d.new(2, 2)
    # ```
    def start_connection_point=: (Geom::Point2d start_point) -> untyped

    # The {#start_extent_point} method returns the paper space location for the
    # start of the dimension line.
    # 
    # _@return_ — start_extent
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # start_ext_point = dim.start_extent_point
    # ```
    def start_extent_point: () -> Geom::Point2d

    # sord omit - no YARD return type given, using untyped
    # The {#start_extent_point=} method sets the paper space location for the
    # start of the dimension line.
    # 
    # _@param_ `start_extent`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # start_ext_point = Geom::Point2d.new(2, 3)
    # dim.start_extent_point = start_ext_point
    # ```
    def start_extent_point=: (Geom::Point2d start_extent) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#start_offset_length=} method sets the length of the offset from the
    # first {Layout::ConnectionPoint} to the start of the first extension line. The
    # {Layout::ConnectionPoint} and extent point will not move.
    # 
    # _@param_ `offset_length`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # end_ext_point = Geom::Point2d.new(5, 6)
    # dim.start_offset_length = 0.5
    # ```
    def start_offset_length=: (Numeric offset_length) -> untyped

    # The {#start_offset_point} method returns the paper space location for the
    # start of the first extension line. The first extension line runs from this
    # offset point to the start extent point.
    # 
    # _@return_ — start_offset
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # start_offset = dim.start_offset_point
    # ```
    def start_offset_point: () -> Geom::Point2d

    # The {#text} method returns a copy of the {Layout::LinearDimension}'s
    # {Layout::FormattedText}.
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # text = dim.text
    # ```
    # 
    # _@note_ — With the addition of auto-text in dimensions for LayOut 2019.2, the
    # copy of the dimension text incorrectly provided the plain text when
    # requesting the display text. This has been fixed for LayOut 2020.1.
    def text: () -> Layout::FormattedText

    # sord omit - no YARD return type given, using untyped
    # The {#text=} method sets the {Layout::LinearDimension}'s
    # {Layout::FormattedText}.
    # 
    # _@param_ `formatted_text`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # height = 1.0
    # dim = Layout::LinearDimension.new(start_point, end_point, height)
    # anchor_type = Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT
    # dim.text = Layout::FormattedText.new("Hello LayOut", start_point, anchor_type)
    # ```
    def text=: (Layout::FormattedText formatted_text) -> untyped
  end

  # References an angular dimension entity. An {Layout::AngularDimension} is
  # composed of the following sub-entities:
  # - two 'extension lines' that extend from the {Layout::Entity} being
  #   dimensioned.
  # - a 'dimension line' connecting the ends of the leaders. This may be
  #   represented by one or two {Layout::Path}s depending on appearance.
  # - an optional 'leader line' that is used for small {Layout::AngularDimension}s.
  # - a 'dimension text' that displays the {Layout::AngularDimension}'s text.
  # 
  # There are seven points that may be modified for an {Layout::AngularDimension}:
  # - two 'connection points' that define the start and end of the
  #   {Layout::AngularDimension}.
  # - two 'extent points' that define the start and end of the dimension line and
  #   are the ends of the two extension lines.
  # - two 'offset points' that define the starting points of the extension lines.
  # - one 'arc center point' that defines the center of the
  #   {Layout::AngularDimension}, where the extension lines intersect.
  # 
  # @version LayOut 2018
  class AngularDimension < Layout::Entity
    LEADER_LINE_TYPE_BEZIER: untyped
    LEADER_LINE_TYPE_HIDDEN: untyped
    LEADER_LINE_TYPE_SINGLE_SEGMENT: untyped
    LEADER_LINE_TYPE_TWO_SEGMENT: untyped

    # The {#angle} method returns the {Layout::AngularDimension}'s angle. The angle
    # is represented in radians.
    # 
    # inner_angle) angle = dim.angle
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def angle: () -> Numeric

    # The {#arc_center_point} method returns the paper space location for the
    # dimension arc center point.
    # 
    # inner_angle) center = dim.arc_center_point
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def arc_center_point: () -> Geom::Point2d

    # sord omit - no YARD return type given, using untyped
    # The {#custom_text=} sets whether or not the {Layout::AngularDimension} uses
    # custom text. When +true+, the text will display a custom string that doesn't
    # change. When +false+, the text will display the length measurement and wil
    # update automatically.
    # 
    # inner_angle) dim.custom_text = true
    # 
    # _@param_ `uses_custom_text`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def custom_text=: (bool uses_custom_text) -> untyped

    # The {#custom_text?} method returns whether the {Layout::AngularDimension}
    # uses custom text. When +true+, the text will display a custom string that
    # doesn't change. When +false+, the text will display the length measurement
    # and will update automatically.
    # 
    # inner_angle) # returns false uses_custom_text = dim.custom_text?
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def custom_text?: () -> bool

    # The {#end_connection_point} method returns the paper space location for the
    # second connection.
    # 
    # inner_angle) end_connection = dim.end_connection_point
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def end_connection_point: () -> Geom::Point2d

    # sord omit - no YARD return type given, using untyped
    # The {#end_connection_point=} method sets the paper space location for the
    # second connection.
    # 
    # inner_angle) dim.end_connection_point = Geom::Point2d.new(6, 6)
    # 
    # _@param_ `end_point`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def end_connection_point=: (Geom::Point2d end_point) -> untyped

    # The {#end_extent_point} method returns the paper space location for the
    # end of the dimension line.
    # 
    # inner_angle) end_ext_point = dim.end_extent_point
    # 
    # _@return_ — end_extent
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def end_extent_point: () -> Geom::Point2d

    # sord omit - no YARD return type given, using untyped
    # The {#end_extent_point=} method sets the paper space location for the
    # end of the dimension line.
    # 
    # inner_angle) end_ext_point = Geom::Point2d.new(5, 6) dim.end_extent_point = Geom::Point2d.new(6,
    # 6)
    # 
    # _@param_ `end_extent`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def end_extent_point=: (Geom::Point2d end_extent) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#end_offset_length=} method sets the length of the offset from the
    # second connection point to the start of the second extension line. The
    # connection and extent points will not move.
    # 
    # inner_angle) end_ext_point = Geom::Point2d.new(5, 6) dim.end_offset_length = 0.5
    # 
    # _@param_ `offset_length`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def end_offset_length=: (Numeric offset_length) -> untyped

    # The {#end_offset_point} method returns the paper space location for the
    # end of the first extension line. The first extension line runs from this
    # offset point to the end extent point.
    # 
    # inner_angle) end_offset = dim.end_offset_point
    # 
    # _@return_ — end_offset
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def end_offset_point: () -> Geom::Point2d

    # The {#entities} method returns the {Layout::Entities} that represent the
    # {Layout::AngularDimension} in its exploded form. Depending on the appearance
    # of the {Layout::AngularDimension} being exploded, this may return anywhere
    # from four to six {Layout::Entity}s: start extension line, end extension line,
    # one or two dimension lines, dimension text, and optionally the leader line.
    # 
    # inner_angle) entites = dim.entities
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def entities: () -> Layout::Entities

    # The {#initialize} method creates a new disconnected
    # {Layout::AngularDimension}.
    # 
    # inner_angle)
    # 
    # _@param_ `start_point` — Where the {Layout::AngularDimension} should start
    # 
    # _@param_ `end_point` — Where the {Layout::AngularDimension} should end
    # 
    # _@param_ `start_extent_point` — The extent point where the dimension line should start
    # 
    # _@param_ `end_extent_point` — The extent point where the dimension line should end
    # 
    # _@param_ `inner_angle` — Whether or not the {Layout::AngularDimension} should measure the inner angle. If +false+, it will measure the outer angle.
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def initialize: (
                      Geom::Point2d start_point,
                      Geom::Point2d end_point,
                      Geom::Point2d start_extent_point,
                      Geom::Point2d end_extent_point,
                      bool inner_angle
                    ) -> void

    # The {#leader_line_type} method returns the type of leader line the
    # {Layout::AngularDimension} is using.
    # 
    # The leader line type can be one of the following:
    # [+Layout::AngularDimension::LEADER_LINE_TYPE_SINGLE_SEGMENT+]
    # [+Layout::AngularDimension::LEADER_LINE_TYPE_TWO_SEGMENT+]
    # [+Layout::AngularDimension::LEADER_LINE_TYPE_BEZIER+]
    # [+Layout::AngularDimension::LEADER_LINE_TYPE_HIDDEN+]
    # 
    # inner_angle) type = dim.leader_line_type
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def leader_line_type: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#leader_line_type=} method sets the type of leader line the
    # {Layout::AngularDimension} is using.
    # 
    # The leader line type can be one of the following:
    # [+Layout::AngularDimension::LEADER_LINE_TYPE_SINGLE_SEGMENT+]
    # [+Layout::AngularDimension::LEADER_LINE_TYPE_TWO_SEGMENT+]
    # [+Layout::AngularDimension::LEADER_LINE_TYPE_BEZIER+]
    # [+Layout::AngularDimension::LEADER_LINE_TYPE_HIDDEN+]
    # 
    # inner_angle) dim.leader_line_type = Layout::AngularDimension::LEADER_LINE_TYPE_BEZIER
    # 
    # _@param_ `type` — The leader line type
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def leader_line_type=: (Integer _type) -> untyped

    # The {#radius} method returns the {Layout::AngularDimension}'s radius. This is
    # the distance from the arc center point to the dimension line.
    # 
    # inner_angle) radius = dim.radius
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def radius: () -> Numeric

    # sord omit - no YARD return type given, using untyped
    # The {#radius=} method sets the the {Layout::AngularDimension}'s radius. This
    # is the distance from the arc center point to the dimension line.
    # 
    # inner_angle) dim.radius = 2.0
    # 
    # _@param_ `radius`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def radius=: (Numeric radius) -> untyped

    # The {#start_connection_point} method returns the paper space location for the
    # first connection.
    # 
    # inner_angle) start_connection = dim.start_connection_point
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def start_connection_point: () -> Geom::Point2d

    # sord omit - no YARD return type given, using untyped
    # The {#start_connection_point=} method sets the paper space location for the
    # first connection.
    # 
    # inner_angle) dim.start_connection_point = Geom::Point2d.new(2, 2)
    # 
    # _@param_ `start_point`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def start_connection_point=: (Geom::Point2d start_point) -> untyped

    # The {#start_extent_point} method returns the paper space location for the
    # start of the dimension line.
    # 
    # inner_angle) start_ext_point = dim.start_extent_point
    # 
    # _@return_ — start_extent
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def start_extent_point: () -> Geom::Point2d

    # sord omit - no YARD return type given, using untyped
    # The {#start_extent_point=} method sets the paper space location for the
    # start of the dimension line.
    # 
    # inner_angle) start_ext_point = Geom::Point2d.new(2, 3) dim.start_extent_point =
    # Geom::Point2d.new(2, 2)
    # 
    # _@param_ `start_extent`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def start_extent_point=: (Geom::Point2d start_extent) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#start_offset_length=} method sets the length of the offset from the
    # first connection point to the start of the first extension line. The
    # connection and extent points will not move.
    # 
    # inner_angle) end_ext_point = Geom::Point2d.new(5, 6) dim.start_offset_length = 0.5
    # 
    # _@param_ `offset_length`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def start_offset_length=: (Numeric offset_length) -> untyped

    # The {#start_offset_point} method returns the paper space location for the
    # start of the first extension line. The first extension line runs from this
    # offset point to the start extent point.
    # 
    # inner_angle) start_offset = dim.start_offset_point
    # 
    # _@return_ — start_offset
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def start_offset_point: () -> Geom::Point2d

    # The {#text} method returns a copy of the {Layout::AngularDimension}'s
    # {Layout::FormattedText}.
    # 
    # inner_angle) text = dim.text
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    # 
    # _@note_ — With the addition of auto-text in dimensions for LayOut 2019.2, the
    # copy of the dimension text incorrectly provided the plain text when
    # requesting the display text. This has been fixed for LayOut 2020.1.
    def text: () -> Layout::FormattedText

    # sord omit - no YARD return type given, using untyped
    # The {#text=} method sets the {Layout::AngularDimension}'s
    # {Layout::FormattedText}.
    # 
    # inner_angle) anchor_type = Layout::FormattedText::ANCHOR_TYPE_TOP_LEFT dim.text =
    # Layout::FormattedText.new("Hello LayOut", start_point, anchor_type)
    # 
    # _@param_ `formatted_text`
    # 
    # ```ruby
    # start_point = Geom::Point2d.new(1, 1)
    # end_point = Geom::Point2d.new(5, 5)
    # start_extent = Geom::Point2d.new(1, 2)
    # end_extent = Geom::Point2d.new(5, 6)
    # inner_angle = true
    # dim = Layout::AngularDimension.new(start_point, end_point, start_extent, end_extent,
    # ```
    def text=: (Layout::FormattedText formatted_text) -> untyped
  end

  # This is raised whenever a method attempts to modify any {Layout::Entity}
  # that resides on a locked {Layout::Layer}, or when attempting to change the
  # shared attribute of a locked {Layout::Layer}.
  # 
  # @version LayOut 2018
  class LockedLayerError < ArgumentError
  end

  # This is raised whenever a method attempts to modify any {Layout::Entity}
  # that is individually locked.
  # 
  # @version LayOut 2018
  class LockedEntityError < ArgumentError
  end

  # References an auto-text definition. Some auto-text definitions are mandatory.
  # Mandatory auto-text definitions may not be removed, added, or modified.
  # 
  # A mandatory {Layout::AutoTextDefinition} is one of the following types:
  # [+Layout::AutoTextDefinition::TYPE_MODEL_GROUP_NAME+]
  # [+Layout::AutoTextDefinition::TYPE_MODEL_COMPONENT_INSTANCE_NAME+]
  # [+Layout::AutoTextDefinition::TYPE_MODEL_COMPONENT_DEFINITION_NAME+]
  # [+Layout::AutoTextDefinition::TYPE_MODEL_COMPONENT_DESCRIPTION+]
  # [+Layout::AutoTextDefinition::TYPE_MODEL_VOLUME+]
  # [+Layout::AutoTextDefinition::TYPE_MODEL_FACE_AREA+]
  # [+Layout::AutoTextDefinition::TYPE_MODEL_EDGE_LENGTH+]
  # [+Layout::AutoTextDefinition::TYPE_MODEL_COORDINATES+]
  # [+Layout::AutoTextDefinition::TYPE_MODEL_DYNAMIC_COMPONENT_ATTRIBUTE+]
  # [+Layout::AutoTextDefinition::TYPE_MODEL_CLASSIFIER_ATTRIBUTE+]
  # [+Layout::AutoTextDefinition::TYPE_MODEL_SCENE_NAME+]
  # [+Layout::AutoTextDefinition::TYPE_MODEL_SCENE_DESCRIPTION+]
  # [+Layout::AutoTextDefinition::TYPE_MODEL_SCALE+]
  # [+Layout::AutoTextDefinition::TYPE_MODEL_SECTION_NAME+]
  # [+Layout::AutoTextDefinition::TYPE_MODEL_SECTION_SYMBOL+]
  # 
  # @example
  #   doc = Layout::Document.open("C:/path/to/document.layout")
  #   definitions = doc.auto_text_definitions
  #   definitions.each { |auto_text|
  #     definitions.remove(auto_text) unless auto_text.mandatory?
  #   }
  # 
  # @version LayOut 2018
  class AutoTextDefinition
    NUMBER_STYLE_ARABIC: untyped
    NUMBER_STYLE_ARABIC_PADDED: untyped
    NUMBER_STYLE_LC_ALPHA: untyped
    NUMBER_STYLE_LC_ROMAN: untyped
    NUMBER_STYLE_UC_ALPHA: untyped
    NUMBER_STYLE_UC_ROMAN: untyped
    TYPE_CUSTOM_TEXT: untyped
    TYPE_DATE_CREATED: untyped
    TYPE_DATE_CURRENT: untyped
    TYPE_DATE_MODIFIED: untyped
    TYPE_DATE_PUBLISHED: untyped
    TYPE_FILE: untyped
    TYPE_MODEL_CLASSIFIER_ATTRIBUTE: untyped
    TYPE_MODEL_COMPONENT_DEFINITION_ATTRIBUTE: untyped
    TYPE_MODEL_COMPONENT_DEFINITION_NAME: untyped
    TYPE_MODEL_COMPONENT_DESCRIPTION: untyped
    TYPE_MODEL_COMPONENT_INSTANCE_ATTRIBUTE: untyped
    TYPE_MODEL_COMPONENT_INSTANCE_NAME: untyped
    TYPE_MODEL_COORDINATES: untyped
    TYPE_MODEL_DYNAMIC_COMPONENT_ATTRIBUTE: untyped
    TYPE_MODEL_EDGE_LENGTH: untyped
    TYPE_MODEL_FACE_AREA: untyped
    TYPE_MODEL_GROUP_NAME: untyped
    TYPE_MODEL_RATIO: untyped
    TYPE_MODEL_SCALE: untyped
    TYPE_MODEL_SCENE_DESCRIPTION: untyped
    TYPE_MODEL_SCENE_NAME: untyped
    TYPE_MODEL_SECTION_NAME: untyped
    TYPE_MODEL_SECTION_SYMBOL: untyped
    TYPE_MODEL_VOLUME: untyped
    TYPE_PAGE_COUNT: untyped
    TYPE_PAGE_NAME: untyped
    TYPE_PAGE_NUMBER: untyped
    TYPE_SEQUENCE: untyped

    # The {#==} method checks to see if the two {Layout::AutoTextDefinition}s are
    # equal. This checks whether the Ruby Objects are pointing to the same internal
    # object.
    # 
    # _@param_ `other`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # definitions.first == defs.last
    # ```
    def ==: (Layout::AutoTextDefinition other) -> bool

    # The {#custom_text} method returns the custom text of the
    # +Layout::AutoTextDefinition::TYPE_CUSTOM_TEXT+ {Layout::AutoTextDefinition}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # text = definitions.last.custom_text
    # ```
    def custom_text: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#custom_text} method sets the custom text of the
    # +Layout::AutoTextDefinition::TYPE_CUSTOM_TEXT+ {Layout::AutoTextDefinition}.
    # 
    # _@param_ `custom_text`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # definitions.last.custom_text = "Boop"
    # ```
    def custom_text=: (String custom_text) -> untyped

    # The {#date_format} method returns the date format of a
    # +Layout::AutoTextDefinition::TYPE_DATE_*+ {Layout::AutoTextDefinition}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # date_format = definitions.last.date_format
    # ```
    def date_format: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#date_format} method sets the date format of a
    # +Layout::AutoTextDefinition::TYPE_DATE_*+ {Layout::AutoTextDefinition}.
    # 
    # _@param_ `date_format`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # definitions.last.date_format = "mmddyyyy"
    # ```
    def date_format=: (String date_format) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#display_file_extension=} method sets whether the
    # +Layout::AutoTextDefinition::TYPE_FILE+ {Layout::AutoTextDefinition} displays
    # the file extension.
    # 
    # _@param_ `display_file_extension`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # definitions.last.display_file_extension = false
    # ```
    def display_file_extension=: (bool display_file_extension) -> untyped

    # The {#display_file_extension?} method returns whether the
    # +Layout::AutoTextDefinition::TYPE_FILE+ {Layout::AutoTextDefinition} displays
    # the file extension.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # show_file_extension = definitions.last.display_file_extension?
    # ```
    def display_file_extension?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#display_full_path=} method sets whether the
    # +Layout::AutoTextDefinition::TYPE_FILE+ {Layout::AutoTextDefinition} displays
    # the full path.
    # 
    # _@param_ `display_full_path`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # definitions.last.display_full_path = true
    # ```
    def display_full_path=: (bool display_full_path) -> untyped

    # The {#display_full_path?} method returns whether the
    # +Layout::AutoTextDefinition::TYPE_FILE+ {Layout::AutoTextDefinition} displays
    # the full path.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # is_full_path = definitions.last.display_full_path?
    # ```
    def display_full_path?: () -> bool

    # The {#end_page} method returns the end page for the
    # +Layout::AutoTextDefinition::TYPE_PAGE_COUNT+ {Layout::AutoTextDefinition}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page_count_def =
    #     doc.auto_text_definitions.add("PageCount", Layout::AutoTextDefinition::TYPE_PAGE_COUNT)
    # # Default end_page value is nil, meaning count to the end of the document
    # page = page_count_def.end_page
    # ```
    def end_page: () -> Layout::Page?

    # sord omit - no YARD return type given, using untyped
    # The {#end_page=} method sets the end page for the
    # +Layout::AutoTextDefinition::TYPE_PAGE_COUNT+ {Layout::AutoTextDefinition}.
    # 
    # _@param_ `page`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # page_count_def =
    #     doc.auto_text_definitions.add("PageCount", Layout::AutoTextDefinition::TYPE_PAGE_COUNT)
    # # Stop the PageCount auto-text at this newly created page instead of at the end of the document
    # page_count_def.end_page = doc.pages.add("new page")
    # ```
    def end_page=: (Layout::Page? page) -> untyped

    # The {#increment} method returns the increment value for
    # +Layout::AutoTextDefinition::TYPE_SEQUENCE+ {Layout::AutoTextDefinition}s.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # sequence_def =
    #     doc.auto_text_definitions.add("Seq1", Layout::AutoTextDefinition::TYPE_SEQUENCE)
    # # Default sequence increment value is 1
    # increment = sequence_def.increment
    # ```
    def increment: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#increment=} method sets the increment value for
    # +Layout::AutoTextDefinition::TYPE_SEQUENCE+ {Layout::AutoTextDefinition}s.
    # 
    # _@param_ `increment`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # sequence_def =
    #     doc.auto_text_definitions.add("Seq1", Layout::AutoTextDefinition::TYPE_SEQUENCE)
    # sequence_def.increment = 10
    # ```
    def increment=: (Integer increment) -> untyped

    # The {#mandatory?} method returns whether the {Layout::AutoTextDefinition} is
    # mandatory or not.
    # 
    # A mandatory {Layout::AutoTextDefinition} is one of the following types:
    # [+Layout::AutoTextDefinition::TYPE_MODEL_GROUP_NAME+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_COMPONENT_INSTANCE_NAME+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_COMPONENT_DEFINITION_NAME+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_COMPONENT_DESCRIPTION+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_VOLUME+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_FACE_AREA+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_EDGE_LENGTH+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_COORDINATES+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_DYNAMIC_COMPONENT_ATTRIBUTE+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_CLASSIFIER_ATTRIBUTE+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_SCENE_NAME+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_SCENE_DESCRIPTION+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_SCALE+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_SECTION_NAME+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_SECTION_SYMBOL+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # definitions.each { |auto_text|
    #   definitions.remove(auto_text) unless auto_text.mandatory?
    # }
    # ```
    def mandatory?: () -> bool

    # The {#name} method returns the name of the {Layout::AutoTextDefinition}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # name = definitions.first.name
    # ```
    def name: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#name=} method sets the name of the {Layout::AutoTextDefinition}.
    # 
    # _@param_ `name`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # definitions.last.name = "New Name"
    # ```
    def name=: (String name) -> untyped

    # The {#number_style} method returns the numbering style for
    # +Layout::AutoTextDefinition::TYPE_PAGE_NUMBER+,
    # +Layout::AutoTextDefinition::TYPE_PAGE_COUNT+, and
    # +Layout::AutoTextDefinition::TYPE_SEQUENCE+ {Layout::AutoTextDefinition}s.
    # 
    # The numbering style can be one of the following values:
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_ARABIC+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_ARABIC_PADDED+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_UC_ALPHA+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_LC_ALPHA+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_UC_ROMAN+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_LC_ROMAN+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # sequence_def = doc.auto_text_definitions.add("Seq1", Layout::AutoTextDefinition::TYPE_SEQUENCE)
    # number_style = sequence_def.number_style
    # ```
    def number_style: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#number_style=} method sets the numbering style for
    # +Layout::AutoTextDefinition::TYPE_PAGE_NUMBER+,
    # +Layout::AutoTextDefinition::TYPE_PAGE_COUNT+, and
    # +Layout::AutoTextDefinition::TYPE_SEQUENCE+ {Layout::AutoTextDefinition}s.
    # 
    # The numbering style can be one of the following values:
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_ARABIC+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_ARABIC_PADDED+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_UC_ALPHA+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_LC_ALPHA+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_UC_ROMAN+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_LC_ROMAN+]
    # 
    # _@param_ `number_style`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # sequence_def = doc.auto_text_definitions.add("Seq1", Layout::AutoTextDefinition::TYPE_SEQUENCE)
    # sequence_def.number_style = Layout::AutoTextDefinition::NUMBER_STYLE_UC_ROMAN
    # ```
    def number_style=: (Integer number_style) -> untyped

    # The {#page_number_style} method returns the numbering style for
    # +Layout::AutoTextDefinition::TYPE_PAGE_NUMBER+ {Layout::AutoTextDefinition}s.
    # 
    # The numbering style can be one of the following values:
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_ARABIC+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_ARABIC_PADDED+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_UC_ALPHA+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_LC_ALPHA+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_UC_ROMAN+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_LC_ROMAN+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page_number_def = doc.auto_text_definitions.add("RomanPageNumbers",
    #   Layout::AutoTextDefinition::TYPE_PAGE_NUMBER) number_style = page_number_def.number_style
    # ```
    # 
    # _@deprecated_ — LayOut 2022.0 This method is deprecated in favor of the more generic {#number_style}
    # method that also works on +Layout::AutoTextDefintion::TYPE_PAGE_COUNT+ and
    # +Layout::AutoTextDefintion::TYPE_SEQUENCE+ {Layout::AutoTextDefinition}s.
    def page_number_style: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#page_number_style=} method sets the numbering style for
    # +Layout::AutoTextDefinition::TYPE_PAGE_NUMBER+ {Layout::AutoTextDefinition}s.
    # 
    # The numbering style can be one of the following values:
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_ARABIC+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_ARABIC_PADDED+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_UC_ALPHA+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_LC_ALPHA+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_UC_ROMAN+]
    # [+Layout::AutoTextDefinition::NUMBER_STYLE_LC_ROMAN+]
    # 
    # _@param_ `number_style`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page_number_def = doc.auto_text_definitions.add("RomanPageNumbers",
    #   Layout::AutoTextDefinition::TYPE_PAGE_NUMBER)
    # page_number_def.page_number_style = Layout::AutoTextDefinition::NUMBER_STYLE_UC_ROMAN
    # ```
    # 
    # _@deprecated_ — LayOut 2022.0 This method is deprecated in favor of the more generic {#number_style=}
    # method that also works on +Layout::AutoTextDefintion::TYPE_PAGE_COUNT+ and
    # +Layout::AutoTextDefintion::TYPE_SEQUENCE+ {Layout::AutoTextDefinition}s.
    def page_number_style=: (Integer number_style) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#renumber} method iterates through all uses of the
    # +Layout::AutoTextDefinition::TYPE_SEQUENCE+ {Layout::AutoTextDefinition} and eliminates gaps and
    # duplicates in the sequence.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # sequence_def =
    #     doc.auto_text_definitions.add("Seq1", Layout::AutoTextDefinition::TYPE_SEQUENCE)
    # sequence_def.renumber
    # ```
    def renumber: () -> untyped

    # The {#sequence_format} method returns the sequence format of a
    # +Layout::AutoTextDefinition::TYPE_SEQUENCE+ {Layout::AutoTextDefinition}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # sequence_def =
    #     doc.auto_text_definitions.add("Seq1", Layout::AutoTextDefinition::TYPE_SEQUENCE)
    # # Default sequence format is ###, meaning entirely replace the string with the sequence number
    # sequence = sequence_def.sequence
    # ```
    def sequence_format: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#sequence_format=} method sets the sequence format of a
    # +Layout::AutoTextDefinition::TYPE_SEQUENCE+ {Layout::AutoTextDefinition}.
    # 
    # _@param_ `sequence_format`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # sequence_def =
    #     doc.auto_text_definitions.add("Seq1", Layout::AutoTextDefinition::TYPE_SEQUENCE)
    # sequence_def.sequence = "Figure ###"
    # ```
    def sequence_format=: (String sequence_format) -> untyped

    # The {#start_index} method returns the start index for
    # +Layout::AutoTextDefinition::TYPE_PAGE_NUMBER+,
    # +Layout::AutoTextDefinition::TYPE_PAGE_COUNT+, and
    # +Layout::AutoTextDefinition::TYPE_SEQUENCE+ {Layout::AutoTextDefinition}s.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # sequence_def = doc.auto_text_definitions.add("Seq1", Layout::AutoTextDefinition::TYPE_SEQUENCE)
    # start_index = sequence_def.start_index
    # ```
    def start_index: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#start_index=} method sets the start index for
    # +Layout::AutoTextDefinition::TYPE_PAGE_NUMBER+,
    # +Layout::AutoTextDefinition::TYPE_PAGE_COUNT+, and
    # +Layout::AutoTextDefinition::TYPE_SEQUENCE+ {Layout::AutoTextDefinition}s.
    # 
    # _@param_ `index`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # sequence_def = doc.auto_text_definitions.add("Seq1", Layout::AutoTextDefinition::TYPE_SEQUENCE)
    # sequence_def.start_index = 10
    # ```
    def start_index=: (Integer index) -> untyped

    # The {#start_page} method returns the start page for
    # +Layout::AutoTextDefinition::TYPE_PAGE_NUMBER+ and
    # +Layout::AutoTextDefinition::TYPE_PAGE_COUNT+ {Layout::AutoTextDefinition}s.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page_number_def =
    #     doc.auto_text_definitions.add("PageNumber", Layout::AutoTextDefinition::TYPE_PAGE_NUMBER)
    # # Default start page is the first page of the document. However we continue to start at that
    # # page even if that page is moved.
    # page = page_number_def.start_page
    # p page == doc.pages[0]
    # doc.pages.add('new page')
    # doc.pages.reorder(doc.pages[0], 1)
    # p page == doc.pages[1]
    # ```
    def start_page: () -> Layout::Page

    # sord omit - no YARD return type given, using untyped
    # The {#start_page=} method sets the start page for
    # +Layout::AutoTextDefinition::TYPE_PAGE_NUMBER+ and
    # +Layout::AutoTextDefinition::TYPE_PAGE_COUNT+ {Layout::AutoTextDefinition}s.
    # 
    # _@param_ `page`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # page_number_def =
    #     doc.auto_text_definitions.add("PageNumber", Layout::AutoTextDefinition::TYPE_PAGE_NUMBER)
    # # Start the PageCount auto-text on the new page
    # page_number_def.start_page = doc.pages.add('new page')
    # ```
    def start_page=: (Layout::Page page) -> untyped

    # The {#tag} method returns the tag string of the {Layout::AutoTextDefinition}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # tag = definitions.first.tag
    # ```
    def tag: () -> String

    # The {#type} method returns the type of the {Layout::AutoTextDefinition}.
    # 
    # The type can be one of the following values:
    # [+Layout::AutoTextDefinition::TYPE_FILE+]
    # [+Layout::AutoTextDefinition::TYPE_PAGE_NAME+]
    # [+Layout::AutoTextDefinition::TYPE_PAGE_NUMBER+]
    # [+Layout::AutoTextDefinition::TYPE_CUSTOM_TEXT+]
    # [+Layout::AutoTextDefinition::TYPE_DATE_CURRENT+]
    # [+Layout::AutoTextDefinition::TYPE_DATE_CREATED+]
    # [+Layout::AutoTextDefinition::TYPE_DATE_MODIFIED+]
    # [+Layout::AutoTextDefinition::TYPE_DATE_PUBLISHED+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_GROUP_NAME+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_COMPONENT_INSTANCE_NAME+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_COMPONENT_DEFINITION_NAME+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_COMPONENT_DESCRIPTION+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_VOLUME+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_FACE_AREA+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_EDGE_LENGTH+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_COORDINATES+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_DYNAMIC_COMPONENT_ATTRIBUTE+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_CLASSIFIER_ATTRIBUTE+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_SCENE_NAME+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_SCENE_DESCRIPTION+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_SCALE+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_SECTION_NAME+]
    # [+Layout::AutoTextDefinition::TYPE_MODEL_SECTION_SYMBOL+]
    # [+Layout::AutoTextDefinition::TYPE_PAGE_COUNT+]
    # [+Layout::AutoTextDefinition::TYPE_SEQUENCE+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # definitions = doc.auto_text_definitions
    # type = definitions.first.type
    # ```
    def type: () -> Integer
  end

  # The AutoTextDefinitions class is a container class for all
  # {Layout::AutoTextDefinition}s in a {Layout::Document}.
  # 
  # @example
  #   # Grab a handle to an existing LayOut document's auto-text definitions.
  #   doc = Layout::Document.open("C:/path/to/document.layout")
  #   auto_texts = doc.auto_text_definitions
  # 
  #   # From here, we can add auto-text definitions to or remove them from the
  #   # document.
  #   auto_texts.add("PageNum", Layout::AutoTextDefinition::TYPE_PAGE_NUM)
  #   auto_texts.remove("PageNum")
  # 
  # @version LayOut 2018
  class AutoTextDefinitions
    include Enumerable[AutoTextDefinition]

    # sord omit - no YARD type given for "index", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#[]} method returns a value from the array of
    # {Layout::AutoTextDefinition}s.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # auto_texts = doc.auto_text_definitions
    # auto_text = auto_texts[2]
    # ```
    def []: (untyped index) -> untyped

    # The {#add} method adds an {Layout::AutoTextDefinition} to the
    # {Layout::Document}.
    # 
    # The type can be one of the following values:
    # [+Layout::AutoTextDefinition::TYPE_FILE+]
    # [+Layout::AutoTextDefinition::TYPE_PAGE_NAME+]
    # [+Layout::AutoTextDefinition::TYPE_PAGE_NUMBER+]
    # [+Layout::AutoTextDefinition::TYPE_CUSTOM_TEXT+]
    # [+Layout::AutoTextDefinition::TYPE_DATE_CURRENT+]
    # [+Layout::AutoTextDefinition::TYPE_DATE_CREATED+]
    # [+Layout::AutoTextDefinition::TYPE_DATE_MODIFIED+]
    # [+Layout::AutoTextDefinition::TYPE_DATE_PUBLISHED+]
    # [+Layout::AutoTextDefinition::TYPE_PAGE_COUNT+]
    # [+Layout::AutoTextDefinition::TYPE_SEQUENCE+]
    # 
    # _@param_ `name`
    # 
    # _@param_ `type`
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # doc.auto_text_definitions.add("current date",
    #    Layout::AutoTextDefinition::TYPE_DATE_CURRENT);
    # ```
    def add: (String name, Integer _type) -> Layout::AutoTextDefinition

    # sord omit - no YARD return type given, using untyped
    # The {#each} method iterates through all of the {Layout::AutoTextDefinition}s.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # auto_texts = doc.auto_text_definitions
    # auto_texts.each { |auto_text|
    #   puts auto_text.name
    # }
    # ```
    # 
    # _@note_ — Don't remove content from this collection while iterating over it with
    # {#each}. This would change the size of the collection and cause elements to
    # be skipped as the indices change. Instead copy the current collection to an
    # array using +to_a+ and then use +each+ on the array, when removing content.
    def each: () ?{ (Layout::AutoTextDefinition auto_text) -> void } -> untyped

    # sord omit - no YARD type given for "auto_text", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#index} method returns the index of the {Layout::AutoTextDefinition},
    # or +nil+ if it doesn't exist in the {Layout::Document}.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # auto_texts = doc.auto_text_definitions
    # index = auto_texts.index(definitions.first) # Returns 0
    # ```
    def index: (untyped auto_text) -> untyped

    # The {#length} method returns the number of {Layout::AutoTextDefinition}s.
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # auto_texts = doc.auto_text_definitions
    # num_auto_texts = auto_texts.length
    # ```
    def length: () -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#remove} method removes an {Layout::AutoTextDefinition} from the
    # {Layout::Document}.
    # 
    # The {Layout::AutoTextDefinition} must be one of the following types:
    # [+Layout::AutoTextDefinition::TYPE_FILE+]
    # [+Layout::AutoTextDefinition::TYPE_PAGE_NAME+]
    # [+Layout::AutoTextDefinition::TYPE_PAGE_NUMBER+]
    # [+Layout::AutoTextDefinition::TYPE_CUSTOM_TEXT+]
    # [+Layout::AutoTextDefinition::TYPE_DATE_CURRENT+]
    # [+Layout::AutoTextDefinition::TYPE_DATE_CREATED+]
    # [+Layout::AutoTextDefinition::TYPE_DATE_MODIFIED+]
    # [+Layout::AutoTextDefinition::TYPE_DATE_PUBLISHED+]
    # [+Layout::AutoTextDefinition::TYPE_PAGE_COUNT+]
    # [+Layout::AutoTextDefinition::TYPE_SEQUENCE+]
    # 
    # ```ruby
    # doc = Layout::Document.open("C:/path/to/document.layout")
    # auto_texts = doc.auto_text_definitions
    # auto_texts.remove(auto_texts[10], true)
    # ```
    def remove: (*untyped args) -> untyped
  end
end

# Because length units are used so often in SketchUp, a special class has been
# added to make it easier to work with length values. You can use a Length
# object any place that you would use a Float.
# 
# Internally, all lengths in SketchUp are stored in inches. The Length class
# stores values in inches as well. A number of methods have been added to the
# Ruby Numeric class to do units conversions.
# 
# The setting for the Length Format and Length Unit can be retrieved from the
# {Sketchup::Model#options} by querying the +"UnitsOptions"+
# {Sketchup::OptionsProvider} for +"LengthFormat"+ and +"LengthUnit"+
# respectively.
# 
# *Constants:*
# 
# [Length Format]
#   - +Length::Decimal+
#   - +Length::Architectural+
#   - +Length::Engineering+
#   - +Length::Fractional+
# 
# [Length Unit]
#   - +Length::Inches+
#   - +Length::Feet+
#   - +Length::Millimeter+
#   - +Length::Centimeter+
#   - +Length::Meter+
#   (Added in SketchUp 2020.0)
#   - +Length::Yard+
# 
# [Area Unit]
#   (Added in SketchUp 2019.2)
#   - +Length::SquareInches+
#   - +Length::SquareFeet+
#   - +Length::SquareMillimeter+
#   - +Length::SquareCentimeter+
#   - +Length::SquareMeter+
#   (Added in SketchUp 2020.0)
#   - +Length::SquareYard+
# 
# [Volume Unit]
#   (Added in SketchUp 2019.2)
#   - +Length::CubicInches+
#   - +Length::CubicFeet+
#   - +Length::CubicMillimeter+
#   - +Length::CubicCentimeter+
#   - +Length::CubicMeter+
#   (Added in SketchUp 2020.0)
#   - +Length::CubicYard+
#   - +Length::Liter+
#   - +Length::USGallon+
# 
# @note Prior to SketchUp 2015, +Length+ used to be derived from +Float+. This
#   is no longer the case.
# 
# @version SketchUp 6.0
class Length < Float
  Architectural: untyped
  Centimeter: untyped
  CubicCentimeter: untyped
  CubicFeet: untyped
  CubicInches: untyped
  CubicMeter: untyped
  CubicMillimeter: untyped
  CubicYard: untyped
  Decimal: untyped
  Engineering: untyped
  Fractional: untyped
  Feet: untyped
  Inches: untyped
  Liter: untyped
  Millimeter: untyped
  Meter: untyped
  SquareCentimeter: untyped
  SquareFeet: untyped
  SquareInches: untyped
  SquareMeter: untyped
  SquareMillimeter: untyped
  SquareYard: untyped
  USGallon: untyped
  Yard: untyped

  # The < method is used to see if one length is less than another length.
  # 
  # For example, if l1 = 1.0.inch and l2 = 1.000001.inch then l1 == l2 so l1
  # < l2 should return false.
  # 
  # _@param_ `length2` — A length value.
  # 
  # _@return_ — true if length1 is < length2; false if
  # length1 is not < length2
  # 
  # ```ruby
  # length1 = 12.to_l
  # length2 = 11.to_l
  # if length1 < length2
  #   puts "length1 is less than length2"
  # else
  #   puts "length1 is not less than length2"
  # end
  # ```
  def <: (Length length2) -> bool

  # The <= method is used to see if one length is less than or equal to
  # another length.
  # 
  # _@param_ `length2` — A length value.
  # 
  # _@return_ — true if length1 is <= length2; false if
  # length1 is not <= length2
  # 
  # ```ruby
  # length1 = 11.to_l
  # length2 = 12.to_l
  # if length1 <= length2
  #   puts "length1 is less than or equal length2"
  # else
  #   puts "length1 is greater than length2"
  # end
  # ```
  def <=: (Length length2) -> bool

  # The <=> method is used to see if one length is less than equal or greater
  # than another length. Because we change == for Length to do a test based on
  # a tolerance, we also need to change <=> to also take tolerance into account.
  # 
  # _@param_ `length2` — A length value.
  # 
  # _@return_ — the result of the comparison
  # 
  # ```ruby
  # length1 = 20.to_l
  # length2 = 30.to_l
  # result = length1 <=> length2
  # ```
  def <=>: (Length length2) -> Integer

  # The == method is used to see if one length is equal to another length.
  # 
  # The equality comparison on Length values uses the default tolerance that
  # SketchUp uses for comparing lengths.
  # 
  # _@param_ `length2` — A length value.
  # 
  # _@return_ — true if length1 is == length2; false if
  # length1 is not == length2
  # 
  # ```ruby
  # length1 = 20.to_l
  # length2 = 30.to_l
  # is_equal = length1 == length2
  # ```
  def ==: (Length length2) -> bool

  # The > method is used to see if one length is greater than another length.
  # 
  # For example, if l1 = 1.0.inch and l2 = 1.000001.inch then l1 == l2 so l1 >
  # l2 should return false.
  # 
  # _@param_ `length2` — A length value.
  # 
  # _@return_ — true if length1 is > length2; false if length1
  # is not > length2
  # 
  # ```ruby
  # length1 = 11.to_l
  # length2 = 12.to_l
  # if length1 > length2
  #   puts "length1 is greater than length2"
  # else
  #   puts "length1 is not greater than length2"
  # end
  # ```
  def >: (Length length2) -> bool

  # The >= method is used to see if one length is greater than or equal to
  # another length.
  # 
  # For example, if l1 = 1.0.inch and l2 = 1.000001.inch then l1 == l2 so l1 >=
  # l2 should return true. Also L1 <= l2 would return true.
  # 
  # _@param_ `length2` — A length value.
  # 
  # _@return_ — true if length1 is >= length2; false if
  # length1 is not >= length2
  # 
  # ```ruby
  # length1 = 11.to_l
  # length2 = 12.to_l
  # if length1 >= length2
  #   puts "length1 is greater than or equal length2"
  # else
  #   puts "length1 is less than length2"
  # end
  # ```
  def >=: (Length length2) -> bool

  # The inspect method is used to retrieve an unformatted string for the length,
  # which is the length in inches, regardless of the user's model unit settings.
  # See Length.to_s for a way automatically format your Length to the user's
  # model units.
  # 
  # _@return_ — an unformatted length string
  # 
  # ```ruby
  # length = 55.to_l
  # str = length.inspect
  # ```
  def inspect: () -> String

  # The to_f method is used to convert a length to a normal float.
  # 
  # _@return_ — the float length value
  # 
  # ```ruby
  # length = 45.to_l
  # f = length.to_f
  # ```
  def to_f: () -> Float

  # Format a length as a String using the current units formatting settings
  # for the model. (So if the user's model is set to feet, this method will
  # return a nicely formatted length in feet.)
  # 
  # _@return_ — the float length value
  # 
  # ```ruby
  # length = 55.to_l
  # str = length.to_s
  # ```
  def to_s: () -> String
end

# The String class contains a method used to parse a string as a length value.
# All string arguments in Ruby API expect utf-8 strings.
# 
# @version SketchUp 6.0
class String
  # The to_l method is used to convert a string to a length. The returned length
  # is expressed in the Model units.
  # 
  # _@return_ — the length value
  # 
  # ```ruby
  # length = "5'".to_l
  # ```
  def to_l: () -> Length
end

# A number of methods have been added to the Ruby Numeric class to do units
# conversions.
# 
# @version SketchUp 6.0
class Numeric
  # The cm method is used to convert from centimeters to inches.
  # 
  # _@return_ — a value in inches if successful
  # 
  # ```ruby
  # cm = 10
  # inches = cm.cm
  # ```
  def cm: () -> Length

  # The degrees method is used to convert from degrees to radians.
  # 
  # For example 90.degrees would return 1.5707963267949
  # 
  # _@return_ — a value in radians if successful
  # 
  # ```ruby
  # degrees = 90
  # radians = degrees.degrees
  # ```
  def degrees: () -> Float

  # The feet method is used to convert from feet to inches.
  # 
  # _@return_ — a value in inches if successful
  # 
  # ```ruby
  # feet = 1
  # inches = feet.feet
  # ```
  def feet: () -> Length

  # The to_l is used to convert from a number to a length.
  # 
  # _@return_ — a Length object if successful
  # 
  # ```ruby
  # number = 12
  # length = number.to_l
  # ```
  def inch: () -> Length

  # The km method is used to convert from kilometers to inches.
  # 
  # _@return_ — a value in inches if successful
  # 
  # ```ruby
  # value = 1
  # inches = value.km
  # ```
  def km: () -> Length

  # The m method is used to convert from meters to inches.
  # 
  # _@return_ — a value in inches if successful
  # 
  # ```ruby
  # meters = 1
  # inches = meters.m
  # ```
  def m: () -> Length

  # The mile method is used to convert from miles to inches.
  # 
  # _@return_ — a value in inches if successful
  # 
  # ```ruby
  # miles = 1
  # inches = miles.mile
  # ```
  def mile: () -> Length

  # The mm method is used to convert from millimeters to inches.
  # 
  # It returns a Length value which is the same length as the given value. For
  # example len = 25.4.mm returns 1 inch.
  # 
  # _@return_ — a value in millimeters if successful
  # 
  # ```ruby
  # value = 10
  # mm = value.mm
  # ```
  def mm: () -> Length

  # The radians method is used to convert from radians to degrees.
  # 
  # For example, 1.5707963267949.radians would return 90.0
  # 
  # _@return_ — a value in degrees if successful
  # 
  # ```ruby
  # radians = 1.5707963267949
  # degrees = radians.radians
  # ```
  def radians: () -> Float

  # The to_cm method is used to convert from inches to centimeters.
  # 
  # _@return_ — a value in centimeters if successful
  # 
  # ```ruby
  # inches = 1
  # cm = inches.to_cm
  # ```
  def to_cm: () -> Float

  # The to_feet method is used to convert from inches to feet.
  # 
  # _@return_ — a value in feet if successful
  # 
  # ```ruby
  # inches = 12
  # feet = inches.to_feet
  # ```
  def to_feet: () -> Float

  # The to_inch method converts from inches to inches.
  # 
  # This does not change the value.
  # 
  # _@return_ — a value in inches if successful
  # 
  # ```ruby
  # inches = 12
  # inches = inches.to_inch
  # ```
  def to_inch: () -> Float

  # The to_km method is used to convert from inches to kilometers.
  # 
  # _@return_ — a value in kilometers if successful
  # 
  # ```ruby
  # inches = 1
  # km = inches.to_km
  # ```
  def to_km: () -> Float

  # The to_l is used to convert from a number to a length.
  # 
  # _@return_ — a Length object if successful
  # 
  # ```ruby
  # number = 12
  # length = number.to_l
  # ```
  def to_l: () -> Length

  # The to_m method is used to convert from inches to meters.
  # 
  # _@return_ — a value in meters if successful
  # 
  # ```ruby
  # inches = 12
  # meters = inches.to_m
  # ```
  def to_m: () -> Float

  # The to_mile method is used to convert from inches to miles.
  # 
  # _@return_ — a value in miles if successful
  # 
  # ```ruby
  # inches = 10000
  # miles = inches.to_mile
  # ```
  def to_mile: () -> Float

  # The to_mm method is used to convert from inches to millimeters.
  # 
  # _@return_ — a value in millimeters if successful
  # 
  # ```ruby
  # inches = 1
  # mm = inches.to_mm
  # ```
  def to_mm: () -> Float

  # The to_yard method is used to convert from inches to yards.
  # 
  # _@return_ — a value in yards if successful
  # 
  # ```ruby
  # inches = 10000
  # yards = inches.to_yard
  # ```
  def to_yard: () -> Float

  # The yard method is used to convert from yards to inches.
  # 
  # _@return_ — a value in inches if successful
  # 
  # ```ruby
  # yards = 1.to_l
  # inches = yards.yard
  # ```
  def yard: () -> Length
end

# The Sketchup module contains a number of important utility methods for use in
# your Ruby scripts. Many of the classes in the API are implemented beneath
# this module. You can think of the Sketchup module as the "root" of the
# application tree. Most ruby calls start from the currently active model, and
# this is accessed via the Sketchup.active_model method.
# 
# @example
#   # Grab a handle to the currently active model (aka the one the user is
#   # looking at in SketchUp.)
#   model = Sketchup.active_model
# 
#   # Grab other handles to commonly used collections inside the model.
#   entities = model.entities
#   layers = model.layers
#   materials = model.materials
#   component_definitions = model.definitions
#   selection = model.selection
# 
#   # Now that we have our handles, we can start pulling objects and making
#   # method calls that are useful.
#   first_entity = entities[0]
#   UI.messagebox("First thing in your model is a " + first_entity.typename)
# 
#   number_materials = materials.length
#   UI.messagebox("Your model has " + number_materials.to_s + " materials.")
# 
#   new_edge = entities.add_line( [0,0,0], [500,500,0])
# 
# @version SketchUp 6.0
module Sketchup
  # The active_model method returns the currently active SketchUp model. On the
  # PC, this is the only model that one can have access to via the API, but
  # Macintosh versions of SketchUp can have multiple models open at once, in
  # which case the method will return the model that the user currently has
  # focused.
  # 
  # _@return_ — active model object if successful, false if
  # unsuccessful
  # 
  # ```ruby
  # model = Sketchup.active_model
  # if !model
  #   UI.messagebox("Failure")
  # else
  #   # code acting on the model
  # end
  # ```
  def self.active_model: () -> Sketchup::Model

  # The add_observer method is used to add an observer to the current object.
  # 
  # _@param_ `observer` — An observer.
  # 
  # _@return_ — true if successful, false if unsuccessful.
  # 
  # ```ruby
  # status = Sketchup.add_observer(observer)
  # ```
  def self.add_observer: (Object observer) -> bool

  # The app_name method is used to retrieve the current application name.
  # 
  # _@return_ — the name of the application, either
  # "SketchUp Pro" or "SketchUp".
  # Note: For versions earlier than SketchUp8 M4
  # (Mac 8.0.15157 and Windows 8.0.15158) this function will
  # return "Google SketchUp Pro" or "Google SketchUp".
  # 
  # ```ruby
  # name = Sketchup.app_name
  # ```
  def self.app_name: () -> String

  # The break_edges= method can be used to disable or enable the break edges
  # feature. Break edges is the SketchUp 7 feature that automatically splits
  # edges that the user draws which cross over one another.
  # 
  # This feature is always on by default and cannot be disabled by the user
  # via the user interface, but you can call this method to disable it. Be
  # cautious in doing so, however, as the resulting model could then be altered
  # when the user later draws lines into it with the break edges feature
  # reactivated.
  # 
  # _@param_ `enabled` — If true, break edges will be turned on. If false, it will be deactivated.
  # 
  # _@return_ — true if break edges was turned on.
  # 
  # ```ruby
  # Sketchup.break_edges = false
  # ```
  def self.break_edges=: (bool enabled) -> bool

  # The break_edges? method indicates whether the break edges feature is
  # currently turned on. Break edges is the SketchUp 7 feature that
  # automatically splits edges that the user draws which cross over one another.
  # This feature is always on by default and cannot be disabled by the user
  # via the user interface.
  # 
  # ```ruby
  # is_on = Sketchup.break_edges?
  # ```
  def self.break_edges?: () -> bool

  # The create_texture_writer method is used to create a TextureWriter object.
  # 
  # _@return_ — a texturewriter object if successful.
  # 
  # ```ruby
  # texturewriter = Sketchup.create_texture_writer
  # ```
  def self.create_texture_writer: () -> Sketchup::TextureWriter

  # The debug_mode= method lets you controls whether SketchUp will output
  # warnings to the console when it detects incorrect usage of the API.
  # The setting takes effect right away, no need to restart SketchUp.
  # 
  # _@param_ `enabled` — If true, SketchUp will produce debug warnings.
  # 
  # ```ruby
  # Sketchup.debug_mode = true
  # ```
  # 
  # _@note_ — Changing this value within your extension can cause problems for other
  # extension developers who rely on the debug information for their own work.
  # Only use this locally; never change this value in an extension you
  # publish.
  def self.debug_mode=: (bool enabled) -> bool

  # The debug_mode? controls whether SketchUp will output warnings to the console
  # when it detects incorrect usage of the API.
  # 
  # ```ruby
  # debug_mode = Sketchup.debug_mode?
  # ```
  def self.debug_mode?: () -> bool

  # The display_name_from_action method is used to gets a user-friendly name
  # from an action string. See Sketchup.send_action for a list of valid
  # action strings.
  # 
  # _@param_ `action_name` — An action string.
  # 
  # _@return_ — a friendly name.
  # 
  # ```ruby
  # Sketchup.display_name_from_action("viewRight:")
  # ```
  # 
  # _@note_ — This method has been non-functional on Mac since SketchUp 8.
  def self.display_name_from_action: (String action_name) -> String

  # Returns the ExtensionsManager where you can find all registered
  # SketchupExtension objects.
  # 
  # #{extension.loaded?}"
  #   }
  # 
  # _@return_ — an ExtensionsManager object.
  # 
  # ```ruby
  # extensions = Sketchup.extensions
  # extensions.each{ |extension|
  #   puts "The next extension is named: #{extension.name} and its loaded? state is:
  # ```
  def self.extensions: () -> Sketchup::ExtensionsManager

  # The file_new method is used to create a new file.
  # 
  # _@return_ — The Sketchup module.
  # 
  # ```ruby
  # new_sketchup = Sketchup.file_new
  # ```
  def self.file_new: () -> Module

  # The find_support_files method is used to retrieve the relative path and name
  # of a file within the SketchUp installation directory.
  # 
  # Forward slashes must be used to delimit between directory names.
  # 
  # _@param_ `filename` — Name of the filename you want to find.
  # 
  # _@param_ `directory` — directory relative to the SketchUp installation directory.
  # 
  # _@return_ — the entire path if successful. If unsuccessful,
  # the method returns false.
  # 
  # ```ruby
  # help_file = Sketchup.find_support_file("help.html", "Plugins/")
  # if help_file
  #   # Print out the help_file full path
  #   UI.messagebox(help_file)
  # 
  #   # Open the help_file in a web browser
  #   UI.openURL("file://" + help_file)
  # else
  #   UI.messagebox("Failure")
  # end
  # ```
  def self.find_support_file: (String filename, String directory) -> String

  # The find_support_files method is used to retrieve the path and name of all
  # matching files within the SketchUp installation directory.
  # 
  # Forward slashes must be used to delimit between directory names.
  # 
  # _@param_ `filename` — Extension of the files to be found.
  # 
  # _@param_ `directory` — directory relative to the SketchUp installation directory. Without this the result will be empty.
  # 
  # _@return_ — an array of files. If unsuccessful, the method
  # returns false.
  # 
  # ```ruby
  # files = Sketchup.find_support_files('rb', 'Plugins')
  # ```
  def self.find_support_files: (String filename, String directory) -> ::Array[String]

  # The fix_shadow_strings= method lets you control whether shadow rendering
  # attempts to fix an artifact commonly referred to as "strings".  The fix
  # is actually very model dependent and not controllable from the UI, so this
  # method can be used to control it.
  # 
  # _@param_ `enabled` — If true, shadow strings fix will be turned on. If false, it will be deactivated.
  # 
  # _@return_ — true if shadow strings fix was turned on.
  # 
  # ```ruby
  # Sketchup.fix_shadow_strings = true
  # ```
  def self.fix_shadow_strings=: (bool enabled) -> bool

  # The fix_shadow_strings? method indicates whether the a fix for a shadow
  # rendering artifact commonly referred to as "strings" is enabled.  The fix
  # is actually very model dependent and not controllable from the UI, so this
  # method can be used to test it.
  # 
  # ```ruby
  # is_on = Sketchup.fix_shadow_strings?
  # ```
  def self.fix_shadow_strings?: () -> bool

  # sord omit - no YARD return type given, using untyped
  # The {.focus} method is used to focus the active model window.
  # 
  # ```ruby
  # Sketchup.focus
  # ```
  # 
  # _@see_ `UI::HtmlDialog.bring_to_front`
  def self.focus: () -> untyped

  # The format_angle method takes a number as an angle in radians and formats it
  # into degrees. For example, format_angle(Math::PI) will return 180.0.
  # 
  # _@param_ `number` — A number to be formatted.
  # 
  # _@return_ — an angle in degrees if successful, false if unsuccessful
  # 
  # ```ruby
  # degrees = Sketchup.format_angle(Math::PI)
  # ```
  def self.format_angle: (Numeric number) -> String

  # The {.format_area} method formats a number as an area using the current units
  # settings.
  # 
  # The +number+ must be in square inches.
  # 
  # _@param_ `number` — A number to be formatted.
  # 
  # ```ruby
  # number = 3.m * 4.m # This will result in 12m2 in inches.
  # formatted_area = Sketchup.format_area(number)
  # ```
  def self.format_area: (Numeric number) -> String

  # The format_degrees method formats a number as an angle given in degrees. For
  # example, 10 becomes 10.0. This is the equivalent to a to_f call.
  # 
  # _@param_ `number` — A number to be formatted.
  # 
  # _@return_ — degrees if successful, false if unsuccessful.
  # 
  # ```ruby
  # degrees = Sketchup.format_degrees(number)
  # ```
  def self.format_degrees: (Numeric number) -> String

  # sord omit - no YARD type given for "*args", using untyped
  # The {.format_length} method formats a number as a length using the current
  # units settings.
  # 
  # The default unit setting is inches. For example, 10 becomes 10".
  # 
  # ```ruby
  # length = Sketchup.format_length(10)
  # ```
  def self.format_length: (*untyped args) -> String

  # The {.format_volume} method formats a number as a volume using the current
  # units settings.
  # 
  # The +number+ must be in cubic inches.
  # 
  # _@param_ `number` — A number to be formatted.
  # 
  # ```ruby
  # number = 3.m * 4.m * 5.m # This will result in 60m3 in inches.
  # formatted_volume = Sketchup.format_area(number)
  # ```
  def self.format_volume: (Numeric number) -> String

  # The get_datfile_info method is used to retrieve the value for the given key
  # from Sketchup.dat.
  # 
  # If the key is not found, default_value is returned.
  # 
  # _@param_ `key` — The key whose value you want to retrieve.
  # 
  # _@param_ `default_value` — The default value you want returned if key is not available.
  # 
  # _@return_ — a string value if successful.
  # 
  # ```ruby
  # value = Sketchup.get_datfile_info(key, default_value)
  # ```
  def self.get_datfile_info: (String key, String default_value) -> String

  # The {.get_i18n_datfile_info} method is used to retrieve the value for the
  # given key from the internationalization file that SketchUp uses to work
  # in multiple languages.
  # 
  # If the +key+ is not found, +default_value+ is returned.
  # 
  # _@param_ `key` — The key whose value you want to retrieve.
  # 
  # _@param_ `default_value` — The default value you want returned if key is not available.
  # 
  # ```ruby
  # value = Sketchup.get_i18n_datfile_info(key, default_value)
  # ```
  def self.get_i18n_datfile_info: (String key, String default_value) -> String

  # The os_language method returns the language code for the language SketchUp
  # is running in. This is an alias for the get_locale method.
  # 
  # Examples of return values are: en-US, fr, it, de, es, ja, ko, zh-CN, zh-TW,
  # pt-BR, nl, ru and sv. For an up to date list os supported languages, see
  # the SketchUp download page.
  # 
  # _@return_ — a code representing the language SketchUp
  # is displaying.
  # 
  # ```ruby
  # language = Sketchup.os_language
  # ```
  def self.get_locale: () -> String

  # The get_resource_path is used to retrieve the directory where "resource"
  # files are stored by SketchUp. Resource files include things like language
  # localization files.
  # 
  # _@param_ `filename` — The filename of a resource file in the resource directory hierarchy.
  # 
  # _@return_ — the directory path to the resources folder.
  # 
  # ```ruby
  # directory = Sketchup.get_resource_path("Styles.strings")
  # ```
  def self.get_resource_path: (String filename) -> String

  # The get_shortcuts method retrieves an array of all keyboard shortcuts
  # currently registered with SketchUp. Each shortcut is returned as a
  # string with the shortcut and the command separated by a tab, similar
  # to "Ctrl+A\\tEdit/Select All"
  # 
  # _@return_ — an array of shortcut strings.
  # 
  # ```ruby
  # shortcuts = Sketchup.get_shortcuts
  # ```
  def self.get_shortcuts: () -> ::Array[String]

  # Installs the contents of a ZIP archive file into SketchUp's Plugins folder.
  # If the ZIP contains subfolders, these will be preserved. This allows for a
  # Ruby API plugin or Extension developer to distribute their plugin as a single
  # file regardless of how many asset files must be included.
  # 
  # The user will be shown a warning message that they must agree to before the
  # install proceeds. If they do not agree, an Interrupt error will be raised.
  # If the user does agree but there is a problem with the unzip process, an
  # Exception will be raised. You can capture these states via a begin/rescue.
  # See the example below.
  # 
  # If the install is successful, any Ruby files that have been added to
  # the Plugins folder will immediately be executed, saving the user a restart.
  # 
  # To create an archive file, use your favorite tool (7zip, Winzip, etc.) to zip
  # up any files and folders in your plugins directory. If the archive contains a
  # SketchupExtension that you would like users to be able to install from the
  # Preferences > Extensions panel, rename your file to have a .rbz file
  # extension.
  # 
  # _@param_ `filepath` — The path to the RBZ or ZIP file to install.
  # 
  # _@param_ `show_warning` — Whether to warn the user not to install untrusted extensions. In certain cases the warning can be confusing and redundant, e.g. when automatically updating a trusted extension. When the user has selected the archive themselves, it is best to warn about the possible risks.
  # 
  # ```ruby
  # path = 'c:/temp/SomePluginPackage.zip'
  # begin
  #   Sketchup.install_from_archive(path)
  # rescue Interrupt => error
  #   UI.messagebox("User said 'no': " + error)
  # rescue Exception => error
  #   UI.messagebox("Error during unzip: " + error)
  # end
  # ```
  def self.install_from_archive: (String filepath, ?bool show_warning) -> bool

  # This methods indicates whether the host SketchUp application is 64bit.
  # Useful for extensions that ship with binaries and need to determine
  # which versions to load.
  # 
  # ```ruby
  # # For backward compatibility, check for the existence of the method
  # # and load 32bit binaries for SketchUp versions that do not have this
  # # method.
  # if Sketchup.respond_to?(:is_64bit?) && Sketchup.is_64bit?
  #   # Load 64bit binaries.
  # else
  #   # Load 32bit binaries.
  # end
  # ```
  def self.is_64bit?: () -> bool

  # The is_online method is used to verify a connection to the Internet. This
  # method can take some time to execute, so be careful not to call it more often
  # than you need.
  # 
  # _@return_ — true if successful, false if unsuccessful.
  # 
  # ```ruby
  # status = Sketchup.is_online
  # ```
  def self.is_online: () -> bool

  # Returns a boolean flag indicating whether the application is SketchUp Pro.
  # 
  # ```ruby
  # if Sketchup.is_pro?
  #   UI.messagebox("You are running SU Pro.")
  # end
  # ```
  # 
  # _@note_ — In SketchUp Make this method will return +true+ during the Pro trial
  # period and revert to +false+ when the trial period is over.
  def self.is_pro?: () -> bool

  # The is_valid_filename? method is used to determine whether a filename
  # contains illegal characters.
  # 
  # _@param_ `filename` — A filename string.
  # 
  # ```ruby
  # status = Sketchup.is_valid_filename?(filename)
  # ```
  def self.is_valid_filename?: (String filename) -> bool

  # The load method is used to include encrypted and nonencrypted ruby files.
  # 
  # You do not need to include the file extension on the path. This method will
  # look for .rb first (unencrypted) and then .rbe (encrypted) and finally .rbs
  # (the deprecated scrambled format) files.
  # See the "Distributing your Plugin" article for details.
  # 
  # _@param_ `path` — The path, including the filename, to the file you want to require.
  # 
  # _@return_ — True if the file is included. False if the
  # file is not included.
  # 
  # ```ruby
  # sfile = "application_loader" # file extension not required
  # status = Sketchup.load(sfile)
  # ```
  def self.load: (String path) -> bool

  # sord omit - no YARD type given for "*args", using untyped
  # sord omit - no YARD return type given, using untyped
  # The {.open_file} method is used to open a SketchUp model.
  # 
  # ```ruby
  # result = Sketchup.open_file("C:\\model.skp")
  # ```
  def self.open_file: (*untyped args) -> untyped

  # The os_language method returns the language code for the language SketchUp
  # is running in. This is an alias for the get_locale method.
  # 
  # Examples of return values are: en-US, fr, it, de, es, ja, ko, zh-CN, zh-TW,
  # pt-BR, nl, ru and sv. For an up to date list os supported languages, see
  # the SketchUp download page.
  # 
  # _@return_ — a code representing the language SketchUp
  # is displaying.
  # 
  # ```ruby
  # language = Sketchup.os_language
  # ```
  def self.os_language: () -> String

  # The parse_length method parses a string as a length.
  # 
  # For example, "200" becomes 200.0.
  # 
  # _@param_ `string` — The string to be parsed as a number.
  # 
  # _@return_ — the numerical representation of the string if
  # successful, or nil if unsuccessful.
  # 
  # ```ruby
  # float = Sketchup.parse_length("2'") # Returns 24 (representing inches)
  # length = float.to_l # Convert to a Length type if needed.
  # ```
  def self.parse_length: (String string) -> Float

  # This methods returns a symbol indicating the current platform.
  # 
  # It should be used over RUBY_PLATFORM as this returns a different value for
  # Windows since SketchUp 2014.
  # 
  # Older SketchUp versions still need to check
  # <code>RUBY_PLATFORM.include?('mswin')</code> or
  # <code>RUBY_PLATFORM.include?('darwin')</code>.
  # 
  # Possible return values:
  # - :platform_win
  # - :platform_osx
  # 
  # _@return_ — Current OS platform.
  # 
  # ```ruby
  # module MyExtension
  #   IS_WIN = Sketchup.platform == :platform_win
  #   IS_OSX = Sketchup.platform == :platform_osx
  # end
  # ```
  def self.platform: () -> Symbol

  # The plugins_disabled= method lets you control whether SketchUp will load
  # Ruby scripts from the plugins directory at startup time. This is primarily
  # a trouble-shooting method. If you are having strange behavior in SketchUp
  # that you suspect is from a bad script, you can type
  # Sketchup.plugins_disabled=true into the Ruby console and restart SketchUp
  # to see if the problem is fixed.
  # 
  # _@param_ `enabled` — If true, the plugins directory will not load.
  # 
  # _@return_ — true if plugins were disabled.
  # 
  # ```ruby
  # # Type this in the Ruby console then restart SketchUp.
  # Sketchup.plugins_disabled = true
  # 
  # # To reactivate plugins, type this into the Ruby console and restart.
  # Sketchup.plugins_disabled = false
  # ```
  def self.plugins_disabled=: (bool enabled) -> bool

  # The plugins_disabled? method indicates whether Ruby scripts in the plugins
  # directory will be loaded at startup time.
  # 
  # ```ruby
  # is_disabled = Sketchup.plugins_disabled?
  # ```
  def self.plugins_disabled?: () -> bool

  # The quit method is used to terminate the application. This will pop-up the
  # usual model save prompts if there are unsaved models open. User can cancel
  # the model save, in which case the application will not terminate.
  # 
  # _@return_ — self
  # 
  # ```ruby
  # Sketchup.quit
  # # Do not expect code to execute reliably after this point.
  # ```
  def self.quit: () -> untyped

  # The read_default method is used to retrieve the string associated with a
  # value within the specified sub-section section of a .INI file or registry
  # (within the Software > SketchUp > SketchUp [Version] section).
  # 
  # _@param_ `section` — A section in an .INI or registry.
  # 
  # _@param_ `variable` — A variable within the section.
  # 
  # _@param_ `default` — A default value if the value is not found.
  # 
  # _@return_ — if unsuccessful, the value of the default
  # if successful.
  # 
  # ```ruby
  # result = Sketchup.read_default("section", "variable", "default")
  # ```
  def self.read_default: (String section, String variable, ?Object? default) -> Object?

  # The redo method is used redo the last transaction on the redo stack.
  # 
  # ```ruby
  # Sketchup.redo
  # ```
  def self.redo: () -> void

  # The register_extension method is used to register an extension with
  # SketchUp's extension manager (in SketchUp preferences).
  # 
  # _@param_ `extension` — A SketchupExtension object.
  # 
  # _@param_ `load_on_start` — Passing true into this will load the extension immediately and set it so that it will load automatically whenever SketchUp restarts.
  # 
  # _@return_ — +true+ if extension registered properly
  # 
  # ```ruby
  # utilities_extension = SketchupExtension.new("Utilities Tools",
  #   "Utilities/utilitiesTools.rb")
  # 
  # utilities_extension.description = "Adds Tools->Utilities to the " +
  #   "SketchUp inteface. The Utilities submenu contains two tools: " +
  #   "Create Face and Query Tool."
  # 
  # Sketchup.register_extension(utilities_extension, false)
  # ```
  # 
  # _@note_ — It is recommended to set +load_on_start+ to true unless you have a very
  # good reason not to.
  def self.register_extension: (SketchupExtension _extension, ?bool load_on_start) -> bool

  # The register_importer method is used to register an importer with SketchUp.
  # 
  # _@param_ `importer` — An Importer object representing the importer.
  # 
  # _@return_ — true if successful, false if unsuccessful.
  # 
  # ```ruby
  # status = Sketchup.register_importer(importer)
  # ```
  def self.register_importer: (Sketchup::Importer importer) -> bool

  # The remove_observer method is used to remove an observer from the current
  # object.
  # 
  # _@param_ `observer` — An observer.
  # 
  # _@return_ — true if successful, false if unsuccessful.
  # 
  # ```ruby
  # status = Sketchup.remove_observer(observer)
  # ```
  def self.remove_observer: (Sketchup::AppObserver observer) -> bool

  # The require method is used to include encrypted and nonencrypted ruby files.
  # This is an alias of the Sketchup.load method.
  # 
  # You do not need to include the file extension on the path. This method will
  # look for .rbe first (encrypted) and then .rbs (the deprecated scrambled
  # format) and finally .rb (unencrypted) files. The loading order was changed
  # in SketchUp 2016 when the new .rbe encryption was introduced. Prior to
  # SketchUp 2016 the loading order was first .rb then .rbs.
  # 
  # _@param_ `path` — The path, including the filename, to the file you want to require.
  # 
  # _@return_ — True if the file is included. False if the
  # file is not included.
  # 
  # ```ruby
  # sfile = "application_loader" # file extension not required
  # status = Sketchup::require(sfile)
  # ```
  def self.require: (String path) -> bool

  # The save_thumbnail method is used to generate a thumbnail for any SKP file -
  # not necessarily the loaded model.
  # 
  # _@param_ `skp_filename` — The name of the SketchUp file whose model you want represented in the thumbnail.
  # 
  # _@param_ `img_filename` — The name of the file where the thumbnail will be saved.
  # 
  # _@return_ — true if successful, false if unsuccessful.
  # 
  # ```ruby
  # status = Sketchup.save_thumbnail("skp_filename", "image_filename")
  # ```
  def self.save_thumbnail: (String skp_filename, String img_filename) -> bool

  # The send_action method sends a message to the message queue to perform some
  # action asynchronously.
  # 
  # Valid actions are:
  # - showRubyPanel:
  # - viewBack:
  # - viewBottom:
  # - viewFront:
  # - viewIso:
  # - viewLeft:
  # - viewRight:
  # - viewTop:
  # - viewPerspective:
  # - viewShowAxes:
  # - viewShowHidden:
  # - viewZoomExtents:
  # - viewZoomToSelection:
  # - viewUndo:
  # - selectOrbitTool:
  # - selectPositionCameraTool:
  # - selectDollyTool:
  # - selectTurnTool:
  # - selectWalkTool:
  # - selectZoomTool:
  # - selectFieldOfViewTool:
  # - selectZoomWindowTool:
  # - pageAdd:
  # - pageDelete:
  # - pageUpdate:
  # - pageNext:
  # - pagePrevious:
  # - renderWireframe:
  # - renderHiddenLine:
  # - renderMonochrome:
  # - renderShaded:
  # - renderTextures:
  # - selectArcTool:
  # - selectArc3PointTool:
  # - selectArc3PointPieTool:
  # - selectAxisTool:
  # - selectCircleTool:
  # - selectEraseTool:
  # - selectFreehandTool:
  # - selectLineTool:
  # - selectMeasureTool:
  # - selectMoveTool:
  # - selectOffsetTool:
  # - selectPaintTool:
  # - selectPolygonTool:
  # - selectProtractorTool:
  # - selectPushPullTool:
  # - selectRectangleTool:
  # - selectRectangle3PointTool:
  # - selectRotateTool:
  # - selectScaleTool:
  # - selectSectionPlaneTool:
  # - selectTextTool:
  # - selectDimensionTool:
  # - selectExtrudeTool:
  # - selectSelectionTool:
  # - editUndo:
  # - editRedo:
  # - editHide:
  # - editUnhide:
  # - fixNonPlanarFaces:
  # 
  # Added in SketchUp 8.0+:
  # - addBuilding:
  # - getPhotoTexture:
  # - selectImageIglooTool:
  # - selectNorthTool:
  # 
  # Added in SketchUp 2013+:
  # - showExtensionStore:
  # 
  # Removed in SketchUp 2013+:
  # - addBuilding:
  # 
  # On the PC only, you can also send these numeric values. (Note that these are
  # officially "unsupported" and are not guaranteed to work in current or
  # future versions of the API.)
  # 
  # - 10501: set view to Top
  # - 10502: set view to Front
  # - 10503: set view to Rear
  # - 10504: set view to Left
  # - 10505: set view to Right
  # - 10506: set view to Bottom
  # - 10507: set view to Axonometric
  # - 10510: set render mode to Wire
  # - 10511: set render mode to Hidden lines removal
  # - 10512: set render mode to Surfaces Shading
  # - 10513: set render mode to Transparency
  # - 10519: set camera to ortho (removes perspective)
  # - 10520: walk tool
  # - 10521: display the System Preferences dialog box (Files tab)
  # - 10522: removes axes display
  # - 10523: pan tool
  # - 10525: set the interactive eye height feature
  # - 10526: zoom window
  # - 10527: zoom extents
  # - 10529: zoom out 2
  # - 10531: toggle the Standard toolbar
  # - 10532: toggle the Camera toolbar
  # - 10533: display the Shadows Settings dialog box
  # - 10537: toggle the Views toolbar
  # - 10538: display the System Preferences dialog box (Display tab)
  # - 10545: toggle Color ByLayer
  # - 10546: toggle Shadows toolbar
  # - 10551: toogle Large icons
  # - 10576: toggle Render Mode toolbar
  # - 10596: set Render Mode to No Transparency (Preferences)
  # - 10597: set Render Mode to Wire (Preferences)
  # - 10598: set Render Mode to Transparency (Preferences)
  # - 10599: set Render Mode to Surfaces Shading (Preferences)
  # - 10600: set Render Mode to Texture (Preferences)
  # - 10601: set Render Mode to No Texture (Preferences)
  # - 10602: toggle Shadows
  # - 10603: toggle Profiles
  # - 10604: toggle Extension Lines
  # - 10605: toggle Jitter edges
  # - 21019: hide Status bar and VCB
  # - 21020: show Status bar and VCB
  # - 21022: hide Status bar and VCB
  # - 21023: place 3d text box
  # - 21024: select the Measure tool
  # - 21031: select the Freehand Draw tool
  # - 21041: select the PushPull tool
  # - 21048: select the Move tool
  # - 21052: hide selected objects
  # - 21056: create face with selected edges closed loop
  # - 21057: select the Protractor tool
  # - 21060: display Components Window
  # - 21061: toggle Draw toolbar
  # - 21063: toggle Model Bounding Box display
  # - 21065: select the Arc tool
  # - 21067: creat a new Page
  # - 21069: select the Arc 3 Point tool
  # - 21070: select the Arc 3 Point Pie tool
  # - 21074: show the Materials Browser Window
  # - 21076: display the Preferences dialog box (Text activated)
  # - 21077: display the Tip of the day Window
  # - 21078: select the Paint Bucket tool
  # - 21080: display the Page Manager Window
  # - 21082: display the Macros Dialog Box
  # - 21086: display the Components Browser Window
  # - 21094: select the Rectangle tool
  # - 21095: select the Polygon tool
  # - 21096: select the Circle tool
  # - 21098: open the Open Window
  # - 21100: select the Offset tool
  # - 21101: select all objects
  # - 21107: invert selection
  # - 21112: open the Import Window
  # - 21124: launch the validity check tool
  # - 21126: select the Axes tool
  # - 21029: select the Rotate tool
  # - 21032: toggle Layer toolbar
  # - 21036: display the Save as Window
  # - 21046: spin the model a full 360&deg; and display report
  # - 21047: fast Pick Time report
  # - 21049: open the Export model Window
  # - 21169: select the Position Camera tool
  # - 21170: display the Preferences, Tour Guide activated
  # - 21180: create a new Page just right of selected page
  # - 21200: display the Insert Image Window
  # - 21233: display Area of selected face
  # - 21234: display Area of all faces with selected material
  # - 21236: select the Scale tool
  # - 21237: display the Export 2D Graphics Window
  # - 21245: display a Polygon Offset Factors dialog box
  # - 21276: reverse selected face(s)
  # - 21287: select the Divide feature
  # - 21337: select the Section Plane Placement tool
  # - 21354: open the Layer Window
  # - 21386: open the Export Animation Window
  # - 21405: select the Text tool
  # - 21406: display Fog dialog box
  # - 21410: select the Dim tool
  # - 21433: toggle Edit toolbar
  # - 21442: select the FollowMe tool
  # - 21448: select the Axes tool
  # - 21453: select all objects
  # - 21460: display Licence
  # - 21462: display Authorization dialog box
  # - 21463: display un-authorizing message
  # - 21464: display Open Licence files (Network) Window
  # - 21466: display Quick reference Card in Adobe Reader
  # - 21467: display Licences in use dialog box
  # - 21469: zoom extents to selected objects
  # - 21476: perform a non-planar check on selected objects
  # - 21477: list accelerators in window
  # - 21485: erase selected objects
  # - 21487: display Edit current material dialog box
  # - 21485: erase all new created pages
  # - 21488: display Entity Info Window
  # - 21490: display Soften Edges Window
  # - 21491: display Profiles
  # - 21492: display Extended Edges
  # - 21493: display Jitter Lines
  # - 21494: select Field of view tool
  # - 21513: display the outliner
  # - 21520: override Tile Rendering Size dialog box
  # - 21525: select the FollowMe tool
  # - 21542: display the Insert Image Window
  # - 21560 and up: causes a runtime Error
  # 
  # _@param_ `action` — The action to be performed.
  # 
  # _@return_ — +true+ if successful, +false+ if unsuccessful
  # 
  # ```ruby
  # result = Sketchup.send_action("selectArcTool:")
  # ```
  def self.send_action: ((String | Integer) action) -> bool

  # The {.send_to_layout} method is used to open a file in LayOut.
  # 
  # _@param_ `file` — The path and filename to open, either .skp or .layout.
  # 
  # _@return_ — true if opening the file succeeded,
  # false otherwise.  If LayOut is not installed or the file is not present
  # this function will return false.
  # 
  # ```ruby
  # result = Sketchup.send_to_layout("C:/models/hexaflexagon.layout")
  # ```
  def self.send_to_layout: (String file) -> bool

  # sord omit - no YARD type given for "*args", using untyped
  # sord omit - no YARD return type given, using untyped
  # The set_status_text method is used to
  # set the text appearing on the status bar within the drawing window.
  # 
  # If no arguments are passed, the status bar content is cleared. Valid
  # positions are:
  # 
  # - +SB_PROMPT+ - the text will appear at the left-side of the status bar
  # - +SB_VCB_LABEL+ - the text will appear in place of the VCB label
  # - +SB_VCB_VALUE+ - the text will appear in the VCB
  # 
  # ```ruby
  # result = Sketchup.set_status_text("This is a Test", SB_VCB_VALUE)
  # if result
  #   #code to do something if set_status_text is successful
  # end
  # ```
  def self.set_status_text: (*untyped args) -> untyped

  # The status_text= method is used to set the text appearing on the status
  # bar within the drawing window.
  # 
  # This is the same as calling set_status_text with a 2nd parameter of
  # SB_PROMPT.
  # 
  # _@param_ `status_text` — The status text that will appear.
  # 
  # ```ruby
  # result = Sketchup.status_text = "This is a Test"
  # ```
  def self.status_text=: (String status_text) -> String

  # The temp_dir method is used to retrieve the OS temporary directory for the
  # current user. You can use this directory to write temporary files that are
  # not required to persist between SketchUp sessions.
  # 
  # _@return_ — a string containing the full temporary directory path
  # 
  # ```ruby
  # temp_dir = Sketchup.temp_dir
  # ```
  def self.temp_dir: () -> String

  # The template method is used to get the file name of the current template.
  # Templates are the .skp files that are loaded when the user select File > New.
  # 
  # _@return_ — the current template
  # 
  # ```ruby
  # name = Sketchup.template
  # ```
  def self.template: () -> String

  # The template= method is used to set the file name of the current template.
  # Templates are the .skp files that are loaded when the user select File > New.
  # 
  # _@param_ `filename` — The name of the template to set.
  # 
  # _@return_ — true if successful, false if unsuccessful.
  # 
  # ```ruby
  # status = Sketchup.template = "filename"
  # ```
  def self.template=: (String filename) -> String

  # The template_dir is used to retrieve the directory where templates are
  # stored by the SketchUp install. Templates are the .skp files that are loaded
  # when the user select File > New.
  # 
  # _@return_ — containing the full template directory path
  # 
  # ```ruby
  # directory = Sketchup.template_dir
  # ```
  def self.template_dir: () -> String

  # The undo method is used undo the last transaction on the undo stack.
  # 
  # ```ruby
  # Sketchup.undo
  # ```
  def self.undo: () -> void

  # The vcb_label= method is used to set the label that appears on the vcb,
  # or the "value control box", which is another word for the "measurements"
  # text entry box that appears at the bottom on the SketchUp window.
  # 
  # This is the same as calling set_status_text with a 2nd parameter of
  # SB_VCB_LABEL.
  # 
  # _@param_ `label_text` — The label text that will appear.
  # 
  # ```ruby
  # result = Sketchup.vcb_label = "This is a Test"
  # ```
  def self.vcb_label=: (String label_text) -> String

  # The vcb_value= method is used to set the value that appears on the vcb,
  # or the "value control box", which is another word for the "measurements"
  # text entry box that appears at the bottom on the SketchUp window.
  # 
  # This is the same as calling set_status_text with a 2nd parameter of
  # SB_VCB_VALUE.
  # 
  # _@param_ `value` — The text that will appear as the vcb's value.
  # 
  # ```ruby
  # result = Sketchup.vcb_value = "This is a Test"
  # ```
  def self.vcb_value=: (String value) -> String

  # Gets the current version of sketchup in decimal form.
  # 
  # _@return_ — the decimal form of the version
  # 
  # ```ruby
  # version = Sketchup.version
  # if (version)
  #   UI.messagebox version
  # else
  #   return
  # end
  # ```
  def self.version: () -> String

  # sord omit - no YARD type given for "*args", using untyped
  # Get the current version of sketchup as a whole number for comparisons. The
  # number returned has the major, minor, and build values packed into an integer
  # value as follows:
  # - Major version = X
  # - Minor version = Y
  # - Build number = Z
  # 
  # SketchUp 6.0 - SketchUp 2015
  # - XXYYYZZZ
  # 
  # SketchUp 2016+
  # - XXYZZZZZZZ
  # 
  # _@return_ — the whole number form of the version
  # 
  # ```ruby
  # if (15003000...15004000) === Sketchup.version_number
  #   puts "SketchUp 15.3"
  # end
  # if Sketchup.version_number >= 1600000000
  #   puts "New format"
  # end
  # ```
  def self.version_number: (*untyped args) -> Integer

  # The write_default method is used to set the string associated with a
  # variable within the specified sub-section of a .plist file on the Mac
  # or the registry on Windows
  # (within the Software > SketchUp > SketchUp [Version] section).
  # 
  # _@param_ `section` — A section in a .plist file (Mac) or the registry (Windows).
  # 
  # _@param_ `key` — A key within the section.
  # 
  # _@param_ `value` — The value to store.
  # 
  # _@return_ — True if successful, false if unsuccessful.
  # 
  # ```ruby
  # result = Sketchup.write_default("section", "key", "my_value")
  # ```
  def self.write_default: (String section, String key, Object value) -> bool

  # The set class represents a collection of unique objects. This class is useful
  # for keeping track of a group of related entities, kind of like a selection
  # set that stays around for as long as you need it to.
  # 
  # To make a set of your own, create an empty one using Sketchup::Set.new, and
  # then add items to it.
  # 
  # @deprecated In SketchUp 2014 this class was changed from +Set+
  #   to +Sketchup::Set+ in order to avoid conflict with the Ruby Standard
  #   Library. The +Sketchup::Set+ class is deprecated and new extensions should
  #   make use of Ruby's +Set+ class unless they need backward compatibility.
  # 
  # @example
  #   set = Sketchup::Set.new
  #   set.insert(1)
  #   set.insert(2)
  # 
  # @example Compatibility Shim
  #   module Example
  # 
  #     # Shim for the Set class which was moved in SketchUp 2014
  #     if defined?(Sketchup::Set)
  #       # Warning! Do NOT do this in the global namespace!
  #       Set = Sketchup::Set
  #     end
  # 
  #     def self.test_set_shim
  #       set = Set.new
  #       set.insert('Hello')
  #       set.insert('World')
  #       puts set.to_a
  #     end
  # 
  #   end
  # 
  # @version SketchUp 6.0
  class Set
    # The clear method is used to clear all objects out of the set.
    # 
    # _@return_ — set - an empty Set object
    # 
    # ```ruby
    # set = Sketchup::Set.new
    # set.insert(1)
    # set.insert(2)
    # set.insert(3)
    # set.clear
    # ```
    def clear: () -> untyped

    # The {#contains?} method is an alias for {#include?}.
    # 
    # _@param_ `entity`
    # 
    # ```ruby
    # set = Sketchup::Set.new
    # set.insert(1)
    # set.insert(2)
    # set.insert(3)
    # p set.contains?(2)
    # ```
    # 
    # _@see_ `#include?`
    def contains?: (Sketchup::Entity entity) -> bool

    # The delete object is used to delete or remove an object from the set.
    # 
    # _@param_ `object` — The object to be deleted.
    # 
    # _@return_ — object - the object that was deleted.
    # 
    # ```ruby
    # set = Sketchup::Set.new
    # set.insert(1)
    # set.insert(2)
    # set.delete(1)
    # ```
    def delete: (untyped object) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The each method is used to iterate through all of the objects in the set.
    # 
    # ```ruby
    # set = Sketchup::Set.new
    # set.insert(1)
    # set.insert(2)
    # set.insert(3)
    # set.each { | item | puts item }
    # ```
    def each: () -> untyped

    # The empty? method is used to determine whether the set is empty.
    # 
    # _@return_ — status - true if the set is empty, false if it is not
    # empty.
    # 
    # ```ruby
    # set = Sketchup::Set.new
    # set.insert(1)
    # set.insert(2)
    # set.insert(3)
    # puts set.empty?
    # ```
    def empty?: () -> bool

    # The {#include?} method is used to determine if the set includes a particular
    # object.
    # 
    # _@param_ `entity`
    # 
    # ```ruby
    # set = Sketchup::Set.new
    # set.insert(1)
    # set.insert(2)
    # set.insert(3)
    # p set.include?(2)
    # ```
    # 
    # _@see_ `#contains?`
    def include?: (Sketchup::Entity entity) -> bool

    # The insert method is used to insert an object into the set.
    # 
    # _@param_ `object` — The object to be inserted into the set.
    # 
    # _@return_ — size - the number of objects in the set
    # 
    # ```ruby
    # set = Sketchup::Set.new
    # set.insert(1)
    # set.insert(2)
    # set.insert(3)
    # ```
    def insert: (untyped object) -> untyped

    # The {#length} method is an alias for {#size}.
    # 
    # ```ruby
    # set = Sketchup::Set.new
    # set.insert(1)
    # set.insert(2)
    # set.insert(3)
    # puts set.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The {#size} method is used to determine the number of objects in the set.
    # 
    # ```ruby
    # set = Sketchup::Set.new
    # set.insert(1)
    # set.insert(2)
    # set.insert(3)
    # puts set.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer

    # The to_a method is used to get an Array of the entities in your Set.
    # 
    # _@return_ — array - The Array of the entities in the Set.
    # 
    # ```ruby
    # set = Sketchup::Set.new
    # set.insert('Hello')
    # set.insert('World')
    # my_array = set.to_a
    # UI.messagebox my_array
    # ```
    def to_a: () -> untyped
  end

  # The {Sketchup::Skp} module is used to read metadata from external SketchUp
  # files without loading the whole file.
  # 
  # @version SketchUp 2021.0
  module Skp
    # The {.read_guid} method is used to read the GUID, globally unique identifier,
    # for an external model.
    # 
    # In SketchUp, GUIDs are used to test if {Sketchup::ComponentDefinition}s and
    # {Sketchup::Model}s match (a component being an embedded model).
    # When you insert a component to a model, its GUID is compared to existing
    # component definitions in that model, and if there is a match the existing
    # component definition is re-used rather than a duplicate being added.
    # When a component definition is modified or a model is saved, their GUIDs are
    # renewed.
    # 
    # _@param_ `filepath`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # definitions = model.definitions
    # definition = definitions.find { |definition| !definition.internal? }
    # # true if component matches its external file.
    # definition.guid == Sketchup::Skp.read_guid(definition.path)
    # ```
    def self.read_guid: (String filepath) -> String
  end

  # SketchUp's drawing axes consist of three colored lines (red, green, blue),
  # usually perpendicular to each other, displayed in the drawing area. The
  # exception is when the user open an instance with a non-orthogonal
  # transformation. The root model transformation is always orthogonal.
  # 
  # The drawing axes are used by drawing tools to align the geometry it creates
  # as well as affecting the inference engine.
  # 
  # The plane where the red and green axes lines lie is called the ground plane.
  # The term origin, is used to define the place where all of axes lines start or
  # originate.
  # 
  # @version SketchUp 2016
  class Axes < Sketchup::Entity
    # The axes method returns the vectors representing the directions of the axes.
    # 
    # _@return_ — Array - an array of three vectors.
    # 
    # ```ruby
    # xaxis, yaxis, zaxis = Sketchup.active_model.axes.axes
    # ```
    def axes: () -> untyped

    # The origin method returns the origin of the axes.
    # 
    # _@return_ — Point3d - the origin for the axes.
    # 
    # ```ruby
    # point = Sketchup.active_model.axes.origin
    # ```
    def origin: () -> untyped

    # The set method allows the axes to be manipulated. The axes must always be
    # orthogonal, otherwise an error is thrown.
    # 
    # _@param_ `origin` — Point3d - The origin to set.
    # 
    # _@param_ `xaxis` — Vector3d - The x axis to set.
    # 
    # _@param_ `yaxis` — Vector3d - The y axis to set.
    # 
    # _@param_ `zaxis` — Vector3d - The z axis to set.
    # 
    # _@return_ — Axes - the axes object being set.
    # 
    # ```ruby
    # xaxis = Geom::Vector3d.new(3, 5, 0)
    # yaxis = xaxis * Z_AXIS
    # Sketchup.active_model.axes.set([10,0,0], xaxis, yaxis, Z_AXIS)
    # ```
    def set: (
               untyped origin,
               untyped xaxis,
               untyped yaxis,
               untyped zaxis
             ) -> untyped

    # The sketch_plane method returns a plane representing the ground plane of the
    # axes.
    # 
    # _@return_ — Array - of 4 numbers that give the coefficients of a
    # plane equation.
    # 
    # ```ruby
    # plane = Sketchup.active_model.axes.sketch_plane
    # ```
    def sketch_plane: () -> untyped

    # The axes method returns the origin and vectors representing the axes.
    # 
    # _@return_ — Array - an array of a point and three vectors.
    # 
    # ```ruby
    # point, xaxis, yaxis, zaxis = Sketchup.active_model.axes.to_a
    # ```
    def to_a: () -> untyped

    # The transformation method returns the transformation of the axes. This is
    # useful when creating tools that respect the model's drawing axes.
    # 
    # _@return_ — Transformation - the transformation for the axes.
    # 
    # ```ruby
    # # Point for a rectangle.
    # points = [
    #   Geom::Point3d.new( 0,  0, 0),
    #   Geom::Point3d.new(10,  0, 0),
    #   Geom::Point3d.new(10, 20, 0),
    #   Geom::Point3d.new( 0, 20, 0)
    # ]
    # # Transform the points so they are local to the model axes. Otherwise
    # # they would be local to the model origin.
    # tr = Sketchup.active_model.axes.transformation
    # points.each { |point| point.transform!(tr) }
    # Sketchup.active_model.active_entities.add_face(points)
    # ```
    def transformation: () -> untyped

    # The xaxis method returns the x axis of the axes.
    # 
    # _@return_ — Vector3d - the x axis for the axes.
    # 
    # ```ruby
    # vector = Sketchup.active_model.axes.xaxis
    # ```
    def xaxis: () -> untyped

    # The yaxis method returns the y axis of the axes.
    # 
    # _@return_ — Vector3d - the y axis for the axes.
    # 
    # ```ruby
    # vector = Sketchup.active_model.axes.yaxis
    # ```
    def yaxis: () -> untyped

    # The zaxis method returns the z axis of the axes.
    # 
    # _@return_ — Vector3d - the z axis for the axes.
    # 
    # ```ruby
    # vector = Sketchup.active_model.axes.zaxis
    # ```
    def zaxis: () -> untyped
  end

  # The Edge class contains methods modifying and extracting information for
  # edges.
  # 
  # @version SketchUp 6.0
  class Edge < Sketchup::Drawingelement
    # The all_connected method retrieves all of the entities connected to an edge,
    # including the edge itself.
    # 
    # _@return_ — the edge and entities connected to that edge
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # # I just happen to know that the second and third entities in the
    # # entities objects are edges.
    # entity1 = entities[1]
    # entity2 = entities[2]
    # edges = entity1.all_connected
    # if (edges)
    #   UI.messagebox edges.to_s
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def all_connected: () -> ::Array[Sketchup::Entity]

    # The common_face method is used to identify a face that is common to two
    # edges.
    # 
    # _@param_ `edge2` — The face whose edge you are checking for commonality.
    # 
    # _@return_ — the Face object that is common to the two edges
    # if successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0,0,0]
    # pts[1] = [width,0,0]
    # pts[2] = [width,depth,0]
    # pts[3] = [0,depth,0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # # I know that the second and third entity objects are edges
    # entity1 = entities[1]
    # entity2 = entities[2]
    # UI.messagebox entity1
    # UI.messagebox entity2
    # face = entity1.common_face entity2
    # if (face)
    #   UI.messagebox face
    # else
    #   UI.messagebox "Failure: No Common Face"
    # end
    # ```
    def common_face: (Sketchup::Edge edge2) -> Sketchup::Face?

    # The curve method is used to get the Curve object that this edge belongs
    # to, if any. Note that if the edge is part of an arc instead of a random
    # curve, then this method will return an ArcCurve object.
    # 
    # _@return_ — returns a Curve object if it is a
    # curve, nil if it is not a curve
    # 
    # ```ruby
    # edge = Sketchup.active_model.entities.add_line([0,0,0],[100,100,0])
    # curve = edge.curve
    # if (curve)
    #   # If it is a curve, display a pointer to the curve
    #   UI.messagebox curve
    # else
    #   UI.messagebox "Failure: Not a Curve"
    # end
    # ```
    def curve: () -> Sketchup::Curve?

    # The end method is used to retrieve the Vertex object at the end of the edge.
    # 
    # _@return_ — a Vertex object if successful
    # 
    # ```ruby
    # edge = Sketchup.active_model.entities.add_line([0,0,0],[100,100,0])
    # vertex = edge.end
    # if (vertex)
    #   # display a pointer to the Vertex
    #   UI.messagebox vertex
    # else
    #   UI.messagebox "Failure"
    # end
    # point = vertex.position
    # # Let's get the Point3d of the vertex
    # if (point)
    #   UI.messagebox point
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def end: () -> Sketchup::Vertex

    # The explode_curve method is used to explode an edge as though it were an
    # ArcCurve.
    # 
    # _@return_ — an exploded edge object if successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # # I just happen to know that the second entity in the
    # # entities objects is an edge.
    # entity1 = entities[1]
    # curve = entity1.explode_curve
    # if (curve)
    #   UI.messagebox curve
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def explode_curve: () -> Sketchup::Edge

    # The {#faces} method is used to retrieve all of the faces common to the edge.
    # 
    # ```ruby
    # edge = Sketchup.active_model.entities.add_line([0, 0, 0], [100, 100, 0])
    # faces = edge.faces
    # ```
    def faces: () -> ::Array[Sketchup::Face]

    # The find_faces method is used to create all of the Faces that can be created
    # with this edge. For example, if you use the API to draw three edges that form
    # a triangle, the face between them will not show up because you've only drawn
    # the edges, but if you call find_faces on one of the edges, the triangle will
    # be filled in.
    # 
    # _@return_ — the number of faces found
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # # I just happen to know that the second entity in the
    # # entities objects is an edge.
    # entity1 = entities[1]
    # # Getting zero.
    # number = entity1.find_faces
    # if (number)
    #   UI.messagebox "I created " + number.to_s + " faces."
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def find_faces: () -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#length} method is used to retrieve the length of an edge in current
    # units.
    # 
    # You can pass in an optional {Geom::Transformation} (or an array that can
    # represent a transformation), to correct for a parent group's transformation.
    # For example, if an edge is inside of a group that is scaled to 200%, the
    # length method will return the unscaled length of the edge. So by passing a
    # 200% transformation object to this method, you can account for that to get
    # the "visual" length of the edge.
    # 
    # ```ruby
    # edge = Sketchup.active_model.entities.add_line([0, 0, 0], [100, 100, 0])
    # puts "#{edge.length} (#{edge.length.inspect})"
    # ```
    def length: (*untyped args) -> untyped

    # The line method is used to retrieve the line defined by the edge. Lines in
    # SketchUp aren't visible entities but geometric constructs represented by
    # an Array with a Point3d and a Vector3d. See the Geom module and the Array
    # class for more information on lines.
    # 
    # _@return_ — an array with a Point3d object
    # and a Vector3d object.
    # 
    # ```ruby
    # edge = Sketchup.active_model.entities.add_line([0,0,0],[100,100,0])
    # # Returns a 3D ray
    # line = edge.line
    # if (line)
    #   UI.messagebox line
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def line: () -> [Geom::Point3d, Geom::Vector3d]

    # The other_vertex method is used to find the opposite vertex given one vertex
    # of the edge.
    # 
    # _@param_ `vertex1` — One of the Vertex objects associated with the edge.
    # 
    # _@return_ — the other Vertex object associated with the edge
    # 
    # ```ruby
    # edge = Sketchup.active_model.entities.add_line([0,0,0],[100,100,0])
    # # Get the end vertex of an edge
    # vertex = edge.end
    # # Should find the starting vertex
    # othervertex = edge.other_vertex vertex
    # if (othervertex)
    #   UI.messagebox othervertex
    # else
    #   UI.messagebox "Failure"
    # end
    # # The Point3d for the vertex
    # point = othervertex.position
    # if (point)
    #   UI.messagebox point
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def other_vertex: (Sketchup::Vertex vertex1) -> Sketchup::Vertex

    # The {#reversed_in?} method is used to determine if the edge is reversed in
    # a face's bounding loop.
    # 
    # _@param_ `face` — The face that is bounded by the edge.
    # 
    # _@return_ — +true+ if the edge is reversed, +false+ if it is not
    # reversed. +nil+ if the edge and face is not connected.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # points = []
    # points[0] = [0, 0, 0]
    # points[1] = [9, 0, 0]
    # points[2] = [9, 9, 0]
    # points[3] = [0, 9, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face(points)
    # edge = face.edges[0]
    # if edge.reversed_in?(face)
    #   face.reverse!
    # end
    # ```
    # 
    # _@see_ `Sketchup::EdgeUse`
    # 
    # _@see_ `Sketchup::Loop`
    def reversed_in?: (Sketchup::Face face) -> bool

    # The {#smooth=} method is used to set the edge to be smooth.
    # 
    # A smooth edge will cause the shading between connected faces to blend to a
    # smooth transition. The edge will still be visible.
    # 
    # _@param_ `value`
    # 
    # ```ruby
    # edge = Sketchup.active_model.entities.add_line([0,0,0], [100,100,0])
    # # Soft and Smooth are normally set in pairs.
    # edge.soft = true
    # edge.smooth = true
    # ```
    # 
    # _@note_ — The soft and smooth properties are normally set in pairs. You can
    # observer this when the Soften/Smooth Edges feature or holding down Ctrl
    # when using the Eraser Tool.
    # 
    # _@see_ `https://help.sketchup.com/en/article/3000097`
    def smooth=: (bool value) -> bool

    # The {#smooth?} method is used to retrieve the current smooth setting for an
    # edge.
    # 
    # A smooth edge will cause the shading between connected faces to blend to a
    # smooth transition. The edge will still be visible.
    # 
    # ```ruby
    # edge = Sketchup.active_model.entities.add_line([0,0,0], [100,100,0])
    # # Soft and Smooth are normally set in pairs.
    # edge.smooth = !edge.smooth?
    # edge.soft = edge.smooth?
    # ```
    # 
    # _@see_ `https://help.sketchup.com/en/article/3000097`
    def smooth?: () -> bool

    # The {#soft=} method is used to set the edge to be soft.
    # 
    # A soft edge will cause the connected faces to be treated as a surface. This
    # means that if you have Hidden Geometry off and select one face it will also
    # select all faces connected with soft edges. A soft edge will also appear
    # hidden.
    # 
    # _@param_ `value`
    # 
    # ```ruby
    # edge = Sketchup.active_model.entities.add_line([0,0,0], [100,100,0])
    # # Soft and Smooth are normally set in pairs.
    # edge.soft = true
    # edge.smooth = true
    # ```
    # 
    # _@note_ — The soft and smooth properties are normally set in pairs. You can
    # observer this when the Soften/Smooth Edges feature or holding down Ctrl
    # when using the Eraser Tool.
    # 
    # _@see_ `https://help.sketchup.com/en/article/3000097`
    def soft=: (bool value) -> bool

    # The {#soft?} method is used to retrieve the current smooth setting for an
    # edge.
    # 
    # A soft edge will cause the connected faces to be treated as a surface. This
    # means that if you have Hidden Geometry off and select one face it will also
    # select all faces connected with soft edges. A soft edge will also appear
    # hidden.
    # 
    # ```ruby
    # edge = Sketchup.active_model.entities.add_line([0,0,0], [100,100,0])
    # # Soft and Smooth are normally set in pairs.
    # edge.soft = !edge.soft?
    # edge.smooth = edge.soft?
    # ```
    # 
    # _@see_ `https://help.sketchup.com/en/article/3000097`
    def soft?: () -> bool

    # The split method is used to  to split an edge into two or more distinct
    # edges. If a Point3d is given, it must be a point that is on the Edge.
    # 
    # If a Float is given, it is a number between 0 and 1 that gives the
    # relative position along the edge at which to split it.  For example,
    # edge.split(0.5) will split the Edge at its midpoint. This split position
    # is measured from the Edge.start.
    # 
    # Returns the new Edge that was created as a result of splitting this one.
    # 
    # _@param_ `position` — A Point3d object whose location is along the edge, or a Float between 0.0 and 1.0 defining how far along the edge to split.
    # 
    # _@return_ — the new Edge object that was split off
    # the old one if successful
    # 
    # ```ruby
    # # Split a line in half.
    # edge = Sketchup.active_model.entities.add_line([0,0,0],[100,100,0])
    # new_edge = edge.split 0.5
    # ```
    def split: (Geom::Point3d position) -> Sketchup::Edge

    # The end method is used to retrieve the Vertex object at the start of the
    # edge.
    # 
    # _@return_ — a Vertex object if successful
    # 
    # ```ruby
    # edge = Sketchup.active_model.entities.add_line([0,0,0],[100,100,0])
    # vertex = edge.start
    # if (vertex)
    #   # display a pointer to the Vertex
    #   UI.messagebox vertex
    # else
    #   UI.messagebox "Failure"
    # end
    # point = vertex.position
    # # Let's get the Point3d of the vertex
    # if (point)
    #   UI.messagebox point
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def start: () -> Sketchup::Vertex

    # The used_by? method is used to see if an edge is used by a given Face or
    # Vertex.
    # 
    # _@param_ `element` — A Vertex or Face object.
    # 
    # ```ruby
    # edge = Sketchup.active_model.entities.add_line([0,0,0],[100,100,0])
    # # Returns a vertex
    # vertex = edge.start
    # # Check to see if the edge is used by the Vertex.
    # status = edge.used_by? vertex
    # if (status)
    #   UI.messagebox status
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def used_by?: ((Sketchup::Vertex | Sketchup::Face) element) -> bool

    # The vertices method is used to retrieve the vertices on the edge.
    # 
    # _@return_ — an array of Vertex objects
    # 
    # ```ruby
    # edge = Sketchup.active_model.entities.add_line([0,0,0],[100,100,0])
    # vertices = edge.vertices
    # ```
    def vertices: () -> ::Array[Sketchup::Vertex]
  end

  # Faces in SketchUp are flat, 2-sided polygons with 3 or more sides.
  # 
  # @version SketchUp 6.0
  class Face < Sketchup::Drawingelement
    PointInside: untyped
    PointNotOnPlane: untyped
    PointOnEdge: untyped
    PointOnFace: untyped
    PointOnVertex: untyped
    PointOutside: untyped
    PointUnknown: untyped

    # The all_connected method retrieves all of the entities connected to a face.
    # 
    # _@return_ — the entities connected to the face
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # connected = face.all_connected
    # ```
    def all_connected: () -> ::Array[Sketchup::Entity]

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The area method is used to retrieve the area of a face.
    # 
    # You can pass in an optional Transformation (or an array that can represent a
    # transformation), to correct for a parent group's transformation. For example,
    # if a face is inside of a group that is scaled to 200%, the area method will
    # return the unscaled area of the face. So by passing a 200% transformation
    # object to this method, you can account for that to get the "visual" area
    # of the face.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # area = face.area
    # ```
    def area: (*untyped args) -> untyped

    # The back_material method is used to retrieve the material assigned to the
    # back side of the face.
    # 
    # _@return_ — a Material object representing the material
    # on the back of the face (if successful)
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # 
    # # Add a material to the back face, then check to see that it was added
    # face.back_material = "red"
    # material = face.back_material
    # ```
    def back_material: () -> Sketchup::Material?

    # The back_material= method is used to set the material assigned to the back
    # side of the face.
    # 
    # _@param_ `material` — A Material object or the name of a valid material.
    # 
    # _@return_ — the name of the valid material or the new
    # Material object (if successful)
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # status = face.back_material = "red"
    # ```
    def back_material=: (Sketchup::Material material) -> Sketchup::Material

    # The classify_point method is used to determine if a given Point3d is on the
    # referenced Face.
    # 
    # It is important that return value comparisons be made against the
    # symbolic constants (i.e. {Sketchup::Face::PointUnknown},
    # {Sketchup::Face::PointInside}, {Sketchup::Face::PointOnVertex}, etc.) rather
    # than the absolute integer values as these values may change from one
    # release to the next.
    # 
    # _@param_ `point` — A Point3d.
    # 
    # _@return_ — an integer describing where a Point3d is in
    # relation to the referenced Face.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [9, 0, 0]
    # pts[2] = [9, 9, 0]
    # pts[3] = [0, 9, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # 
    # # Check a point that should be outside the face.
    # pt = Geom::Point3d.new(50, 50, 0)
    # result = face.classify_point(pt)
    # if result == Sketchup::Face::PointOutside
    #   puts "#{pt.to_s} is outside the face"
    # end
    # 
    # # Check a point that should be outside inside the face.
    # pt = Geom::Point3d.new(1, 1, 0)
    # result = face.classify_point(pt)
    # if result == Sketchup::Face::PointInside
    #   puts "#{pt.to_s} is inside the face"
    # end
    # 
    # # Check a point that should be on the vertex of the face.
    # pt = Geom::Point3d.new(0, 0, 0)
    # result = face.classify_point(pt)
    # if result == Sketchup::Face::PointOnVertex
    #   puts "#{pt.to_s} is on a vertex"
    # end
    # 
    # # Check a point that should be on the edge of the face.
    # pt = Geom::Point3d.new(0, 1, 0)
    # result = face.classify_point(pt)
    # if result == Sketchup::Face::PointOnEdge
    #   puts "#{pt.to_s} is on an edge of the face"
    # end
    # 
    # # Check a point that should be off the plane of the face.
    # pt = Geom::Point3d.new(1, 1, 10)
    # result = face.classify_point(pt)
    # if result == Sketchup::Face::PointNotOnPlane
    #   puts "#{pt.to_s} is not on the same plane as the face"
    # end
    # ```
    def classify_point: (Geom::Point3d point) -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#clear_texture_position} method is used to remove any explicit
    # texture positioning for a face and have SketchUp display it with the
    # default texture positioning.
    # 
    # _@param_ `front` — +true+ Clears on the front side of the face, +false+ the back side.
    def clear_texture_position: (bool front) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#clear_texture_projection} method is used to clear the texture
    # projection. This is similar to toggling off Projection from the Position
    # Texture tool in the UI.
    # 
    # _@param_ `frontside` — +true+ for front side, +false+ for back side.
    # 
    # _@see_ `#position_material`
    # 
    # _@see_ `#get_texture_projection`
    def clear_texture_projection: (bool frontside) -> untyped

    # The edges method is used to get an array of edges that bound the face.
    # 
    # _@return_ — an array of Edge objects (if successful)
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # edges = face.edges
    # ```
    def edges: () -> ::Array[Sketchup::Edge]

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#followme} method is used to create a shape by making the face follow
    # along an array of edges.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # 
    # depth = 100
    # width = 100
    # 
    # # Add the face to the entities in the model
    # points = [
    #   Geom::Point3d.new(0, 0, 0),
    #   Geom::Point3d.new(width, 0, 0),
    #   Geom::Point3d.new(width, depth, 0),
    #   Geom::Point3d.new(0, depth, 0)
    # ]
    # face = entities.add_face(points)
    # 
    # # Add the line which we will "follow" to the entities in the model
    # point1 = Geom::Point3d.new(0, 0, 0)
    # point2 = Geom::Point3d.new(0, 0, 100)
    # edge = entities.add_line(point1, point2)
    # face.followme(edge)
    # ```
    def followme: (*untyped args) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # The get_UVHelper object is used to retrieve a UVHelper object for use in
    # texture manipulation on a face.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [9, 0, 0]
    # pts[2] = [9, 9, 0]
    # pts[3] = [0, 9, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # tw = Sketchup.create_texture_writer
    # uvHelp = face.get_UVHelper(true, true, tw)
    # ```
    def get_UVHelper: (*untyped args) -> Sketchup::UVHelper

    # The get_glued_instances method returns an Array any ComponentInstances
    # that are glued to the face.
    # 
    # ComponentInstance objects that are currently glued to the face.
    # 
    # _@return_ — An array of
    # 
    # ```ruby
    # # Create a series of points that define a new face.
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [9, 0, 0]
    # pts[2] = [9, 9, 0]
    # pts[3] = [0, 9, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # glued_array = face.get_glued_instances
    # ```
    def get_glued_instances: () -> ::Array[(Sketchup::ComponentInstance | Sketchup::Group | Sketchup::Image)]

    # The {#get_texture_projection} method will return a vector representing the
    # projection for either the front or back side of the face.
    # 
    # _@param_ `frontside` — +true+ for front side, +false+ for back side.
    # 
    # _@return_ — a vector on success, +nil+ if face is not
    # textured with a projected texture mapping.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # materials = model.materials
    # 
    # # Create a face and add it to the model entities
    # pts = []
    # pts[0] = [0, 0, 1]
    # pts[1] = [10, 0, 1]
    # pts[2] = [10, 10, 1]
    # face = entities.add_face(pts)
    # 
    # # Export an image to use as a texture
    # path = Sketchup.temp_dir
    # full_name = File.join(path, "temp_image.jpg")
    # model.active_view.write_image(full_name, 500, 500, false, 0.0)
    # 
    # # Create a material and assign the texture to it
    # material = materials.add("Test Material")
    # material.texture = full_name
    # 
    # # Assign the new material to our face we created
    # face.material = material
    # 
    # # Set the projection of the applied material
    # face.set_texture_projection(face.normal, true)
    # 
    # # Get the projection of the applied material
    # vector = face.get_texture_projection(true)
    # ```
    # 
    # _@see_ `#position_material`
    # 
    # _@see_ `#texture_projected?`
    def get_texture_projection: (bool frontside) -> Geom::Vector3d?

    # The loops method is used to get an array of all of the loops that bound the
    # face.
    # 
    # _@return_ — an array of Loop objects if successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # loops = face.loops
    # ```
    def loops: () -> ::Array[Sketchup::Loop]

    # The material method is used to retrieve the material assigned to the
    # front of the face. (This method is inherited from the Drawingelement
    # parent class.)
    # 
    # _@return_ — a Material object representing the material
    # on the front of the face (if successful)
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # 
    # # Add a material to the face, then check to see that it was added
    # face.material = "red"
    # material = face.material
    # ```
    def material: () -> Sketchup::Material?

    # The material= method is used to set the material assigned to the front
    # side of the face. (This method is inherited from the Drawingelement
    # parent class.)
    # 
    # _@param_ `material` — A Material object or the name of a valid material.
    # 
    # _@return_ — the name of the valid material or the new
    # Material object (if successful)
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # status = face.material = "red"
    # ```
    def material=: (Sketchup::Material material) -> Sketchup::Material

    # The mesh method creates a polygon mesh that represents the face. See the
    # {Geom::PolygonMesh} class for more information.
    # 
    # Valid flags are:
    # 
    # - +0+: Include PolygonMeshPoints,
    # - +1+: Include PolygonMeshUVQFront,
    # - +2+: Include PolygonMeshUVQBack,
    # - +4+: Include PolygonMeshNormals.
    # 
    # Use bitwise OR to combine flags. A value of +7+ will include all
    # flags, for example.
    # 
    # _@param_ `flags` — One or more flags used to generate a mesh.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # 
    # kPoints = 0
    # kUVQFront = 1
    # kUVQBack = 2
    # kNormals = 4
    # flags = kPoints | kUVQFront | kUVQBack | kNormals # equals to 7
    # mesh = face.mesh(flags)
    # ```
    def mesh: (?Integer flags) -> Geom::PolygonMesh

    # The normal method is used to retrieve the 3D vector normal to the face in
    # the front direction.
    # 
    # _@return_ — a Vector3d object if successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # normal = face.normal
    # ```
    def normal: () -> Geom::Vector3d

    # This method is used to retrieve the outer loop that bounds the face.
    # 
    # _@return_ — a Loop object representing the outer loop (if
    # successful)
    # 
    # ```ruby
    # # Create a series of points that define a new face.
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [9, 0, 0]
    # pts[2] = [9, 9, 0]
    # pts[3] = [0, 9, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # loop = face.outer_loop
    # ```
    def outer_loop: () -> Sketchup::Loop

    # The plane method is used to retrieve the plane of the face. See the Array
    # class for information on how planes are stored.
    # 
    # _@return_ — a plane that contains the face (if successful)
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # plane = face.plane
    # ```
    def plane: () -> [Float, Float, Float, Float]

    # sord omit - no YARD type given for "*args", using untyped
    # The {#position_material} method is used to position a material on a face.
    # 
    # The +points+ argument must contain 2, 4, 6 or 8 points. The points are used
    # in pairs to describe where a point in the texture image is positioned on the
    # Face. The first point in each pair is a 3D point in the model. The second
    # point in each pair of points is a 2D point that gives the (u,v) coordinates
    # of a point in the image to match up with the 3D point.
    # 
    # _@return_ — the face upon success, +false+ if material or
    # texture if not valid.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # 
    # # Create a face and add it to the model entities
    # points = [
    #   Geom::Point3d.new(0, 0, 1),
    #   Geom::Point3d.new(9, 0, 1),
    #   Geom::Point3d.new(9, 9, 1),
    #   Geom::Point3d.new(0, 9, 1),
    # ]
    # face = entities.add_face(points)
    # 
    # # Export an image to use as a texture
    # path = Sketchup.temp_dir
    # full_name = File.join(path, "temp_image.jpg")
    # model.active_view.write_image(full_name, 500, 500, false, 0.0)
    # 
    # # Create a material and assign the texture to it
    # material = model.materials.add("Test Material")
    # material.texture = full_name
    # 
    # # Assign the new material to our face we created
    # face.material = material
    # 
    # mapping = [
    #   Geom::Point3d.new(3,0,0), # Model coordinate
    #   Geom::Point3d.new(0,0,0), # UV coordinate
    # ]
    # on_front = true
    # face.position_material(material, mapping, on_front)
    # ```
    # 
    # _@see_ `#texture_positioned?`
    # 
    # _@see_ `#texture_projected?`
    # 
    # _@see_ `#get_texture_projection`
    # 
    # _@see_ `#clear_texture_projection`
    def position_material: (*untyped args) -> (Sketchup::Face | bool)

    # The pushpull method is used to perform a push/pull on a face.
    # 
    # The distance is measured in the direction that the face normal is pointing.
    # 
    # _@param_ `distance` — The distance to push/pull the face.
    # 
    # _@param_ `copy` — Create a new push/pull starting face if true (equivalent of pressing CTRL while in SketchUp), do not create a push/pull starting face if false.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # status = face.pushpull(100, true)
    # ```
    def pushpull: (Length distance, ?bool copy) -> void

    # The reverse! method is used to reverse the face's orientation, meaning the
    # front becomes the back.
    # 
    # _@return_ — the reversed Face object if successful, false if
    # unsuccessful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # status = face.reverse!
    # ```
    def reverse!: () -> (Sketchup::Face | bool)

    # The {#set_texture_projection} method is used to set the texture projection
    # direction.
    # 
    # _@param_ `vector` — representing the direction of the projection. Use +nil+ to remove the projection.
    # 
    # _@param_ `frontside` — +true+ for front side, +false+ for back side.
    # 
    # _@deprecated_ — This function never worked correctly. It's not capable of
    # controlling the position and orientation of the texture. In some cases it
    # produced an invalid model. As of SketchUp 2021.1 the method simply raises
    # +NotImplementedError+.
    # 
    # _@see_ `#position_material`
    # 
    # _@see_ `#clear_texture_projection`
    def set_texture_projection: (Geom::Vector3d vector, bool frontside) -> bool

    # The {#texture_positioned?} method is used to check if the face has a
    # texture that is positioned.
    # 
    # A texture is positioned when it's not using the default texture coordinates.
    # 
    # When a user uses the Paint Bucket Tool to apply a material sampled from the
    # Material Browser it will use default texture coordinates and not be
    # positioned. It will be positioned if the user uses the Position Texture Tool.
    # 
    # When an API user uses {Sketchup::Drawinglement#material=} the texture is not
    # positioned. It will be positioned when the API user uses
    # {Sketchup::Face#position_material}. It it also positioned of the face was
    # crafted via {Geom::PolygonMesh}.
    # 
    # _@param_ `front` — +true+ Checks the front side of the face, +false+ the back side.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # faces = entities.grep(Sketchup::Face).select { |face|
    #   face.texture_positioned?(true) || face.texture_positioned?(false)
    # }
    # ```
    # 
    # _@see_ `#position_material`
    # 
    # _@see_ `#material=`
    # 
    # _@see_ `#back_material=`
    def texture_positioned?: (bool front) -> bool

    # The {#texture_projected?} method is used to check if the face has a
    # texture that is projected.
    # 
    # A texture is projected when the user enables this property via the
    # Position Texture Tool.
    # 
    # It is also projected when the API user passes a projection vector to
    # {#position_material}.
    # 
    # _@param_ `front` — +true+ Checks the front side of the face, +false+ the back side.
    # 
    # _@see_ `#get_texture_projection`
    # 
    # _@see_ `#clear_texture_projection`
    # 
    # _@see_ `#position_material`
    def texture_projected?: (bool front) -> bool

    # The {#uv_tile_at} method is used to get the corner positions (model and UV)
    # of a UV tile.
    # 
    # The UV tile bounds the given reference point on the plane of the face. If the
    # reference isn't on the plane of the face it will be projected onto it.
    # 
    # The world coordinates are on the plane of the face unless the texture is
    # projected. When the texture is projected the the world points are on an
    # arbitrary plane that is perpendicular to the projection direction.
    # 
    # The returned coordinates are arranged to be compatible with {#position_material}.
    # 
    # <b>Getting the bounds of the UV tile under the cursor:</b>
    # 
    # <i>The red quadrilateral represents the model points returned.</i>
    # 
    # rdoc-image:../images/face-uv-tile-at.png
    # 
    # _@param_ `position` — Model position on the face's plane that will be bounded by the UV tile.
    # 
    # _@param_ `front` — +true+ Checks the front side of the face, +false+ the back side.
    # 
    # _@return_ — A set of 8 points. Each stride of two is
    # first a model space point, the second a UV
    # coordinate. +nil+ if the face doesn't have
    # a texture on the given side.
    # 
    # Copy material from front to back
    # ```ruby
    # model = Sketchup.active_model
    # model.active_entities.grep(Sketchup::Face) { |face|
    #   material = face.material
    # 
    #   if material&.texture.nil?
    #     face.back_material = material
    #   end
    # 
    #   reference = face.vertices.first.position
    #   mapping = face.uv_tile_at(reference, true)
    #   if face.texture_projected?(true)
    #     projection = face.get_texture_projection(true)
    #     face.position_material(material, mapping, false, projection)
    #   else
    #     face.position_material(material, mapping, false)
    #   end
    # }
    # ```
    # 
    # Iterate each set of world and UV coordinates
    # ```ruby
    # model = Sketchup.active_model
    # faces = model.active_entities.grep(Sketchup::Face)
    # face = faces.find { |face| face.material&.texture }
    # reference = face.vertices.first.position
    # mapping = face.uv_tile_at(reference, true)
    # mapping.each_slice(2) { |position, uv|
    #   puts "World: #{position.inspect} - UV: #{uv.inspect}"
    # }
    # ```
    # 
    # _@see_ `#position_material`
    def uv_tile_at: (Geom::Point3d position, bool front) -> ::Array[Geom::Point3d]?

    # The vertices method is used to get an array of all of the vertices that
    # bound the face.
    # 
    # _@return_ — an array of Vertex objects if successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # vertices = face.vertices
    # ```
    def vertices: () -> ::Array[Sketchup::Vertex]
  end

  # The {Sketchup::Http} module provides interfaces to create asynchronous HTTP
  # requests. This is an alternative to the Net::Http module that comes with
  # Ruby StdLib - which is known to have issues within SketchUp.
  # 
  # @version SketchUp 2017
  module Http
    DELETE: untyped
    GET: untyped
    HEAD: untyped
    OPTIONS: untyped
    PATCH: untyped
    POST: untyped
    PUT: untyped
    STATUS_CANCELED: untyped
    STATUS_FAILED: untyped
    STATUS_PENDING: untyped
    STATUS_SUCCESS: untyped
    STATUS_UNKNOWN: untyped

    # Http::Request objects allows you to send HTTP request to HTTP servers.
    # 
    # @version SketchUp 2017
    class Request
      # Gets the http body that is going to be used when sending the request.
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # 
      # @request.start do |request, response|
      #   puts "body: #{request.body}"
      # end
      # ```
      def body: () -> String

      # Sets the http body that is going to be used when sending the request.
      # 
      # _@param_ `body` — A String containing the body.
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # @request.body = "Hello World"
      # 
      # @request.start do |request, response|
      #   puts "body: #{request.body}"
      # end
      # ```
      def body=: (String body) -> String

      # Cancels the request.
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # @request.start do |request, response|
      #   puts "body: #{response.body}"
      # end
      # 
      # @request.cancel
      # ```
      def cancel: () -> bool

      # Returns the http headers that are going to be used when sending the request.
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # @request.headers = { :key1 => "value1", :key2 => "value2" }
      # 
      # @request.headers.each do |key, value|
      #   puts "#{key}: #{value}"
      # end
      # ```
      def headers: () -> ::Hash[untyped, untyped]

      # Sets the http headers that are going to be used when sending the request.
      # 
      # _@param_ `headers` — A key/value pair hash.
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # @request.headers = { :key1 => "value1", :key2 => "value2" }
      # 
      # @request.headers.each do |key, value|
      #   puts "#{key}: #{value}"
      # end
      # ```
      def headers=: (::Hash[untyped, untyped] headers) -> bool

      # The new method is used to create a new Sketchup::Http::Request.
      # 
      # The default port is 80, to use a different port define it in the URL when
      # creating a new {Sketchup::Http::Request}.
      # 
      # The +method+ parameter accepts any custom http method or one of the
      # following:
      # * +Sketchup::Http::GET+
      # * +Sketchup::Http::POST+
      # * +Sketchup::Http::PUT+
      # * +Sketchup::Http::DELETE+
      # * +Sketchup::Http::HEAD+
      # * +Sketchup::Http::OPTIONS+
      # 
      # _@param_ `url` — The targetted URL.
      # 
      # _@param_ `method` — Optionally, the request method to use, the default is Sketchup::Http::GET
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080", Sketchup::Http::GET)
      # 
      # @request.start do |request, response|
      #   puts "body: #{response.body}"
      # end
      # ```
      # 
      # _@note_ — If no reference is kept to the {Sketchup::Http::Request}, it can be garbage collected,
      # making the download silently fail. This is especially noticeable for larger downloads that
      # takes longer time.
      def initialize: (String url, String method) -> void

      # Returns the http method that is going to be used when sending the request.
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # 
      # @request.start do |request, response|
      #   puts "request.method: #{request.method}"
      # end
      # ```
      def method: () -> String

      # Sets the http method that is going to be used when sending the request.
      # The value can be any custom http method or one of the following:
      # * +Sketchup::Http::GET+
      # * +Sketchup::Http::POST+
      # * +Sketchup::Http::PUT+
      # * +Sketchup::Http::DELETE+
      # * +Sketchup::Http::HEAD+
      # * +Sketchup::Http::OPTIONS+
      # 
      # _@param_ `method` — A string containing the http method name.
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # @request.method = Sketchup::Http::POST
      # 
      # @request.start do |request, response|
      #   puts "request.method: #{request.method}"
      # end
      # ```
      def method=: (String method) -> bool

      # Adds a download progress callback block that will get called everytime we
      # have received data from the server until the download finishes.
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # 
      # @request.set_download_progress_callback do |current, total|
      #   if total == -1
      #     puts "#{current}B"
      #   else
      #     percentage = (current.to_f / total * 100).round
      #     puts "#{current}B / #{total}B (#{percentage}%)"
      #   end
      # end
      # 
      # @request.start
      # ```
      # 
      # _@note_ — +total+ is -1 if the server doesn't specify a file size in the response header.
      def set_download_progress_callback: () ?{ (Integer current, Integer total) -> void } -> bool

      # Adds a upload progress callback block that will get called everytime we have
      # uploaded data to the server until the upload finishes.
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # 
      # @request.set_upload_progress_callback do |current, total|
      #   puts "upload current: #{current}"
      #   puts "upload total: #{total}"
      # end
      # 
      # request.start
      # ```
      def set_upload_progress_callback: () ?{ (Integer current, Integer total) -> void } -> bool

      # Starts the request and optionally add a callback block.
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # 
      # @request.start do |request, response|
      #   puts "body: #{response.body}"
      # end
      # ```
      def start: () ?{ (Request request, Response response) -> void } -> bool

      # Returns the internal status code. It can be one of the following:
      # * +Sketchup::Http::STATUS_UNKNOWN+
      # * +Sketchup::Http::STATUS_SUCCESS+
      # * +Sketchup::Http::STATUS_PENDING+
      # * +Sketchup::Http::STATUS_CANCELED+
      # * +Sketchup::Http::STATUS_FAILED+
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # @request.start
      # puts "response.status: #{@request.status}"
      # ```
      def status: () -> Integer

      # Returns a copy of the Request's URL.
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # 
      # @request.start do |request, response|
      #   puts "url: #{request.url}"
      # end
      # ```
      def url: () -> String
    end

    # Http::Response objects allows you to get the response information from the
    # server, you can only receive the Http::Response if you have attached a
    # callback block when calling start from the Http::Request object.
    # 
    # @version SketchUp 2017
    class Response
      # Gets the http body that was received from the server as a string encoded
      # using the charset provided in the Content-Type of the server response, if
      # no charset is specified, ASCII-8BIT will be used.
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # 
      # @request.start do |request, response|
      #   puts "body: " + response.body
      # end
      # ```
      def body: () -> String

      # Returns the http headers that were sent by the server.
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # 
      # @request.start do |request, response|
      #   response.headers.each do |key, value|
      #     puts "#{key}: #{value}"
      #   end
      # end
      # ```
      def headers: () -> ::Hash[untyped, untyped]

      # Returns the HTTP response status code as defined in rfc2616.
      # 
      # ```ruby
      # @request = Sketchup::Http::Request.new("http://localhost:8080")
      # 
      # @request.start do |request, response|
      #   puts "http status code: #{response.status_code}"
      # end
      # ```
      def status_code: () -> Integer
    end
  end

  # Loop is a low level topology class that will not need to be used often. A
  # Loop is a chain of Edges that bound a Face.
  # 
  # @version SketchUp 6.0
  class Loop < Sketchup::Entity
    # Determine if the loop is convex.
    # 
    # _@return_ — status - true if convex, false if not convex.
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points = []
    # points << Geom::Point3d.new(0, 0, 0)
    # points << Geom::Point3d.new(100, 0, 0)
    # points << Geom::Point3d.new(100, 200, 0)
    # points << Geom::Point3d.new(0, 200, 0)
    # face = entities.add_face(points)
    # loop = face.outer_loop
    # if loop.convex?
    #   puts "Loop is convex."
    # else
    #   puts "Loop is not convex."
    # end
    # ```
    def convex?: () -> bool

    # Get an array of the edges that define the loop in an ordered sequence.
    # 
    # _@return_ — edges - an array of Edge objects if successful.
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points = []
    # points << Geom::Point3d.new(0, 0, 0)
    # points << Geom::Point3d.new(100, 0, 0)
    # points << Geom::Point3d.new(100, 200, 0)
    # points << Geom::Point3d.new(0, 200, 0)
    # face = entities.add_face(points)
    # loop = face.outer_loop
    # edges = loop.edges
    # ```
    def edges: () -> untyped

    # Get an array of the EdgeUse objects that define this loop in an ordered
    # sequence.
    # 
    # _@return_ — edgeuses - an array of EdgeUse objects if successful.
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points = []
    # points << Geom::Point3d.new(0, 0, 0)
    # points << Geom::Point3d.new(100, 0, 0)
    # points << Geom::Point3d.new(100, 200, 0)
    # points << Geom::Point3d.new(0, 200, 0)
    # face = entities.add_face(points)
    # loop = face.outer_loop
    # edgeuses = loop.edgeuses
    # ```
    def edgeuses: () -> untyped

    # Get the Face object that is bounded by this loop.
    # 
    # _@return_ — face - a Face object if successful
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points = []
    # points << Geom::Point3d.new(0, 0, 0)
    # points << Geom::Point3d.new(100, 0, 0)
    # points << Geom::Point3d.new(100, 200, 0)
    # points << Geom::Point3d.new(0, 200, 0)
    # face = entities.add_face(points)
    # loop = face.outer_loop
    # loop_face = loop.face
    # ```
    def face: () -> untyped

    # Determine if this is an outer loop. Each face has one outer loop, and will
    # have one loop for each hole.
    # 
    # _@return_ — status - true if the loop is an outer loop, false if it
    # is not an outer loop.
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points = []
    # points << Geom::Point3d.new(0, 0, 0)
    # points << Geom::Point3d.new(100, 0, 0)
    # points << Geom::Point3d.new(100, 200, 0)
    # points << Geom::Point3d.new(0, 200, 0)
    # face = entities.add_face(points)
    # loop = face.outer_loop
    # if loop.outer?
    #   puts "Loop is an outer loop."
    # else
    #   puts "Loop is not an outer loop."
    # end
    # ```
    def outer?: () -> bool

    # Get an array of the vertices that define the loop in an ordered sequence.
    # 
    # _@return_ — vertices - an array of Vertex objects if successful.
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points = []
    # points << Geom::Point3d.new(0, 0, 0)
    # points << Geom::Point3d.new(100, 0, 0)
    # points << Geom::Point3d.new(100, 200, 0)
    # points << Geom::Point3d.new(0, 200, 0)
    # face = entities.add_face(points)
    # loop = face.outer_loop
    # vertices = loop.vertices
    # ```
    def vertices: () -> untyped
  end

  # An interface to a menu.
  # 
  # @version SketchUp 6.0
  class Menu
    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#add_item} method is used to add a menu item to the specified menu.
    # 
    # This method takes a block that defines the action to perform when the menu
    # item is selected.
    # 
    # The item id that is returned can be used when adding an optional
    # validation procedure for the menu item.
    # 
    # ```ruby
    # menu = UI.menu('Plugins')
    # menu.add_item("Test") { puts 'Hello World' }
    # ```
    def add_item: (*untyped args) -> untyped

    # The {#add_separator} method is used to add a menu separator to a menu.
    # 
    # ```ruby
    # plugins_menu = UI.menu("Plugins")
    # plugins_menu.add_separator
    # ```
    def add_separator: () -> void

    # The {#add_submenu} method is used to add a sub-menu to a menu.
    # 
    # _@param_ `title` — The title of the sub menu.
    # 
    # _@return_ — a Menu object
    # 
    # ```ruby
    # plugins_menu = UI.menu("Plugins")
    # submenu = plugins_menu.add_submenu("Test")
    # submenu.add_item("Hello World") {
    #   UI.messagebox("Hi there!")
    # }
    # ```
    def add_submenu: (String title) -> Sketchup::Menu

    # sord omit - no YARD return type given, using untyped
    # The {#set_validation_proc} method is used to specify the menu validation
    # procedure. Your procedure should return either MF_ENABLED, MF_DISABLED,
    # MF_CHECKED, MF_UNCHECKED, or MF_GRAYED.
    # 
    # _@param_ `item` — The numerical identifier for the menu item.
    # 
    # ```ruby
    # plugins_menu = UI.menu("Plugins")
    # item = plugins_menu.add_item("Test") { UI.messagebox "My Test Item"}
    # status = plugins_menu.set_validation_proc(item)  {
    #   if Sketchup.is_pro?
    #     MF_ENABLED
    #   else
    #     MF_GRAYED
    #   end
    # }
    # ```
    def set_validation_proc: (Integer item) -> untyped
  end

  # The Page class contains methods to extract information and modify the
  # properties of an individual page.
  # 
  # Note that inside the SketchUp user interface pages are called "Scenes".
  # 
  # @version SketchUp 6.0
  class Page < Sketchup::Entity
    # The axes method returns the drawing axes for the page.
    # 
    # _@return_ — Axes - the axes for the page.
    # 
    # ```ruby
    # page = Sketchup.active_model.pages.add("Example Page")
    # xaxis = Geom::Vector3d.new(3, 5, 0)
    # yaxis = xaxis * Z_AXIS
    # page.axes.set([10,0,0], xaxis, yaxis, Z_AXIS)
    # ```
    def axes: () -> untyped

    # The camera method retrieves the camera for a particular page.
    # 
    # _@return_ — camera - a Camera object if successful, nil if the page
    # does not save camera information
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # camera = page.camera
    # ```
    def camera: () -> untyped

    # The delay_time method retrieves the amount of time, in seconds, that a page
    # will be displayed before transition to another page during a tour.
    # 
    # The default delay time can be modified in the Model Info > Animation panel
    # of the SketchUp User Interface. If this method returns -1, the default
    # delay time is used.
    # 
    # _@return_ — time - the number of seconds of delay
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # time = page.delay_time
    # ```
    def delay_time: () -> untyped

    # The delay_time= method sets the amount of time, in seconds, that a page will
    # be displayed before transitioning to another page during a tour. If you set
    # the delay for a page to be -1, the default delay time will be used.
    # 
    # The default delay time can be modified in the Model Info > Animation panel
    # of the SketchUp User Interface.
    # 
    # _@param_ `seconds` — The number of seconds to set as the delay time.
    # 
    # _@return_ — time - the number of seconds of delay
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # time = page.delay_time = 10
    # ```
    def delay_time=: (untyped seconds) -> untyped

    # The description method retrieves the description for a page as found in the
    # Scenes manager dialog.
    # 
    # _@return_ — description - a textual description for the page.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # description = page.description
    # ```
    def description: () -> untyped

    # The description method sets the description for a page as found in the
    # Scenes manager dialog.
    # 
    # _@param_ `description` — A string description for the page.
    # 
    # _@return_ — description - the new string description for the page
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # description = page.description = "This is my first page"
    # ```
    def description=: (untyped description) -> untyped

    # The {#get_drawingelement_visibility} method is used to get the visibility
    # of a drawing element on a particular page.
    # 
    # _@param_ `element`
    # 
    # _@return_ — - true if visible, false if not.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(10,0,0)
    # constpoint = entities.add_cpoint(point1)
    # pages = model.pages
    # page = pages.add("My Page")
    # result = page.get_drawingelement_visibility(constpoint)
    # ```
    def get_drawingelement_visibility: (Sketchup::Drawingelement element) -> bool

    # The hidden_entities method retrieves all hidden entities within a page.
    # 
    # _@return_ — entities - an Entities object containing hidden
    # entities on the page.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # entities = page.hidden_entities
    # ```
    def hidden_entities: () -> untyped

    # The {#include_in_animation=} method controls whether the page should be
    # included when exporting an animation from the model.
    # 
    # _@param_ `include`
    # 
    # Turn off animation for all pages.
    # ```ruby
    # model = Sketchup.active_model
    # model.pages.each { |page|
    #   page.include_in_animation = false
    # }
    # ```
    def include_in_animation=: (bool include) -> Sketchup::Page

    # The {#include_in_animation?} method determines whether the page should be
    # included when exporting an animation from the model.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # in_animation = model.pages.select { |page| page.include_in_animation? }
    # ```
    def include_in_animation?: () -> bool

    # The label method retrieves the label for a page from the page tab.
    # 
    # _@return_ — label - a string label for the page tab
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # label = page.label
    # ```
    def label: () -> untyped

    # The {#layer_folders} method retrieves the hidden layer folders
    # associated with a page.
    # 
    # _@return_ — Returns +nil+ if {#use_hidden_layers?}
    # returns +false+
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add("My Page")
    # folders = page.layer_folders
    # ```
    def layer_folders: () -> ::Array[Sketchup::LayerFolder]?

    # The {#layers} method retrieves layers that don't use their default visibility
    # on this page.
    # 
    # _@return_ — Returns +nil+ if {#use_hidden_layers?}
    # returns +false+
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add("My Page")
    # layers = page.layers
    # ```
    # 
    # Test layer visibility
    # ```ruby
    # def visible_in_scene?(layer, scene)
    #   scene.layers.include?(layer) == hidden_by_default?(layer)
    # end
    # 
    # def hidden_by_default?(layer)
    #   layer.page_behavior & LAYER_HIDDEN_BY_DEFAULT == LAYER_HIDDEN_BY_DEFAULT
    # end
    # ```
    def layers: () -> ::Array[Sketchup::Layer]?

    # The name method retrieves the name for a page from the page tab.
    # 
    # _@return_ — label - a string name for the page tab
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # name = page.name
    # ```
    def name: () -> untyped

    # The name= method sets the name for a page's tab.
    # 
    # _@param_ `name` — The name of the page to be set.
    # 
    # _@return_ — name - the name that you have set
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # name = page.name = "Page Name"
    # ```
    def name=: (untyped name) -> untyped

    # The rendering_options method retrieves a RenderingOptions object for the
    # page.
    # 
    # _@return_ — renderingoptions - a RenderingOptions object
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # renderingoptions = page.rendering_options
    # ```
    def rendering_options: () -> untyped

    # The {#set_drawingelement_visibility} method is used to change the visibility
    # of a drawing element on a particular page. Only drawing elements on the root
    # of the model, as well as nested instances of components, groups, and images
    # are controlled by Page visibility.
    # 
    # _@param_ `element`
    # 
    # _@param_ `visibility`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(10, 0, 0)
    # constpoint = entities.add_cpoint(point1)
    # pages = model.pages
    # page = pages.add("My Page")
    # page.set_drawingelement_visibility(constpoint, false)
    # ```
    def set_drawingelement_visibility: (Sketchup::Drawingelement element, bool visibility) -> bool

    # sord omit - no YARD type given for "arg1", using untyped
    # sord omit - no YARD type given for "arg2", using untyped
    # The {#set_visibility} method sets the visibility for a layer or
    # layer folder on a page.
    # 
    # _@return_ — the page whose visibility was set.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add("My Page")
    # layer = model.layers.add("My Layer")
    # page.set_visibility(layer, false)
    # ```
    def set_visibility: (untyped arg1, untyped arg2) -> Sketchup::Page

    # The shadow_info method retrieves the ShadowInfo object for the page.
    # 
    # _@return_ — shadowinfo - a ShadowInfo object if successful, nil if
    # the page does not save shadow information
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # shadowinfo = page.shadow_info
    # ```
    def shadow_info: () -> untyped

    # The style method retrieves the style associated with the page.
    # 
    # _@return_ — style - the Style object if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # style = page.style
    # ```
    def style: () -> untyped

    # Get the amount of time that it takes to transition to this page during a
    # slideshow or animation export.  If this value is -1, it means to use the
    # default transition time.
    # 
    # _@return_ — transitiontime - the amount of time it takes to
    # transition to this page during a slideshow or animation
    # export.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # time = page.transition_time
    # ```
    def transition_time: () -> untyped

    # The transition_time= method is used to set the transition time.
    # 
    # _@param_ `trans_time` — The transition time in seconds.
    # 
    # _@return_ — transitiontime - the new transition time
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # time = page.transition_time=20
    # ```
    def transition_time=: (untyped trans_time) -> untyped

    # The {#update} method performs an update on the page properties based on the
    # current view that the user has. What properties of the Page get updated are
    # controlled via an integer whose bits corresponds to different properties.
    # These flags can be used individually or combined using bitwise OR.
    # 
    #   PAGE_USE_CAMERA            # Camera Location
    #   PAGE_USE_RENDERING_OPTIONS # Drawing Style
    #   PAGE_USE_SHADOWINFO        # Shadow Setting
    #   PAGE_USE_SKETCHCS          # Axes Location
    #   PAGE_USE_HIDDEN            # Hidden Geometry & Objects (Up 2019 and older)
    #   PAGE_USE_HIDDEN_GEOMETRY   # Hidden Geometry (SU 2020 and later)
    #   PAGE_USE_HIDDEN_OBJECTS    # Hidden Objects (SU 2020 and later)
    #   PAGE_USE_LAYER_VISIBILITY  # Visible Layers
    #   PAGE_USE_SECTION_PLANES    # Active Section Planes
    #   PAGE_USE_ALL               # All possible scene properties
    # 
    # _@param_ `flags` — The bitwise OR of the bit flags.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # status = page.update
    # 
    # # Updates Camera Location, Shadow Settings and Visible Layers.
    # flags = PAGE_USE_CAMERA | PAGE_USE_SHADOWINFO | PAGE_USE_LAYER_VISIBILITY
    # status = page.update(flags)
    # ```
    def update: (Integer flags) -> bool

    # The use_axes= method sets the page's axes property.
    # 
    # _@param_ `pagesettings` — true if you want your page to save this property, false if you do not want your page to save this property.
    # 
    # _@return_ — status - true if you are saving the property, false if
    # you are not saving the property.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # # Set use_axes to false
    # status = page.use_axes=false
    # ```
    def use_axes=: (untyped pagesettings) -> untyped

    # The use_axes? method determines whether you are storing the axes property
    # with the page.
    # 
    # _@return_ — status - true if you are storing the this property with
    # the page, false if you are not storing this property
    # with the page.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # status = page.use_axes?
    # ```
    def use_axes?: () -> bool

    # The use_camera= method sets the page's camera property.
    # 
    # _@param_ `setting` — true if you want your page to save this property, false if you do not want your page to save this property.
    # 
    # _@return_ — status - true if you are saving the property, false if
    # you are not saving the property.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # status = page.use_camera = true
    # ```
    def use_camera=: (untyped setting) -> untyped

    # The use_camera? method determines whether you are storing the camera
    # property with the page.
    # 
    # _@return_ — status - true if you are storing the this property with
    # the page, false if you are not storing this property
    # with the page.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # status = page.use_camera?
    # ```
    def use_camera?: () -> bool

    # The use_hidden= method sets the page's hidden property.
    # 
    # _@param_ `setting` — true if you want your page to save this property, false if you do not want your page to save this property.
    # 
    # _@return_ — status - true if you are saving the property, false if
    # you are not saving the property.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # status = page.use_hidden = false
    # ```
    # 
    # _@deprecated_ — The functionality is replaced by {use_hidden_geometry=}
    # and {use_hidden_objects=} in SketchUp 2020.1.
    # 
    # _@see_ `#use_hidden_geometry=`
    # 
    # _@see_ `#use_hidden_objects=`
    def use_hidden=: (untyped setting) -> untyped

    # The use_hidden? method determines whether you are storing the hidden
    # property with the page.
    # 
    # _@return_ — status - true if you are storing the this property with
    # the page, false if you are not storing this property
    # with the page.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add("My Page")
    # status = page.use_hidden?
    # ```
    # 
    # _@deprecated_ — The functionality is replaced by {use_hidden_geometry?}
    # and {use_hidden_objects?} in SketchUp 2020.1.
    # 
    # _@see_ `#use_hidden_geometry?`
    # 
    # _@see_ `#use_hidden_objects?`
    def use_hidden?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # Sets the page's use hidden geometry property.
    # 
    # _@param_ `setting` — `true` if you want your page to save this property, `false` if you do not want your page to save this property.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add("My Page")
    # status = page.use_hidden_geometry = false
    # ```
    def use_hidden_geometry=: (bool setting) -> untyped

    # Returns the use hidden geometry property from the page.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add("My Page")
    # status = page.use_hidden_geometry?
    # ```
    def use_hidden_geometry?: () -> bool

    # The use_hidden_layers= method sets the page's hidden layers
    # property.
    # 
    # _@param_ `setting` — true if you want your page to save this property, false if you do not want your page to save this property.
    # 
    # _@return_ — status - true if you are saving the property, false if
    # you are not saving the property.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # status = page.use_hidden_layers = false
    # ```
    def use_hidden_layers=: (untyped setting) -> untyped

    # The use_hidden_layers? method determines whether you are storing the hidden
    # layers property with the page.
    # 
    # _@return_ — status - true if you are storing the this property with
    # the page, false if you are not storing this property
    # with the page.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # status = page.use_hidden_layers?
    # ```
    def use_hidden_layers?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # Sets the page's use hidden objects property.
    # 
    # _@param_ `setting` — `true` if you want your page to save this property, `false` if you do not want your page to save this property.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add("My Page")
    # status = page.use_hidden_objects = false
    # ```
    def use_hidden_objects=: (bool setting) -> untyped

    # Returns the use hidden objects property from the page.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add("My Page")
    # status = page.use_hidden_objects?
    # ```
    def use_hidden_objects?: () -> bool

    # The use_rendering_optoins= method sets the page's display
    # settings property.
    # 
    # _@param_ `setting` — true if you want your page to save this property, false if you do not want your page to save this property.
    # 
    # _@return_ — status - true if you are saving the property, false
    # if you are not saving the property.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # status = page.use_rendering_options = false
    # ```
    def use_rendering_options=: (untyped setting) -> untyped

    # The use_rendering_options? method determines whether you are storing the
    # rendering options property with the page.
    # 
    # _@return_ — status - true if you are storing the this property with
    # the page, false if you are not storing this property
    # with the page.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # status = page.use_rendering_options?
    # ```
    def use_rendering_options?: () -> bool

    # The use_section_planes= method sets the page's section planes
    # property.
    # 
    # _@param_ `setting` — true if you want your page to save this property, false if you do not want your page to save this property.
    # 
    # _@return_ — status - true if you are saving the property, false if
    # you are not saving the property.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # status = page.use_section_planes=false
    # ```
    def use_section_planes=: (untyped setting) -> untyped

    # The use_section_planes? method determines whether you are storing the
    # section planes property with the page.
    # 
    # _@return_ — status - true if you are storing the this property with
    # the page, false if you are not storing this property
    # with the page.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # status = page.use_section_planes?
    # ```
    def use_section_planes?: () -> bool

    # The use_shadow_info= method sets the page's shadow info property.
    # 
    # _@param_ `setting` — true if you want your page to save this property, false if you do not want your page to save this property.
    # 
    # _@return_ — status - true if you are saving the property, false if
    # you are not saving the property.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # status = page.use_shadow_info=false
    # ```
    def use_shadow_info=: (untyped setting) -> untyped

    # The use_shadow_info? method determines whether you are storing the shadow
    # info property with the page.
    # 
    # _@return_ — status - true if you are storing the this property with
    # the page, false if you are not storing this property
    # with the page.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # status = page.use_shadow_info?
    # ```
    def use_shadow_info?: () -> bool

    # The use_style= method sets the style to be used by the page.
    # 
    # _@param_ `style` — The Style object to use.
    # 
    # _@return_ — nil
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # style = model.styles[0]
    # page.use_style = style
    # ```
    def use_style=: (untyped style) -> untyped

    # The use_style? method determines whether storing a style with the page.
    # 
    # _@return_ — status - true if you are storing the this property with
    # the page, false if you are not storing this property
    # with the page.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # page = pages.add "My Page"
    # use_style = page.use_style?
    # ```
    def use_style?: () -> bool
  end

  # The Text class contains method to manipulate a Text entity object.
  # 
  # @version SketchUp 6.0
  class Text < Sketchup::Drawingelement
    # The arrow_type method retrieves the current arrow type used for the leader
    # text.
    # 
    # Valid arrow types are 0 for none, 2 for dot, 3 for closed arrow, 4 for open
    # arrow.
    # 
    # _@return_ — a numerical representation for the type of
    # arrow.
    # 
    # ```ruby
    # type = text.arrow_type=0
    # ```
    def arrow_type: () -> Integer

    # The arrow_type= method sets the arrow type used for leader text.
    # 
    # Valid arrow types are 0 for none, 2 for dot, 3 for closed arrow, 4 for open
    # arrow.
    # 
    # _@param_ `type` — A numerical representation of the type of arrow to be set.
    # 
    # _@return_ — a numerical representation for the type of
    # arrow.
    # 
    # ```ruby
    # arrow = text.arrow_type=type
    # ```
    def arrow_type=: (Integer _type) -> Integer

    # The {#attached_to} method returns an array of the attached
    # {Sketchup::InstancePath} object and the {Geom::Point3d}.
    # 
    # ```ruby
    # # Have a text annotation attached to a drawing element and selected
    # Sketchup.active_model.selection[0].attached_to
    # ```
    def attached_to: () -> [Sketchup::InstancePath, Geom::Point3d]?

    # sord omit - no YARD return type given, using untyped
    # The {#attached_to=} method will attach the {Sketchup::Text} to another
    # {Sketchup::DrawingElement}.
    # 
    # _@param_ `path`
    # 
    # ```ruby
    # # Have a text annotation attached to a drawing element and selected
    # array = Sketchup.active_model.selection[0].attached_to
    # Sketchup.active_model.selection[0].attached_to = [array[0], Geom::Point3d.new(0, 0, 0)]
    # ```
    def attached_to=: ([Sketchup::InstancePath, Geom::Point3d] path) -> untyped

    # The display_leader= method accepts true or false for whether to display the
    # leader.
    # 
    # Leader text that is not displayed is set to Hidden type.
    # 
    # _@param_ `status` — true if you want to display the leader text, false if you do not want to display the leader text.
    # 
    # _@return_ — the status that you set.
    # 
    # ```ruby
    # leader = text.display_leader=true
    # ```
    def display_leader=: (bool status) -> bool

    # The display_leader? method returns the status of the leader.
    # 
    # ```ruby
    # status = text.display_leader
    # ```
    def display_leader?: () -> bool

    # The has_leader method is used to determine if the Text object has a leader.
    # 
    # ```ruby
    # status = text.has_leader
    # ```
    def has_leader?: () -> bool

    # The leader_type method retrieves the currently set leader type.
    # 
    # _@return_ — a numerical value representing the currently
    # set leader type.
    # 
    # ```ruby
    # leader = text.leader_type
    # ```
    def leader_type: () -> Integer

    # The leader_type = method sets the leader type.
    # 
    # Valid leader types are 0 for none, 1 for View-based, and 2 for Pushpin
    # 
    # _@param_ `type` — A numerical value representing the leader type to be set.
    # 
    # _@return_ — a numerical value representing the leader type
    # you just set.
    # 
    # ```ruby
    # leader = text.leader_type=1
    # ```
    def leader_type=: (Integer _type) -> Integer

    # The line_weight method returns a line weight in number of pixels.
    # 
    # Defalt line weight is 1.
    # 
    # _@return_ — the line weight in pixels
    # 
    # ```ruby
    # weight = text.line_weight
    # ```
    def line_weight: () -> Integer

    # The line_weight= method sets the line weight in pixels.
    # 
    # Default line weight is 1.
    # 
    # _@param_ `weight` — The line weight to be set (in pixels).
    # 
    # _@return_ — The line weight that has been set.
    # 
    # ```ruby
    # newweight = text.line_weight = 4
    # ```
    def line_weight=: (Integer weight) -> Integer

    # The point method is used to get the point associated with the text.
    # 
    # _@return_ — a Point3d object.
    # 
    # ```ruby
    # point3d = text.point
    # ```
    def point: () -> Geom::Point3d

    # The point= method is used to set the point associated with the text.
    # 
    # _@param_ `point3d` — A Point3d object.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # status = text.point = point3d
    # ```
    def point=: (Geom::Point3d point3d) -> Geom::Point3d

    # The set_text method is used to set the text within a Text object without
    # recording an Undo operation.
    # 
    # _@param_ `textstring` — The string to be set within the Text object.
    # 
    # _@return_ — the Text object
    # 
    # ```ruby
    # text = text.set_text "This is another text"
    # ```
    def set_text: (String textstring) -> Sketchup::Text

    # The text method is used to retrieve the string version of a Text object.
    # 
    # _@return_ — the string representation of the Text
    # object
    # 
    # ```ruby
    # textstring = text.text
    # ```
    def text: () -> String

    # The text= method is used to set the string version of a Text object.
    # 
    # _@param_ `textstring`
    # 
    # _@return_ — the newly set text
    # 
    # ```ruby
    # textstring = text.text= "text"
    # ```
    def text=: (String textstring) -> String

    # The vector method is used to get the vector associated with the text.
    # 
    # _@return_ — a Vector3d object.
    # 
    # ```ruby
    # vector = text.vector
    # ```
    def vector: () -> Geom::Vector3d

    # The vector= method is used to set the vector associated with the text.
    # 
    # _@param_ `vector` — A Vector3d object.
    # 
    # ```ruby
    # vector = text.vector
    # ```
    def vector=: (Geom::Vector3d vector) -> Geom::Vector3d
  end

  # Tool is the interface that you implement to create a SketchUp tool.
  # See
  # {our code
  # example}[https://github.com/SketchUp/sketchup-ruby-api-tutorials/tree/main/examples/02_custom_tool]
  # for how to create a custom tool in Ruby.
  # 
  # To create a new tool in Ruby, you must define a new class that implements
  # the methods for the events that you want to respond to. You do not have
  # to implement methods for every possible event that a Tool can respond to.
  # 
  # Once you have defined a tool class, you select that tool by creating an
  # instance of it and passing it to {Sketchup::Model#select_tool}. For
  # example:
  # 
  #   class MyTool
  #     def activate
  #       puts 'Your tool has been activated.'
  #     end
  #   end
  # 
  #   my_tool = MyTool.new
  #   Sketchup.active_model.select_tool(my_tool)
  # 
  # The following table contains several constants you can use when check for
  # certain key presses inside the keyboard handling callbacks:
  # 
  # - +CONSTRAIN_MODIFIER_KEY+ = Shift Key
  # - +CONSTRAIN_MODIFIER_MASK+ = Shift Key
  # - +COPY_MODIFIER_KEY+ = Alt/Option on Mac, Ctrl on PC
  # - +COPY_MODIFIER_MASK+ = Alt/Option on Mac, Ctrl on PC
  # - +ALT_MODIFIER_KEY+ = Command on Mac, Alt on PC
  # - +ALT_MODIFIER_MASK+ = Command on Mac, Alt on PC
  # 
  # @abstract Implement the methods described in this class to create a tool.
  #   You can not sub-class this class because it is not defined by the API.
  # 
  # @version SketchUp 6.0
  class Tool
    # sord omit - no YARD return type given, using untyped
    # The {#activate} method is called by SketchUp when the tool is selected.
    # It is a good place to put most of your initialization, such as instance
    # variables to track the state of the tool.
    # 
    # ```ruby
    # def activate
    #   puts 'Your tool has been activated.'
    # end
    # ```
    def activate: () -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#deactivate} method is called when the tool is deactivated because a
    # different tool was selected.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def deactivate(view)
    #   puts "Your tool has been deactivated in view: #{view}"
    # end
    # ```
    def deactivate: (Sketchup::View view) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#draw} method is called by SketchUp whenever the view is refreshed to
    # allow the tool to do its own drawing. If the tool has some temporary graphics
    # that it wants displayed while it is active, it should implement this method
    # and draw to the {Sketchup::View}.
    # 
    # _@param_ `view` — A View object where the method was invoked.
    # 
    # ```ruby
    # def draw(view)
    #   # Draw a square.
    #   points = [
    #     Geom::Point3d.new(0, 0, 0),
    #     Geom::Point3d.new(9, 0, 0),
    #     Geom::Point3d.new(9, 9, 0),
    #     Geom::Point3d.new(0, 9, 0)
    #   ]
    #   # Fill
    #   view.drawing_color = Sketchup::Color.new(255, 128, 128)
    #   view.draw(GL_QUADS, points)
    #   # Outline
    #   view.line_stipple = '' # Solid line
    #   view.drawing_color = Sketchup::Color.new(64, 0, 0)
    #   view.draw(GL_LINE_LOOP, points)
    # end
    # ```
    # 
    # _@note_ — If you draw outside the model bounds you need to implement
    # {Tool#getExtents} which return a bounding box large enough to include the
    # points you draw. Otherwise your drawing will be clipped.
    # 
    # _@see_ `getExtents`
    # 
    # _@see_ `Sketchup::View#draw`
    def draw: (Sketchup::View view) -> untyped

    # The {#enableVCB?} method is used to tell SketchUp whether to allow the user
    # to enter text into the VCB (value control box, aka the "measurements" panel).
    # If you do not implement this method, then the vcb is disabled by default.
    # 
    # _@return_ — Return +true+ if you want the VCB enabled
    # 
    # ```ruby
    # # For this tool, allow vcb text entry while the tool is active.
    # def enableVCB?
    #   return true
    # end
    # ```
    def enableVCB?: () -> bool

    # In order to accurately draw things, SketchUp needs to know the extents of
    # what it is drawing. If the tool is doing its own drawing, it may need to
    # implement this method to tell SketchUp the extents of what it will be
    # drawing. If you don't implement this method, you may find that part of what
    # the tool is drawing gets clipped to the extents of the rest of the
    # model.
    # 
    # This must return a {Geom::BoundingBox}. In a typical implementation, you
    # will create a new {Geom::BoundingBox}, add points to set the extents of the
    # drawing that the tool will do and then return it.
    # 
    # ```ruby
    # def getExtents
    #   bb = Sketchup.active_model.bounds
    #   return bb
    # end
    # ```
    def getExtents: () -> Geom::BoundingBox

    # The {#getInstructorContentDirectory} method is used to tell SketchUp the
    # directory containing your Tool's instructor content. To use this, create
    # a custom instructor directory, put an index.html file inside of it, and then
    # return that path via this method. If the SketchUp user has the Instructor
    # window open when they activate your tool, they will see your html file.
    # 
    # _@return_ — the directory path where the Instructor content exists.
    # 
    # ```ruby
    # def getInstructorContentDirectory
    #   extension_path = Sketchup.extensions['MyExtension].extension_path
    #   instructor_path = File.join(extension_path, 'MyExtension', 'instructor')
    #   return instructor_path
    # end
    # ```
    # 
    # _@note_ — Prior to SketchUp 2014 this method would assume the path was relative
    # to the SketchUp resource folder. From 2014 and onwards you can specify the
    # absolute path to an HTML file or the absolute path to a directory
    # containing an index.html file.
    def getInstructorContentDirectory: () -> String

    # sord omit - no YARD type given for "*args", using untyped
    # The {#getMenu} method is called by SketchUp to let the tool provide its own
    # context menu. Most tools will not want to implement this method and,
    # instead, use the normal context menu found on all entities.
    # 
    # If you do implement this method, the argument is a Menu. You should use the
    # add_item method to build the context menu.
    # 
    # Your tool will use a standard context menu by default if you do not
    # implement this method. Implement this method if you want a context-click to
    # display something other than this default context menu.
    # 
    # In SketchUp 2015 the flags, x, y and view parameters were added. They are
    # needed if you need to pick the entities under the mouse position. The new
    # parameters are optional, but if you need to use one you must include them
    # all.
    # 
    # _@return_ — nil
    # 
    # ```ruby
    # if Sketchup.version.to_i < 15
    #   # Compatible with SketchUp 2014 and older:
    #   def getMenu(menu)
    #     menu.add_item('Say Hello') {
    #       UI.messagebox('Hello')
    #     }
    #   end
    # else
    #   # Only works with SketchUp 2015 and newer:
    #   def getMenu(menu, flags, x, y, view)
    #     ph = view.pick_helper(x, y)
    #     entity = ph.best_picked
    #     if entity
    #       view.model.selection.clear
    #       view.model.selection.add(entity)
    #       menu.add_item("Erase #{entity.typename}") {
    #         entity.erase!
    #       }
    #    end
    #  end
    # end
    # ```
    def getMenu: (*untyped args) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#onCancel} method is called by SketchUp to cancel the current operation
    # of the tool. The typical response will be to reset the tool to its initial
    # state.
    # 
    # The reason identifies the action that triggered the call. The reason can be
    # one of the following values:
    # 
    # - +0+: the user canceled the current operation by hitting the escape key.
    # - +1+: the user re-selected the same tool from the toolbar or menu.
    # - +2+: the user did an undo while the tool was active.
    # 
    # _@param_ `reason` — A reason value (see comments).
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onCancel(reason, view)
    #   puts "MyTool was canceled for reason ##{reason} in view: #{view}"
    # end
    # ```
    # 
    # _@note_ — When something is undone {#onCancel} is called before the undo is
    # actually executed. If you need to do something with the model after an undo
    # use {Sketchup::ModelObserver#onTransactionUndo}.
    # 
    # _@note_ — When {#onKeyDown} is implemented and returns +true+, pressing Esc
    # doesn't trigger {#onCancel}.
    def onCancel: (Integer reason, Sketchup::View view) -> untyped

    # The {#onKeyDown} method is called by SketchUp when the user presses a key on
    # the keyboard. If you want to get input from the VCB, you should implement
    # onUserText rather than this method.
    # 
    # This method is can be used for special keys such as the Shift key, Ctrl key,
    # and so on, or for just determining which key a user pressed. This method is
    # actually called for all keys that are pressed.
    # 
    # There are several
    # "virtual keys" defined as constants you can use.  Their use is cross
    # platform. They are:
    # 
    # - +VK_ALT+
    # - +VK_COMMAND+
    # - +VK_CONTROL+
    # - +VK_DELETE+
    # - +VK_DOWN+
    # - +VK_END+
    # - +VK_HOME+
    # - +VK_INSERT+
    # - +VK_LEFT+
    # - +VK_MENU+
    # - +VK_NEXT+
    # - +VK_PRIOR+
    # - +VK_RIGHT+
    # - +VK_SHIFT+
    # - +VK_SPACE+
    # - +VK_UP+
    # 
    # V6: There is a bug on Windows where the typematic effect does
    # not work. Typematic effects work fine on a Mac.
    # 
    # _@param_ `key` — The key that was pressed.
    # 
    # _@param_ `repeat` — A value of 1 for a single press of a key.  A value of 2 if the user has pressed a key and is holding it down.
    # 
    # _@param_ `flags` — A bit mask that tells the state of the modifier keys at the time of the event.
    # 
    # _@param_ `view`
    # 
    # _@return_ — Return +true+ to prevent SketchUp from processing the
    # event.
    # 
    # ```ruby
    # def onKeyDown(key, repeat, flags, view)
    #   puts "onKeyDown: key = #{key}"
    #   puts "        repeat = #{repeat}"
    #   puts "         flags = #{flags}"
    #   puts "          view = #{view}"
    # end
    # ```
    def onKeyDown: (
                     Integer key,
                     Integer repeat,
                     Integer flags,
                     Sketchup::View view
                   ) -> bool

    # The {#onKeyUp} method is called by SketchUp when the user releases a key on
    # the keyboard.
    # 
    # _@param_ `key` — The key that was pressed.
    # 
    # _@param_ `repeat` — A value of 1 for a single press of a key.  A value of 2 if the user has pressed a key and is holding it down.
    # 
    # _@param_ `flags` — A bit mask that tells the state of the modifier keys at the time of the event.
    # 
    # _@param_ `view`
    # 
    # _@return_ — Return +true+ to prevent SketchUp from processing the
    # event.
    # 
    # ```ruby
    # def onKeyUp(key, repeat, flags, view)
    #   puts "onKeyUp: key = #{key}"
    #   puts "      repeat = #{repeat}"
    #   puts "       flags = #{flags}"
    #   puts "        view = #{view}"
    # end
    # ```
    def onKeyUp: (
                   Integer key,
                   Integer repeat,
                   Integer flags,
                   Sketchup::View view
                 ) -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#onLButtonDoubleClick} is called by SketchUp when the user double clicks
    # with the left mouse button.
    # 
    # _@param_ `flags` — A bit mask that tells the state of the modifier keys and other mouse buttons at the time.
    # 
    # _@param_ `x` — The X coordinate on the screen where the event occurred.
    # 
    # _@param_ `y` — The Y coordinate on the screen where the event occurred.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onLButtonDoubleClick(flags, x, y, view)
    #   puts "onLButtonDoubleClick: flags = #{flags}"
    #   puts "                          x = #{x}"
    #   puts "                          y = #{y}"
    #   puts "                       view = #{view}"
    # end
    # ```
    def onLButtonDoubleClick: (
                                Integer flags,
                                Integer x,
                                Integer y,
                                Sketchup::View view
                              ) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#onLButtonDown} method is called by SketchUp when the left mouse button
    # is pressed. Most tools will implement this method.
    # 
    # _@param_ `flags` — A bit mask that tells the state of the modifier keys and other mouse buttons at the time.
    # 
    # _@param_ `x` — The X coordinate on the screen where the event occurred.
    # 
    # _@param_ `y` — The Y coordinate on the screen where the event occurred.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onLButtonDown(flags, x, y, view)
    #   puts "onLButtonDown: flags = #{flags}"
    #   puts "                   x = #{x}"
    #   puts "                   y = #{y}"
    #   puts "                view = #{view}"
    # end
    # ```
    def onLButtonDown: (
                         Integer flags,
                         Integer x,
                         Integer y,
                         Sketchup::View view
                       ) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#onLButtonUp} method is called by SketchUp when the left mouse button is
    # released.
    # 
    # _@param_ `flags` — A bit mask that tells the state of the modifier keys and other mouse buttons at the time.
    # 
    # _@param_ `x` — The X coordinate on the screen where the event occurred.
    # 
    # _@param_ `y` — The Y coordinate on the screen where the event occurred.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onLButtonUp(flags, x, y, view)
    #   puts "onLButtonUp: flags = #{flags}"
    #   puts "                 x = #{x}"
    #   puts "                 y = #{y}"
    #   puts "              view = #{view}"
    # end
    # ```
    def onLButtonUp: (
                       Integer flags,
                       Integer x,
                       Integer y,
                       Sketchup::View view
                     ) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#onMButtonDoubleClick} method is called by SketchUp when the middle
    # mouse button (on a three button mouse) is double-clicked.
    # 
    # Only implement this method if you want SketchUp to react to a middle mouse
    # button being double-clicked.
    # 
    # _@param_ `flags` — A bit mask that tells the state of the modifier keys and other mouse buttons at the time.
    # 
    # _@param_ `x` — The X coordinate on the screen where the event occurred.
    # 
    # _@param_ `y` — The Y coordinate on the screen where the event occurred.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onMButtonDoubleClick(flags, x, y, view)
    #   puts "onMButtonDoubleClick: flags = #{flags}"
    #   puts "                          x = #{x}"
    #   puts "                          y = #{y}"
    #   puts "                       view = #{view}"
    # end
    # ```
    # 
    # _@note_ — Though this method has been documented in the Ruby API for many years,
    # it has never worked properly. We are leaving this documentation in place
    # for now in the hopes of fixing the implementation, but you won't have any
    # luck trying to use it in SU7 and earlier.
    def onMButtonDoubleClick: (
                                Integer flags,
                                Integer x,
                                Integer y,
                                Sketchup::View view
                              ) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#onMButtonDown} method is called by SketchUp when the middle mouse
    # button (on a three button mouse) is down.
    # 
    # The Orbit tool is activated by default when the middle mouse button is down.
    # Implement this method if you want a middle mouse button to do something
    # other than invoke the Orbit tool.
    # 
    # _@param_ `flags` — A bit mask that tells the state of the modifier keys and other mouse buttons at the time.
    # 
    # _@param_ `x` — The X coordinate on the screen where the event occurred.
    # 
    # _@param_ `y` — The Y coordinate on the screen where the event occurred.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onMButtonDown(flags, x, y, view)
    #   puts "onMButtonDown: flags = #{flags}"
    #   puts "                    x = #{x}"
    #   puts "                    y = #{y}"
    #   puts "                 view = #{view}"
    # end
    # ```
    def onMButtonDown: (
                         Integer flags,
                         Integer x,
                         Integer y,
                         Sketchup::View view
                       ) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#onMButtonUp} method is called by SketchUp when the middle mouse button
    # (on a three button mouse) is released.
    # 
    # SketchUp returns to the previous tool from the Orbit tool when the middle
    # mouse button is released. Implement this method if you want a middle mouse
    # button to do something other than return to the previous tool when in the
    # Orbit tool.
    # 
    # _@param_ `flags` — A bit mask that tells the state of the modifier keys and other mouse buttons at the time.
    # 
    # _@param_ `x` — The X coordinate on the screen where the event occurred.
    # 
    # _@param_ `y` — The Y coordinate on the screen where the event occurred.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onMButtonUp(flags, x, y, view)
    #   puts "onMButtonUp: flags = #{flags}"
    #   puts "                  x = #{x}"
    #   puts "                  y = #{y}"
    #   puts "               view = #{view}"
    # end
    # ```
    def onMButtonUp: (
                       Integer flags,
                       Integer x,
                       Integer y,
                       Sketchup::View view
                     ) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#onMouseEnter} method is called by SketchUp when the mouse enters the
    # viewport.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onMouseEnter(view)
    #   puts "onMouseEnter: view = #{view}"
    # end
    # ```
    def onMouseEnter: (Sketchup::View view) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#onMouseLeave} method is called by SketchUp when the mouse leaves the
    # viewport.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onMouseLeave(view)
    #   puts "onMouseLeave: view = #{view}"
    # end
    # ```
    def onMouseLeave: (Sketchup::View view) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#onMouseMove} method is called by SketchUp whenever the mouse is moved.
    # You will often want to implement this method.
    # 
    # Try to make this method as efficient as possible because this method is
    # called often.
    # 
    # _@param_ `flags` — A bit mask that tells the state of the modifier keys and other mouse buttons at the time.
    # 
    # _@param_ `x` — The X coordinate on the screen where the event occurred.
    # 
    # _@param_ `y` — The Y coordinate on the screen where the event occurred.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onMouseMove(flags, x, y, view)
    #   puts "onMouseMove: flags = #{flags}"
    #   puts "                  x = #{x}"
    #   puts "                  y = #{y}"
    #   puts "               view = #{view}"
    # end
    # ```
    def onMouseMove: (
                       Integer flags,
                       Integer x,
                       Integer y,
                       Sketchup::View view
                     ) -> untyped

    # The {#onMouseWheel} method is called by SketchUp when the mouse scroll wheel
    # is used.
    # 
    # _@param_ `flags` — A bit mask that tells the state of the modifier keys and other mouse buttons at the time.
    # 
    # _@param_ `delta` — Either +1+ or +-1+ depending on which direction the mouse wheel scrolled.
    # 
    # _@param_ `x` — The X coordinate on the screen where the event occurred.
    # 
    # _@param_ `y` — The Y coordinate on the screen where the event occurred.
    # 
    # _@param_ `view`
    # 
    # _@return_ — Return +true+ to prevent SketchUp from performing default
    # zoom action.
    # 
    # ```ruby
    # class ExampleTool
    # 
    #   def initialize
    #     @property_value = 0
    #     @rect = [
    #       Geom::Point3d.new(100, 150, 0),
    #       Geom::Point3d.new(300, 150, 0),
    #       Geom::Point3d.new(300, 250, 0),
    #       Geom::Point3d.new(100, 250, 0),
    #     ]
    #   end
    # 
    #   def onMouseMove(flags, x, y, view)
    #     view.invalidate
    #   end
    # 
    #   def onMouseWheel(flags, delta, x, y, view)
    #     # If the cursor is not within the bounds of the rectangle, return false
    #     # to let SketchUp do its default action (zoom).
    #     point = Geom::Point3d.new(x, y)
    #     return false unless Geom.point_in_polygon_2D(point, @rect, true)
    # 
    #     # If cursor is within the bounds of the rectangle, update the value
    #     # and prevent the default zoom.
    #     @property_value += delta
    #     view.invalidate
    #     true
    #   end
    # 
    #   def draw(view)
    #     view.line_width = 2
    #     view.line_stipple = ''
    #     view.drawing_color = 'red'
    #     view.draw2d(GL_QUADS, @rect)
    # 
    #     point = Geom::Point3d.new(120, 170)
    #     view.draw_text(point, "Value: #{@property_value}",
    #        size: 20, bold: true, color: 'black')
    #   end
    # 
    # end
    # 
    # Sketchup.active_model.select_tool(ExampleTool.new)
    # ```
    def onMouseWheel: (
                        Integer flags,
                        Integer delta,
                        Float x,
                        Float y,
                        Sketchup::View view
                      ) -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#onRButtonDoubleClick} is called by SketchUp when the user double clicks
    # with the right mouse button.
    # 
    # _@param_ `flags` — A bit mask that tells the state of the modifier keys and other mouse buttons at the time.
    # 
    # _@param_ `x` — The X coordinate on the screen where the event occurred.
    # 
    # _@param_ `y` — The Y coordinate on the screen where the event occurred.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onRButtonDoubleClick(flags, x, y, view)
    #   puts "onRButtonDoubleClick: flags = #{flags}"
    #   puts "                          x = #{x}"
    #   puts "                          y = #{y}"
    #   puts "                       view = #{view}"
    # end
    # ```
    def onRButtonDoubleClick: (
                                Integer flags,
                                Integer x,
                                Integer y,
                                Sketchup::View view
                              ) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#onRButtonDown} method is called by SketchUp when the user presses
    # the right mouse button. Implement this method, along with the tool.getMenu
    # method, when you want your tool to do something other than display the
    # default context menu when the right mouse button is clicked.
    # 
    # _@param_ `flags` — A bit mask that tells the state of the modifier keys and other mouse buttons at the time.
    # 
    # _@param_ `x` — The X coordinate on the screen where the event occurred.
    # 
    # _@param_ `y` — The Y coordinate on the screen where the event occurred.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onRButtonDown(flags, x, y, view)
    #   puts "onRButtonDown: flags = #{flags}"
    #   puts "                   x = #{x}"
    #   puts "                   y = #{y}"
    #   puts "                view = #{view}"
    # end
    # ```
    def onRButtonDown: (
                         Integer flags,
                         Integer x,
                         Integer y,
                         Sketchup::View view
                       ) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#onRButtonUp} method is called by SketchUp when the user releases the
    # right mouse button.
    # 
    # _@param_ `flags` — A bit mask that tells the state of the modifier keys and other mouse buttons at the time.
    # 
    # _@param_ `x` — The X coordinate on the screen where the event occurred.
    # 
    # _@param_ `y` — The Y coordinate on the screen where the event occurred.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onRButtonUp(flags, x, y, view)
    #   puts "onRButtonUp: flags = #{flags}"
    #   puts "                 x = #{x}"
    #   puts "                 y = #{y}"
    #   puts "              view = #{view}"
    # end
    # ```
    def onRButtonUp: (
                       Integer flags,
                       Integer x,
                       Integer y,
                       Sketchup::View view
                     ) -> untyped

    # The {#onReturn} method is called by SketchUp when the user hit the Return key
    # to complete an operation in the tool. This method will rarely need to be
    # implemented.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onReturn(view)
    #   puts "onReturn(#{view})"
    # end
    # ```
    def onReturn: (Sketchup::View view) -> void

    # The {#onSetCursor} method is called by SketchUp when the tool wants to set
    # the cursor.
    # 
    # _@return_ — Return +true+ to prevent SketchUp using the default cursor.
    # 
    # ```ruby
    # def onSetCursor
    #   puts "onSetCursor: view = #{view}"
    #   # You would set your cursor here. See UI.set_cursor method.
    #   UI.set_cursor(@cursor_id) # UI.set_cursor return true
    # end
    # ```
    def onSetCursor: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#onUserText} method is called by SketchUp when the user has typed text
    # into the VCB and hit return.
    # 
    # _@param_ `text` — The text string that was typed into the VCB.
    # 
    # _@param_ `view` — A view object where the method was invoked.
    # 
    # ```ruby
    # def onUserText(text, view)
    #   @distance = text.to_l
    # rescue ArgumentError
    #   view.tooltip = 'Invalid length'
    # end
    # ```
    def onUserText: (String text, Sketchup::View view) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#resume} method is called by SketchUp when the tool becomes active again
    # after being suspended.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def resume(view)
    #   puts "resume: view = #{view}"
    # end
    # ```
    def resume: (Sketchup::View view) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#suspend} method is called by SketchUp when the tool temporarily becomes
    # inactive because another tool has been activated. This typically happens
    # when a viewing tool is activated, such as when orbit is active due to the
    # middle mouse button.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def suspend(view)
    #   puts "suspend: view = #{view}"
    # end
    # ```
    def suspend: (Sketchup::View view) -> untyped
  end

  # This class contains methods to manipulate the current point of view of the
  # model. The drawing methods here (draw_line, draw_polyline, etc) are meant to
  # be invoked within a tool's Tool.draw method. Calling them outside Tool.draw
  # will have no effect.
  # 
  # You access the View by calling the Model.active_view method.
  # 
  # @example
  #   view = Sketchup.active_model.active_view
  # 
  # @version SketchUp 6.0
  class View
    # The add_observer method is used to add an observer to the current object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # status = view.add_observer observer
    # ```
    def add_observer: (Object observer) -> bool

    # sord duck - #nextFrame looks like a duck type, replacing with untyped
    # sord duck - #nextFrame looks like a duck type, replacing with untyped
    # The animation= method is used to set an animation that is displayed for a
    # view. See Animation for details on how to create an animation object.
    # 
    # _@param_ `animation` — An Animation object.
    # 
    # _@return_ — the newly set Animation object
    # 
    # ```ruby
    # animation = ViewSpinner.new
    # model = Sketchup.active_model
    # view = model.active_view
    # anim = view.animation=animation
    # if (anim)
    #   UI.messagebox anim
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def animation=: (untyped animation) -> untyped

    # The average_refresh_time is used to set the average time used to refresh the
    # current model in the view. This can be used to estimate the frame rate for
    # an animation.
    # 
    # _@return_ — the time in seconds
    # 
    # ```ruby
    # model = Sketchup.active_model
    # view = model.active_view
    # time = view.average_refresh_time
    # ```
    def average_refresh_time: () -> Float

    # The camera method is used to retrieve the camera for the view.
    # 
    # _@return_ — a Camera object
    # 
    # ```ruby
    # camera = view.camera
    # ```
    def camera: () -> Sketchup::Camera

    # sord infer - inferred type of parameter "arg" as Sketchup::Camera using getter's return type
    # sord omit - no YARD return type given, using untyped
    # The {#camera=} method is used to set the camera for the view. If a transition
    # time is given, then it will animate the transition from the current camera
    # to the new one.
    # 
    # ```ruby
    # camera = Sketchup::Camera.new([5, 5, 9], [5, 10, 0], Z_AXIS)
    # view = Sketchup.active_model.active_view
    # view.camera = camera
    # ```
    def camera=: (Sketchup::Camera arg) -> untyped

    # The center method is used to retrieve the coordinates of the center of the
    # view in pixels. It is returned as an array of 2 values for x and y.
    # 
    # _@return_ — the center of the view
    # 
    # ```ruby
    # model = Sketchup.active_model
    # view = model.active_view
    # c = view.center
    # ```
    def center: () -> Geom::Point3d

    # The corner method is used to retrieve the coordinates of one of the corners
    # of the view. The argument is an index between 0 and 3 that identifies which
    # corner you want. This method returns an array with two integers which are
    # the coordinates of the corner of the view in the view space. If the view
    # uses a Camera with a fixed aspect ratio, then the corners are the corners of
    # the viewing are of the camera which might be different than the actual
    # corners of the view itself.
    # 
    # The index numbers are as follows:
    #  - 0: top left,
    #  - 1: top right,
    #  - 2: bottom left,
    #  - 3: bottom right.
    # 
    # _@param_ `index` — A value between (or including) 0 and 3 identifying the corner whose coordinate you want to retrieve.
    # 
    # _@return_ — a 2d array [w,h] representing the screen point
    # 
    # ```ruby
    # point = view.corner index
    # ```
    def corner: (Integer index) -> [Integer, Integer]

    # sord omit - no YARD type given for "*args", using untyped
    # The {#draw} method is used to do basic drawing. This method can only be
    # called from within the {Tool#draw} method of a tool that you implement in
    # Ruby.
    # 
    # The following constants are all OpenGL terms and have been externalized to
    # Ruby. Here is a summary of their meanings:
    # 
    # [GL_POINTS]
    #   Treats each vertex as a single point. Vertex n defines point n. N
    #   points are drawn.
    # 
    # [GL_LINES]
    #   Treats each pair of vertices as
    #   an independent line segment. Vertices 2n-1 and 2n define line n. N/2 lines
    #   are drawn.
    # 
    # [GL_LINE_STRIP]
    #   Draws a connected group of line
    #   segments from the first vertex to the last. Vertices n and n+1 define
    #   line n. N-1 lines are drawn.
    # 
    # [GL_LINE_LOOP]
    #   Draws a connected group of line segments from the first vertex to the last,
    #   then back to the first. Vertices n and n+1 define line n. The last line,
    #   however, is defined by vertices N and 1. N lines are drawn.
    # 
    # [GL_TRIANGLES]
    #   Treats each triplet of vertices as an independent
    #   triangle. Vertices 3n-2, 3n-1, and 3n define triangle n. N/3 triangles are
    #   drawn.
    # 
    # [GL_TRIANGLE_STRIP]
    #   Draws a connected group of triangles. One triangle is defined for each
    #   vertex presented after the first two vertices. For odd n, vertices n, n+1,
    #   and n+2 define triangle n. For even n, vertices n+1, n, and n+2 define
    #   triangle n. N-2 triangles are drawn.
    # 
    # [GL_TRIANGLE_FAN]
    #   Draws a connected group of triangles.
    #   One triangle is defined for each vertex presented after the first two
    #   vertices. Vertices 1, n+1, and n+2 define triangle n. N-2 triangles are
    #   drawn.
    # 
    # [GL_QUADS]
    #   Treats each group of four vertices as an
    #   independent quadrilateral. Vertices 4n-3, 4n-2, 4n-1, and 4n define
    #   quadrilateral n. N/4 quadrilaterals are drawn.
    # 
    # [GL_QUAD_STRIP]
    #   Draws a connected group of quadrilaterals. One quadrilateral is
    #   defined for each pair of vertices presented after the first pair.
    #   Vertices 2n-1, 2n, 2n+2, and 2n+1 define quadrilateral n. N/2-1
    #   quadrilaterals are drawn. Note that the order in which vertices are used to
    #   construct a quadrilateral from strip data is different from that used with
    #   independent data.
    # 
    # [GL_POLYGON]
    #   Draws a single, convex polygon. Vertices 1
    #   through N define this polygon.
    # 
    # ```ruby
    # points = [
    #   Geom::Point3d.new(0, 0, 0),
    #   Geom::Point3d.new(9, 0, 0),
    #   Geom::Point3d.new(9, 9, 0),
    #   Geom::Point3d.new(0, 9, 0)
    # ]
    # view.draw(GL_LINE_LOOP, points)
    # ```
    # 
    # _@note_ — If you draw outside the model bounds you need to implement
    # {Tool#getExtents} which returns a bounding box large enough to include the
    # points you draw. Otherwise your drawing will be clipped.
    # 
    # _@see_ `Tool#getExtents`
    def draw: (*untyped args) -> Sketchup::View

    # sord omit - no YARD type given for "*args", using untyped
    # The {#draw2d} method is used to draw in screen space (using 2D screen
    # coordinates) instead of 3D space.
    # 
    # The second parameter is an {Array} of {Geom::Point3d} objects (or several
    # individual {Geom::Point3d} objects). These {Geom::Point3d} objects are in
    # screen space, not 3D space.
    # The X value corresponds to the number of pixels from the left edge of the
    # drawing area. The Y value corresponds to the number of pixels down from
    # the top of the drawing area. The Z value is not used.
    # 
    # ```ruby
    # points = [
    #   Geom::Point3d.new(0, 0, 0),
    #   Geom::Point3d.new(8, 0, 0),
    #   Geom::Point3d.new(8, 4, 0),
    #   Geom::Point3d.new(0, 4, 0)
    # ]
    # view.draw2d(GL_LINE_STRIP, points)
    # ```
    # 
    # _@see_ `#draw`
    # 
    # _@see_ `UI.scale_factor`
    def draw2d: (*untyped args) -> Sketchup::View

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The draw_lines method is used to draw disconnected lines.
    # 
    # You must have an even number of points. This method is usually  invoked
    # within the draw method of a tool.
    # 
    # ```ruby
    # point4 = Geom::Point3d.new 0,0,0
    # point5 = Geom::Point3d.new 100,100,100
    # # returns a view
    # status = view.drawing_color="red"
    # status = view.draw_lines point4, point5
    # ```
    def draw_line: (*untyped args) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The draw_lines method is used to draw disconnected lines.
    # 
    # You must have an even number of points. This method is usually  invoked
    # within the draw method of a tool.
    # 
    # ```ruby
    # point4 = Geom::Point3d.new 0,0,0
    # point5 = Geom::Point3d.new 100,100,100
    # # returns a view
    # status = view.drawing_color="red"
    # status = view.draw_lines point4, point5
    # ```
    def draw_lines: (*untyped args) -> untyped

    # This method is used to draw points.
    # 
    # This method is usually invoked within the draw method of a tool.
    # 
    # _@param_ `points`
    # 
    # _@param_ `size` — Size of the point in pixels.
    # 
    # _@param_ `style` — 1 = open square, 2 = filled square, 3 = "+", 4 = "X", 5 = "*", 6 = open triangle, 7 = filled triangle.
    # 
    # _@param_ `color`
    # 
    # _@return_ — a View object
    # 
    # ```ruby
    # point3 = Geom::Point3d.new 0,0,0
    # # returns a view
    # status = view.draw_points(point3, 10, 1, "red")
    # ```
    def draw_points: (
                       ::Array[Geom::Point3d] points,
                       ?Integer size,
                       ?Integer style,
                       ?Sketchup::Color color
                     ) -> Sketchup::View

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The draw_polyline method is used to draw a series of connected line segments
    # from pt1 to pt2 to pt3, and so on.
    # 
    # This method is usually invoked within the draw method of a tool.
    # 
    # ```ruby
    # point12 = Geom::Point3d.new 0,0,0
    # point13 = Geom::Point3d.new 10,10,10
    # point14 = Geom::Point3d.new 20,20,20
    # point15 = Geom::Point3d.new 30,30,30
    # status = view.draw_polyline point12, point13, point14, point15
    # ```
    def draw_polyline: (*untyped args) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # This method is used to draw text on the screen and is usually invoked within
    # the draw method of a tool.
    # 
    # The {TextVerticalAlignCenter} option will align the text to the center of the
    # height of the first line, not the whole boundingbox of the text. To align
    # around the full bounds of the text, use {#text_bounds} to compute the
    # desired alignment.
    # 
    # The vertical alignment can vary between fonts and platforms. It's recommended
    # to test different fonts and find one that fits well across both platforms
    # for your purposes.
    # 
    # <b>Example of different vertical alignment and text bounds:</b>
    # 
    # rdoc-image:../images/view-draw-text-with-bounds.png
    # 
    # ```ruby
    # class ExampleTool
    #   def draw(view)
    #     # This works in all SketchUp versions and draws the text using the
    #     # default font, size and color (i.e. the model edge color).
    #     point = Geom::Point3d.new(200, 100, 0)
    #     view.draw_text(point, "This is a test")
    # 
    #     # This works in SketchUp 2016 and up.
    #     options = {
    #       :font => "Arial",
    #       :size => 20,
    #       :bold => true,
    #       :align => TextAlignRight
    #     }
    #     point = Geom::Point3d.new(200, 200, 0)
    #     view.draw_text(point, "This is another\ntest", options)
    # 
    #     # You can also use Ruby 2.0's named arguments:
    #     point = Geom::Point3d.new(200, 200, 0)
    #     view.draw_text(point, "Hello world!", color: "Red")
    #   end
    # end
    # ```
    # 
    # Cross Platform Font Size
    # ```ruby
    # class ExampleTool
    #   IS_WIN = Sketchup.platform == :platform_win
    # 
    #   def draw(view)
    #     draw_text(view, [100, 200, 0], "Hello World", size: 20)
    #   end
    # 
    #   private
    # 
    #   # This will ensure text is drawn with consistent size across platforms,
    #   # using pixels as size units.
    #   def draw_text(view, position, text, **options)
    #     native_options = options.dup
    #     if IS_WIN && options.key?(:size)
    #       native_options[:size] = pixels_to_points(options[:size])
    #     end
    #     view.draw_text(position, text, **native_options)
    #   end
    # 
    #   def pixels_to_points(pixels)
    #     ((pixels.to_f / 96.0) * 72.0).round
    #   end
    # end
    # ```
    # 
    # _@note_ — Under Windows the font name must be less than 32 characters - due to
    # system limitations.
    # 
    # _@note_ — As of SU2017 this will automatically scale the font-size by the same
    # factor as {UI.scale_factor}.
    # 
    # _@note_ — The font size is platform dependent. On Windows the method expects
    # points, where on Mac it's pixels. See "Cross Platform Font Size" example
    # for details.
    def draw_text: (*untyped args) -> Sketchup::View

    # The drawing_color method is used to set the color that is used for drawing
    # to the view.
    # 
    # This method is usually invoked within the draw method of a tool.
    # 
    # _@param_ `color` — A Color object.
    # 
    # ```ruby
    # view = view.drawing_color = color
    # ```
    def drawing_color=: ((Sketchup::Color | String) color) -> Sketchup::View

    # The dynamic= method allows you to degrade visual quality while improving
    # performance when a model is large and view refresh time is slow. For
    # example, if you were using a Ruby script to animate the camera through
    # a large scene, you may want to set dynamic to true during that time.
    # 
    # See also camera.rb which is part of the film and stage ruby
    # scripts.
    # 
    # _@param_ `value`
    # 
    # ```ruby
    # view.dynamic = true
    # ```
    # 
    # _@deprecated_ — This method is no longer doing anything.
    def dynamic=: (bool value) -> bool

    # The field_of_view method is used get the view's field of view setting, in
    # degrees.
    # 
    # _@return_ — the field of view
    # 
    # ```ruby
    # fov = Sketchup.active_model.active_view.field_of_view
    # ```
    def field_of_view: () -> Float

    # The field_of_view= method is used set the view's field of view setting,
    # in degrees.
    # 
    # _@param_ `fov` — the field of view
    # 
    # ```ruby
    # my_view = Sketchup.active_model.active_view
    # my_view.field_of_view = 45
    # my_view.invalidate
    # ```
    def field_of_view=: (Numeric fov) -> Numeric

    # sord omit - no YARD type given for "*args", using untyped
    # The guess_target method is used to guess at what the user is looking at when
    # you have a perspective view.
    # 
    # This method is useful when writing a viewing tool. See also camera.rb which
    # is part of the film and stage ruby scripts.
    # 
    # _@return_ — a Point3d object representing the point in the
    # model that the user is likely interested in.
    # 
    # ```ruby
    # target = view.guess_target
    # ```
    def guess_target: (*untyped args) -> Geom::Point3d

    # The inference_locked? method is used to determine if inference locking is on
    # for the view.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # view = model.active_view
    # status = view.inference_locked
    # ```
    def inference_locked?: () -> bool

    # The inputpoint method is used to retrieve an input point.
    # 
    # This will normally be used inside one of the mouse event handling methods in
    # a tool. Usually, it is preferable to create the InputPoint first and then
    # use the pick method on it.
    # 
    # _@param_ `x` — A x value.
    # 
    # _@param_ `y` — A y value.
    # 
    # _@param_ `inputpoint1` — An InputPoint object.
    # 
    # ```ruby
    # inputpoint = view.inputpoint x, y, inputpoint1
    # ```
    def inputpoint: (Numeric x, Numeric y, Sketchup::InputPoint inputpoint1) -> Sketchup::InputPoint

    # The invalidate method is used mark the view as in need of a redraw.
    # 
    # _@return_ — the invalidated View object
    # 
    # ```ruby
    # model = Sketchup.active_model
    # view = model.active_view
    # invalidated_view = view.invalidate
    # ```
    # 
    # _@note_ — This is the preferred method to update the viewport. Use this before
    # trying to use {#refresh}.
    def invalidate: () -> Sketchup::View

    # sord omit - no YARD type given for "*args", using untyped
    # The last_refresh_time method is used to retrieve the time for the last full
    # view refresh.
    # 
    # _@return_ — time in milliseconds
    # 
    # ```ruby
    # time = view.last_refresh_time
    # ```
    def last_refresh_time: (*untyped args) -> Float

    # The line_stipple= method is used to set the line pattern to use for drawing.
    # The stipple pattern is given as a string.
    # Valid strings are:
    #   "." (Dotted Line),
    #   "-" (Short Dashes Line),
    #   "_" (Long Dashes Line),
    #   "-.-" (Dash Dot Dash Line),
    #   "" (Solid Line).
    # 
    # This method is usually invoked within the draw method of a tool.
    # 
    # _@param_ `pattern` — A string stipple pattern, such as "-.-"
    # 
    # _@return_ — the View object
    # 
    # ```ruby
    # point8 = Geom::Point3d.new 0,0,0
    # point9 = Geom::Point3d.new 100,100,100
    # view.line_stipple = "-.-"
    # view = view.draw_lines point8, point9
    # ```
    def line_stipple=: (String pattern) -> Sketchup::View

    # The line_width= method is used to set the line width to use for drawing. The
    # value is a Double indicating the desired width in pixels.
    # 
    # This method is usually invoked within the draw method of a tool.
    # 
    # _@param_ `width` — The width in pixels.
    # 
    # ```ruby
    # view.line_width = width
    # ```
    # 
    # _@note_ — As of SU2017 this will automatically scale the line width by the same
    # factor as {UI.scale_factor}.
    def line_width=: (Integer width) -> Integer

    # Loads a texture to be drawn with {#draw} or {#draw2d}.
    # 
    # _@param_ `image_rep`
    # 
    # _@return_ — A resource ID referring to the image loaded.
    # 
    # ```ruby
    # module Example
    #   class MyTool
    #     def activate
    #       view = Sketchup.active_model.active_view
    #       image_rep = view.model.materials.current.texture.image_rep
    #       @texture_id = view.load_texture(image_rep)
    #     end
    # 
    #     def deactivate(view)
    #       view.release_texture(@texture_id)
    #     end
    # 
    #     def draw(view)
    #       points = [ [0, 0, 0], [9, 0, 0], [9, 9, 0], [0, 9, 0] ]
    #       uvs = [ [0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0] ]
    #       view.draw(GL_QUADS, points, texture: @texture_id, uvs: uvs)
    #     end
    #   end
    # end
    # Sketchup.active_model.select_tool(Example::MyTool.new)
    # ```
    # 
    # _@note_ — To conserve resources on the user's machine, textures can be loaded
    # only when there is a Ruby tool on the tool stack. Make sure to release the
    # texture when it's no longer needed. Any textures not already released
    # when the last Ruby tool on the tool stack is removed will be automatically
    # released by SketchUp.
    # 
    # _@note_ — Avoid loading and releasing textures within the {Sketchup::Tool#draw}
    # event as that is not efficient.
    # 
    # _@see_ `#release_texture`
    # 
    # _@see_ `#draw`
    def load_texture: (Sketchup::ImageRep image_rep) -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # The {#lock_inference} method is used to lock or unlock an inference.
    # 
    # This method will typically be called from inside a tool class when the user
    # presses the shift key or arrow keys.
    # 
    # With no arguments it unlocks all inferences. With one argument it locks
    # inference based on that passed {Sketchup::InputPoint}'s entities, e.g. along
    # a {Sketchup::Edge}'s line or a {Sketchup::Face}'s plane. With two arguments,
    # it locks inference along an axis.
    # 
    # _@return_ — a View object
    # 
    # ```ruby
    # view = view.lock_inference
    # view = view.lock_inference(inputpoint)
    # view = view.lock_inference(inputpoint1, inputpoint2)
    # ```
    def lock_inference: (*untyped args) -> Sketchup::View

    # The model method is used to retrieve the model for the current view.
    # 
    # _@return_ — the model for this view
    # 
    # ```ruby
    # model = view.model
    # ```
    def model: () -> Sketchup::Model

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The pick_helper method is used to retrieve a pick helper for the view. See
    # the PickHelper class for information on pick helpers.
    # 
    # This call returns an initialized PickHelper.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # view = model.active_view
    # ph = view.pick_helper
    # ```
    def pick_helper: (*untyped args) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The pickray method is used to retrieve a ray passing through a given screen
    # position in the viewing direction.
    # 
    # ```ruby
    # ray = view.pickray x, y
    # ```
    def pickray: (*untyped args) -> untyped

    # The pixels_to_model method is used to compute a model size from a pixel size
    # at a given point.
    # 
    # This method is useful for deciding how big to draw something based on a
    # desired size in pixels.
    # 
    # _@param_ `pixels` — The pixel size.
    # 
    # _@param_ `point` — A Point3d object where the size will be calculated from.
    # 
    # _@return_ — the model size
    # 
    # ```ruby
    # size = view.pixels_to_model(pixels, point)
    # ```
    # 
    # _@note_ — As of SU2017 this will automatically scale the pixel-size by the same
    # factor as {UI.scale_factor}.
    def pixels_to_model: (Numeric pixels, Geom::Point3d point) -> Float

    # The refresh method is used to immediately force a redraw of the view.
    # 
    # _@return_ — the refreshed View object
    # 
    # ```ruby
    # model = Sketchup.active_model
    # view = model.active_view
    # refreshed_view = view.refresh
    # ```
    # 
    # _@note_ — This method might impact performance and if used incorrectly cause
    # instability or crashes. Don't use this unless you have verified that
    # you cannot use {#invalidate} instead.
    def refresh: () -> Sketchup::View

    # Releases a texture loaded via {#load_texture}, freeing up it's memory.
    # It's good practice to do so whenever there is no longer any need for the
    # resource.
    # 
    # For example, when your tool deactivates you probably want to release your
    # resources as you don't know if your tool will be used again.
    # 
    # _@param_ `texture_id`
    # 
    # _@return_ — +true+ if texture was released. +false+ otherwise.
    # 
    # ```ruby
    # module Example
    #   class MyTool
    #     def activate
    #       view = Sketchup.active_model.active_view
    #       image_rep = view.model.materials.current.texture.image_rep
    #       @texture_id = view.load_texture(image_rep)
    #     end
    # 
    #     def deactivate(view)
    #       view.release_texture(@texture_id)
    #     end
    # 
    #     def draw(view)
    #       points = [ [0, 0, 0], [9, 0, 0], [9, 9, 0], [0, 9, 0] ]
    #       uvs = [ [0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0] ]
    #       view.draw(GL_QUADS, points, texture: @texture_id, uvs: uvs)
    #     end
    #   end
    # end
    # Sketchup.active_model.select_tool(Example::MyTool.new)
    # ```
    # 
    # _@see_ `#load_texture`
    def release_texture: (Integer texture_id) -> bool

    # The remove_observer method is used to remove an observer from the current
    # object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # status = view.remove_observer observer
    # ```
    def remove_observer: (Object observer) -> bool

    # The screen_coords method is used to retrieve the screen coordinates of the
    # given point on the screen.
    # 
    # The x and y values returned correspond to the x and y screen coordinates.
    # Ignore the z values.  If the referenced point is not in the current
    # viewport,  the x and/or y value may be negative.
    # 
    # _@param_ `point3d` — A Point3d object.
    # 
    # _@return_ — A Point3d containing the screen position
    # 
    # ```ruby
    # point = view.screen_coords(ORIGIN)
    # ```
    def screen_coords: (Geom::Point3d point3d) -> Geom::Point3d

    # Set the drawing color for the view based on the direction of a line that you
    # want to draw. These colors will match the axes colors in the SketchUp model
    # (typically blue for straight up and down, etc.)
    # 
    # This method is usually invoked within the draw method of a tool.
    # 
    # _@param_ `point1` — Point3d object representing first point in the line.
    # 
    # _@param_ `point2` — Point3d object representing the second point in the line.
    # 
    # _@return_ — a View object
    # 
    # ```ruby
    # view = view.set_color_from_line point1, point2
    # ```
    def set_color_from_line: (Geom::Point3d point1, Geom::Point3d point2) -> Sketchup::View

    # The show_frame method is used to show a frame of an Animation object in the
    # current view.
    # 
    # You can supply an optional delay in seconds to wait before showing the next
    # frame. This can be useful to control the speed at which the animation runs.
    # 
    # _@param_ `delay` — An optional delay in seconds.
    # 
    # ```ruby
    # status = view.show_frame delay
    # ```
    def show_frame: (Numeric delay) -> Sketchup::View

    # This method is used to compute the bounds of the text when
    # using {#draw_text}. The bounds are not a tight fit around the top and bottom
    # as they include varying amount of line spacing depending on the font used.
    # 
    # The {TextVerticalAlignCenter} option will align the text to the center of the
    # height of the first line, not the whole boundingbox of the text.
    # 
    # <b>Example of different vertical alignment and text bounds:</b>
    # 
    # rdoc-image:../images/view-draw-text-with-bounds.png
    # 
    # _@param_ `point` — A Point3d object representing a 2D coordinate in view space.
    # 
    # _@param_ `text` — The text string to draw.
    # 
    # _@param_ `options` — The text can be customized by providing a hash or named arguments of options.
    # 
    # ```ruby
    # class ExampleTool
    #   TEXT_OPTIONS = {
    #     :font => "Arial",
    #     :size => 20,
    #     :bold => true,
    #     :align => TextAlignRight,
    #     :align => TextVerticalAlignBaseline
    #   }
    # 
    #   # Since `draw` is called frequently it can be useful to pre-compute and
    #   # cache values used by `draw`.
    #   def activate
    #     @text = "Hello SketchUp"
    #     @position = Geom::Point3d.new(200, 200, 0)
    # 
    #     # Compute text bounds
    #     view = Sketchup.active_model.active_view
    #     bounds = view.text_bounds(@position, @text, TEXT_OPTIONS)
    # 
    #     # Compute polygon for the text bounds
    #     x1, y1 = bounds.upper_left.to_a
    #     x2, y2 = bounds.lower_right.to_a
    #     @points = [
    #       Geom::Point3d.new(x1, y1),
    #       Geom::Point3d.new(x1, y2),
    #       Geom::Point3d.new(x2, y2),
    #       Geom::Point3d.new(x2, y1),
    #     ]
    #   end
    # 
    #   def draw(view)
    #     # Draw text bounds
    #     view.drawing_color = Sketchup::Color.new(255, 0, 0, 64)
    #     view.draw2d(GL_QUADS, @points)
    # 
    #     # Draw text
    #     view.draw_text(@position, @text, TEXT_OPTIONS)
    #   end
    # end
    # ```
    # 
    # _@note_ — Under Windows the font name must be less than 32 characters - due to
    # system limitations.
    # 
    # _@see_ `#draw_text`
    def text_bounds: (Geom::Point3d point, String text, ?::Hash[untyped, untyped] options) -> Geom::Bounds2d

    # Set a tooltip to display in the view. This is useful for displaying tooltips
    # in a tool that you write in Ruby.
    # 
    # _@param_ `string` — The string tooltip.
    # 
    # _@return_ — the new tooltip string
    # 
    # ```ruby
    # tooltip = view.tooltip = string
    # ```
    def tooltip=: (String string) -> String

    # The vpheight method is used to retrieve the height of the viewport for the
    # view.
    # 
    # _@return_ — the height of the viewport in physical pixels.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # view = model.active_view
    # height = view.vpheight
    # ```
    def vpheight: () -> Integer

    # The vpwidth method is used to retrieve the width of the viewport for the
    # view.
    # 
    # _@return_ — the width of the viewport in physical pixels.
    # 
    # ```ruby
    # width = view.vpwidth
    # ```
    def vpwidth: () -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # The {#write_image} method is used to write the current view to an image file.
    # 
    # Supported file types are `.png`, `.jpg`, `.jpeg`, `gif`, `.bmp`, `.tif`.
    # For other file formats  available from the GUI in File > Export > 2D
    # Graphics, .e.g `.pdf`, use {Sketchup::Model#export}.
    # 
    # compression = 1.0)
    #   @note Prefer the overload with option hash instead of this variant. This
    #     overload is not updated with new options.
    # 
    #   @example
    #     filename = File.join(Sketchup.temp_dir, 'example.png')
    #     antialias = false
    #     compression = 0.9
    #     model = Sketchup.active_model
    #     view = model.active_view
    #     view.write_image(filename, 640, 480, antialias, compression)
    # 
    #   @param [String] filename
    #     The filename for the saved image
    #   @param [Integer] width
    #     Width in pixels, defaults to the current viewport width {#vpwidth}.
    #   @param [Integer] height
    #     Height in pixels, defaults to the current viewport height {#vpheight}.
    #   @param [Boolean] antialias
    #   @param [Float] compression
    #     Compression factor for JPEG images, between +0.0+ and +1.0+.
    def write_image: (*untyped args) -> bool

    # The zoom method is used to zoom in or out by some zoom factor.
    # 
    # _@param_ `zoom_or_ents` — A Float zoom factor from 1.0 or larger or an Array or collection of entities to "zoom extents" around.
    # 
    # _@return_ — the zoomed View object
    # 
    # ```ruby
    # view = view.zoom factor
    # view = view.zoom selection
    # view = view.zoom entity
    # view = view.zoom array_of_entities
    # ```
    def zoom: ((Numeric | Sketchup::Selection | Sketchup::Entity | ::Array[Sketchup::Entity]) zoom_or_ents) -> Sketchup::View

    # The zoom_extents method is used to zoom to the extents about the entire
    # model, as if the user has selected the zoom extents command from the menu.
    # 
    # _@return_ — the zoomed View object
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # new_view = view.zoom_extents
    # ```
    def zoom_extents: () -> Sketchup::View
  end

  # The Color class is used to create and manipulate colors within SketchUp
  # Models. The class can also be used the same way with LayOut documents.
  # 
  # For methods that accept a Color object, such as the
  # face.material method, you can pass in an actual Color object, or an object
  # that can be converted to a Color. For example:
  # 
  # SketchUp ships with several built in colors in the Materials Browser.
  # These colors are listed in the following table.
  # {include:file:assets/colors.html}
  # 
  # @example
  #   face.material = Sketchup::Color.new(255, 0, 0)
  #   face.material = 255
  #   face.material = 0xff
  #   face.material = "red"
  #   face.material = "#ff0000"
  #   face.material = [1.0, 0.0, 0.0]
  #   face.material = [255, 0, 0]
  # 
  # @version SketchUp 6.0
  class Color
    # The {.names} method is used to retrieve an array of all color names
    # recognized by SketchUp.
    # 
    # In general, whenever a method wants a color, you can pass in a String with
    # one of these names.
    # 
    # ```ruby
    # array = Sketchup::Color.names
    # ```
    def self.names: () -> ::Array[untyped]

    # The {#==} method checks to see if the two {Sketchup::Color}s are equal. This
    # checks whether the RGBA values are the same. In versions prior to SketchUp
    # 2018 two color objects with the same values would be considered different.
    # 
    # _@param_ `other`
    # 
    # ```ruby
    # SketchUp::Color.new(255, 255, 255) == Sketchup::Color.new(1.0, 1.0, 1.0)
    # ```
    def ==: (Object other) -> bool

    # The {#alpha} method is used to retrieve the opacity of the color. A value of
    # 0 is transparent, 255 is opaque.
    # 
    # ```ruby
    # color = Sketchup::Color.new "OldLace"
    # alpha = color.alpha
    # ```
    def alpha: () -> Integer

    # The {#alpha=} method is used to set the opacity of the color. A value of 0 is
    # transparent, 255 is opaque.
    # 
    # _@param_ `alpha` — The new opacity value.
    # 
    # ```ruby
    # color = Sketchup::Color.new "AliceBlue"
    # alpha = color.alpha = 255
    # ```
    def alpha=: ((Integer | Float) alpha) -> (Integer | Float)

    # The {#blend} method is used to blend two colors.
    # 
    # The blended color will be the result of taking (1 - weight) * color1 +
    # weight * color2. If weight = 0, you will get color2. If weight = 1 you will
    # get color1.
    # 
    # _@param_ `color2` — The second color to be blended (with this color).
    # 
    # _@param_ `weight` — A Float between 0.0 and 1.0
    # 
    # ```ruby
    # color1 = Sketchup::Color.new "OldLace"
    # color2 = Sketchup::Color.new "AliceBlue"
    # color3 = color1.blend color2, 0.5
    # ```
    def blend: (Sketchup::Color color2, Float weight) -> Sketchup::Color

    # The {#blue} method is used to retrieve the blue value of a color.
    # 
    # Value range is 0 to 255.
    # 
    # ```ruby
    # color = Sketchup::Color.new "AliceBlue"
    # blue = color.blue
    # ```
    def blue: () -> Integer

    # The {#blue=} method is used to set the blue value of a color.
    # 
    # Value range is 0 to 255.
    # 
    # _@param_ `blue` — The blue value for the color.
    # 
    # ```ruby
    # color = Sketchup::Color.new "AliceBlue"
    # blue = color.blue = 200
    # ```
    def blue=: ((Integer | Float) blue) -> (Integer | Float)

    # The {#green} method is used to retrieve the green value of a color.
    # 
    # Value range is 0 to 255.
    # 
    # ```ruby
    # color = Sketchup::Color.new "AliceBlue"
    # green = color.green
    # ```
    def green: () -> Integer

    # The {#green=} method is used to set the green component of a RGB Color.
    # 
    # Value range is 0 to 255.
    # 
    # _@param_ `green` — The green value for the color.
    # 
    # ```ruby
    # color = Sketchup::Color.new "AliceBlue"
    # green = color.green = 200
    # ```
    def green=: ((Integer | Float) green) -> (Integer | Float)

    # sord omit - no YARD type given for "*args", using untyped
    # The new method is used to create a new Color object.
    # 
    # ```ruby
    # color_from_name = Sketchup::Color.new "OldLace"
    # color_from_rgb = Sketchup::Color.new(0, 128, 255)
    # color_from_rgba = Sketchup::Color.new(0, 128, 255, 128)
    # color_from_hex = Sketchup::Color.new(0xFF0000)
    # 
    # # You can then assign colors to the material of DrawingElements.
    # # Note that this creates a new Material object, and the alpha value
    # # of the color does NOT get applied to the new Material. You must
    # # manually set the alpha to get transparent materials.
    # face.material = color_from_rgba
    # face.material.alpha = 0.5
    # ```
    def initialize: (*untyped args) -> void

    # The {#red} method is used to retrieve the red component of a RGB Color.
    # 
    # Value range is 0 to 255.
    # 
    # ```ruby
    # color = Sketchup::Color.new "AliceBlue"
    # red = color.red
    # ```
    def red: () -> Integer

    # The {#red=} method is used to set the red component of a RGB Color.
    # 
    # Value range is 0 to 255.
    # 
    # _@param_ `red` — The red value for the color.
    # 
    # ```ruby
    # color = Sketchup::Color.new "AliceBlue"
    # red = color.red=200
    # ```
    def red=: ((Integer | Float) red) -> (Integer | Float)

    # The {#to_a} method is used to convert a Color object to an Array object. The
    # returned array will contain 4 integer values (RGBA) between 0 and 255.
    # 
    # ```ruby
    # color = Sketchup::Color.new "AliceBlue"
    # color_array = color.to_a
    # ```
    def to_a: () -> ::Array[untyped]

    # The {#to_i} method is used to convert a Color object to an 32 bit integer.
    # 
    # ```ruby
    # color = Sketchup::Color.new "AliceBlue"
    # integer = color.to_i
    # ```
    def to_i: () -> Integer

    # The {#to_s} method returns a string representation of the {Sketchup::Color}
    # object, in the form of "Color(255, 255, 255, 255)".
    # 
    # ```ruby
    # color = Sketchup::Color.new(255, 255, 255, 255)
    # color_str = color.to_s
    # ```
    def to_s: () -> String
  end

  # The Curve class is used by SketchUp to unite a series of Edge objects into
  # one conceptual entity. Since SketchUp is a surface modeler, all circles,
  # arcs, and arbitrary curves are really just edges that are bound together in
  # sequence.
  # 
  # There is a subclass of Curve called ArcCurve, which is any curve that makes
  # up part of a circle. You can think of ArcCurves as entities that were created
  # with SketchUp's Arc or Circle drawing tools and Curves as entities that were
  # created with the Freehand drawing tool.
  # 
  # @version SketchUp 6.0
  class Curve < Sketchup::Entity
    # The count_edges method is used to retrieve the number of Edge objects that
    # make up the Curve.
    # 
    # _@return_ — num_edges - the number of edges in the curve
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.entities
    # edgearray = entities.add_circle centerpoint, vector2, 10
    # edge = edgearray[0]
    # curve = edge.curve
    # number = curve.count_edges
    # ```
    def count_edges: () -> untyped

    # The each_edge method is used to iterate through all of the Edge objects in
    # the curve.
    # 
    # _@return_ — edge - a variable that will hold each Edge object as
    # they are found.
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.entities
    # edgearray = entities.add_circle centerpoint, vector2, 10
    # edge = edgearray[0]
    # curve = edge.curve
    # curve.each_edge {|edge| puts "Edge {edge.entityID}: {edge.length}" }
    # ```
    def each_edge: () -> untyped

    # The edges method is used to retrieve an array of Edge objects that make up
    # the Curve.
    # 
    # _@return_ — edges - an array of Edge objects if successful
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.entities
    # edgearray = entities.add_circle centerpoint, vector2, 10
    # edge = edgearray[0]
    # curve = edge.curve
    # edges = curve.edges
    # ```
    def edges: () -> untyped

    # The first_edge method is used to retrieve the first edge of the curve.
    # 
    # _@return_ — edge - the first Edge object in the curve if successful
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.entities
    # edgearray = entities.add_circle centerpoint, vector2, 10
    # edge = edgearray[0]
    # curve = edge.curve
    # firstedge = curve.first_edge
    # ```
    def first_edge: () -> untyped

    # _@return_ — True if this edge was originally created by the polygon
    # tool, otherwise false.
    # 
    # ```ruby
    # # Create a polygon and check its edge
    # ents = Sketchup.active_model.entities
    # ents.add_ngon [0, 0, 0], [0, 0, 1], 10, 6
    # curve = nil
    # ents.each { |e| curve = e.curve if e.is_a? Sketchup::Edge }
    # is_poly = curve.is_polygon?
    # ```
    def is_polygon?: () -> bool

    # The last_edge method is used to retrieve the last edge of the curve.
    # 
    # _@return_ — edge - the last Edge object in the curve if successful
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.entities
    # edgearray = entities.add_circle centerpoint, vector2, 10
    # edge = edgearray[7]
    # curve = edge.curve
    # lastedge = curve.last_edge
    # ```
    def last_edge: () -> untyped

    # The length method retrieves the length of the curve.
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.entities
    # edgearray = entities.add_circle centerpoint, vector2, 10
    # edge = edgearray[7]
    # curve = edge.curve
    # length = curve.length
    # ```
    def length: () -> Length

    # The {#move_vertices} method moves the vertices in the curve to points.
    # 
    # _@param_ `point_array`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.entities
    # new_edges = entities.add_arc(ORIGIN, X_AXIS, Z_AXIS, 20.cm, 0, 270.degrees, 32)
    # curve = new_edges.first.curve
    # points = curve.vertices.map(&:position)
    # points.each_with_index { |pt, i| pt.z = i * 1.cm }
    # curve.move_vertices(points)
    # ```
    def move_vertices: (::Array[Geom::Point3d] point_array) -> bool

    # The vertices method retrieves a collection of all vertices in a curve.
    # 
    # _@return_ — vertices - a collection of the vertices
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.entities
    # edgearray = entities.add_circle centerpoint, vector2, 10
    # edge = edgearray[7]
    # curve = edge.curve
    # vertices = curve.vertices
    # ```
    def vertices: () -> untyped
  end

  # A Group class contains methods for manipulating groups of entities.
  # 
  # Groups in SketchUp are very similar to components, but can from a user point
  # of view be thought of as unique objects. Groups can be instanced when copied
  # but are silently made unique when edited through the GUI. To honor this
  # behavior, make sure to call {#make_unique} before modifying a group through
  # the API.
  # 
  # @version SketchUp 6.0
  class Group < Sketchup::Drawingelement
    # The add_observer method is used to add a ComponentInstance observer to the
    # group.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # # Add a group to the model.
    # group = Sketchup.active_model.entities.add_group
    # group.entities.add_line([0,0,0],[100,100,100])
    # status = group.add_observer observer
    # ```
    def add_observer: (Object observer) -> bool

    # The copy method is used to create a new Group object that is a copy of the
    # group.
    # 
    # _@return_ — a new Group object
    # 
    # ```ruby
    # # Add a group to the model.
    # group = Sketchup.active_model.entities.add_group
    # group.entities.add_line([0,0,0],[100,100,100])
    # group2 = group.copy
    # ```
    def copy: () -> Sketchup::Group

    # The definition method is used to retrieve the component definition for this
    # group.
    # 
    # _@return_ — a ComponentDefinition object if
    # successful
    # 
    # ```ruby
    # group = Sketchup.active_model.entities.add_group
    # definition = group.definition
    # ```
    def definition: () -> Sketchup::ComponentDefinition

    # The description method is used to retrieve the description for the group.
    # 
    # _@return_ — a string description if successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the group to the entities in the model
    # group = entities.add_group
    # 
    # # Get the entities within the group
    # entities2 = group.entities
    # 
    # # Add a face to within the group
    # face = entities2.add_face pts
    # group.description = "This is a Group with a 2d Face"
    # description = group.description
    # ```
    def description: () -> String

    # The description= method is used to set the description for the group.
    # 
    # _@param_ `description` — A string description.
    # 
    # _@return_ — the new description if successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the group to the entities in the model
    # group = entities.add_group
    # 
    # # Get the entities within the group
    # entities2 = group.entities
    # 
    # # Add a face to within the group
    # face = entities2.add_face pts
    # group.description = "This is a Group with a 2d Face"
    # description = group.description
    # if (description)
    #   UI.messagebox description
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def description=: (String description) -> String

    # The entities method is used to retrieve a collection of entities in the
    # group.
    # 
    # _@return_ — an Entities object if successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the group to the entities in the model
    # group = entities.add_group
    # 
    # # Get the entities within the group
    # entities2 = group.entities
    # 
    # # Add a face to within the group
    # face = entities2.add_face pts
    # entities = group.entities
    # if (entities)
    #   UI.messagebox entities
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def entities: () -> Sketchup::Entities

    # The equals? method is used to determine if a group is geometrically
    # equivalent to another group.
    # 
    # _@param_ `group` — The group to compare this group with.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # group1 = entities[0]
    # group2 = entities[1]
    # status = group1.equals?(group2)
    # ```
    def equals?: (Sketchup::Group group) -> bool

    # The explode method is used to explode the group into individual entities.
    # 
    # _@return_ — An array of entity objects if successful, false if
    # unsuccessful.
    # 
    # ```ruby
    # # Add a group to the model.
    # group = Sketchup.active_model.entities.add_group
    # group.entities.add_line([0,0,0],[100,100,100])
    # 
    # array = group.explode
    # if array
    #   UI.messagebox "Exploded the group"
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def explode: () -> ::Array[Sketchup::Drawingelement]

    # The {#glued_to} method is used to retrieve the entity that this group is
    # glued to.
    # 
    # ```ruby
    # point = Geom::Point3d.new(10, 20, 30)
    # transform = Geom::Transformation.new(point)
    # model = Sketchup.active_model
    # entities = model.active_entities
    # group = entities.add_group
    # group.entities.add_face([[0, 0, 0], [10, 0, 0], [10, 10, 0], [0, 10, 0]])
    # status = group.glued_to
    # ```
    def glued_to: () -> (Sketchup::Face | Sketchup::Group | Sketchup::ComponentInstance | Sketchup::Image)?

    # The {glued_to=} method glues this group to a drawing element.
    # When moving this other drawing elment with the Move tool, the glued group moves with it.
    # 
    # _@param_ `drawing_element`
    # 
    # _@return_ — the entity the group was glued to.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # 
    # # Create a face
    # face = entities.add_face([[0, 0, 0], [100, 0, 0], [100, 100, 0], [0, 100, 0]])
    # 
    # # Create a group
    # definitions = model.definitions
    # group = entities.add_group
    # group.entities.add_face([[0, 0, 0], [10, 0, 0], [10, 10, 0], [0, 10, 0]])
    # 
    # # Make group "gluable"
    # group.definition.behavior.is2d = true
    # 
    # # Glue the group to the face.
    # # If you now move the face, the group will follow.
    # group.glued_to = face
    # ```
    def glued_to=: ((Sketchup::Face | Sketchup::Group | Sketchup::ComponentInstance | Sketchup::Image)? drawing_element) -> (Sketchup::Face | Sketchup::Group | Sketchup::ComponentInstance | Sketchup::Image)?

    # The guid method is used to get the base 64 encoded unique id
    # for this SketchUp object.
    # 
    # _@return_ — a unique 22 character string
    # 
    # ```ruby
    # # Add a group to the model.
    # group = Sketchup.active_model.entities.add_group
    # group.entities.add_line([0,0,0],[100,100,100])
    # guid = group.guid
    # ```
    def guid: () -> String

    # The intersect method is used to compute the boolean intersection of two
    # groups representing manifold solid volumes (this & arg).  If the specified
    # objects (this and arg) do not represent manifold volumes, this method fails.
    # 
    # _@param_ `group` — The group to intersect this group with.
    # 
    # _@return_ — The resultant group if the two objects
    # (this and arg) represent manifold solids and the
    # operation succeeds. Otherwise nil is returned.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # group1 = entities[0]
    # group2 = entities[1]
    # result = group1.intersect(group2)
    # ```
    # 
    # _@note_ — This method is not available in SketchUp Make.
    def intersect: ((Sketchup::Group | Sketchup::ComponentInstance) group) -> Sketchup::Group?

    # The {#local_bounds} method is used to retrieve the {Geom::BoundingBox}
    # bounding the contents of a {Sketchup::Group}, in the group's own internal
    # coordinate system.
    # 
    # ```ruby
    # # Add a group to the model.
    # group = Sketchup.active_model.entities.add_group
    # group.entities.add_line([0,0,0],[100,100,100])
    # transformation = Geom::Transformation.new([100,0,0])
    # 
    # # Note that local_bounds_1 and local_bounds_2 will be identical, since
    # # they both find the bounding box in group's untransformed state.
    # local_bounds_1 = group.local_bounds
    # group.transform! transformation
    # local_bounds_2 = group.local_bounds
    # ```
    # 
    # _@deprecated_ — In favor of `group.definition.bounds`.
    def local_bounds: () -> Geom::BoundingBox

    # The locked= method is used to lock a group.
    # 
    # _@param_ `lock`
    # 
    # _@return_ — true if the group is locked, false if not
    # 
    # ```ruby
    # # Add a group to the model.
    # group = Sketchup.active_model.entities.add_group
    # group.entities.add_line([0,0,0],[100,100,100])
    # status = group.locked = true
    # ```
    def locked=: (bool lock) -> bool

    # The locked? method is used to determine if a group is locked.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the group to the entities in the model
    # group = entities.add_group
    # status = group.locked?
    # UI.messagebox status
    # ```
    def locked?: () -> bool

    # The {#make_unique} method is used to force a group to have a unique
    # definition. If the group is already unique in the model, nothing happens.
    # 
    # Copying a group in SketchUp will create a group that shares the same
    # definition. SketchUp implicitly makes group unique when edited from the GUI,
    # and from a user point of view groups could be thought of as always being
    # unique. To honor this behavior, call this method before editing a group
    # through the API.
    # 
    # _@return_ — the unique group
    # 
    # ```ruby
    # # Assume we have 2 groups, one copied from the other and sharing definitions
    # groups = Sketchup.active_model.entities.grep(Sketchup::Group)
    # groups[0].make_unique
    # if (groups[0].entities.to_a == groups[1].entities.to_a)
    #   puts "This should not happen since we made the groups unique"
    # end
    # ```
    def make_unique: () -> Sketchup::Group

    # The manifold? method is used to determine if a group is manifold.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # group = entities.add_instance(definition, transformation)
    # status = group.manifold?
    # ```
    def manifold?: () -> bool

    # The {#move!} method is used to set the transformation of this group
    # instance, similarly to {#transformation=} but without recording to the undo
    # stack.
    # 
    # This method is useful for moving entities inside of an animation or page
    # transition.
    # 
    # _@param_ `transformation`
    # 
    # _@return_ — the transformed Group object if successful
    # 
    # ```ruby
    # point = Geom::Point3d.new 500,500,500
    # transformation = Geom::Transformation.new point
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the group to the entities in the model
    # group = entities.add_group
    # 
    # # Get the entities within the group
    # entities2 = group.entities
    # 
    # # Add a face to within the group
    # face = entities2.add_face pts
    # UI.messagebox "Group before Move"
    # group = group.move!(transformation)
    # ```
    # 
    # _@note_ — Despite the name being similar to {#transform!}, this method closer
    # corresponds to {#transformation=}.
    def move!: (Geom::Transformation transformation) -> Sketchup::Group

    # The name method is used to retrieve the name of the group.
    # 
    # _@return_ — The name of the group if successful
    # 
    # ```ruby
    # # Add a group to the model.
    # group = Sketchup.active_model.entities.add_group
    # group.entities.add_line([0,0,0],[100,100,100])
    # group.name = "A Line"
    # name = group.name
    # ```
    def name: () -> String

    # The name= method is used to set the description for the group.
    # 
    # _@param_ `name` — A string name.
    # 
    # _@return_ — a new name if successful
    # 
    # ```ruby
    # # Add a group to the model.
    # group = Sketchup.active_model.entities.add_group
    # group.entities.add_line([0,0,0],[100,100,100])
    # group.name = "A Line"
    # name = group.name
    # ```
    def name=: (String name) -> String

    # The outer_shell method is used to compute the outer shell of the two groups
    # representing manifold solid volumes (this || arg).  If the specified objects
    # (this and arg) do not represent manifold volumes, this method fails.
    # 
    # _@param_ `group` — The group to outer shell this group with.
    # 
    # _@return_ — The resultant group if the two objects
    # (this and arg) represent manifold solids and the
    # operation succeeds otherwise nil is returned.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # group1 = entities[0]
    # group2 = entities[1]
    # result = group1.outer_shell(group2)
    # ```
    def outer_shell: ((Sketchup::Group | Sketchup::ComponentInstance) group) -> Sketchup::Group?

    # The remove_observer method is used to remove a ComponentInstance observer
    # from the group.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # group = Sketchup.active_model.entities[0]
    # if group != nil
    #   if group.is_a? Sketchup::Group
    #     status = group.remove_observer observer
    #   end
    # end
    # ```
    def remove_observer: (Object observer) -> bool

    # The show_differences method is used to determine if a group is
    # geometrically equivalent to another group and in addition move the non-
    # matching and matching geometry to new layers.
    # 
    # This method will move both groups to Layer0.  Geometry that is the same
    # in both groups will be moved to a new layer named group_name + "_same".
    # Geometry that is not the same will be moved to a layer named group_name +
    # "_diff".
    # 
    # If verbose is true, a list of all the geometry that is different
    # from one group to the other is displayed texturally in the Ruby Console.
    # 
    # _@param_ `group` — The group to be compared with.
    # 
    # _@param_ `verbose` — A boolean flag indicating whether to display a textural report of the found differences to the Ruby console.
    # 
    # _@return_ — true if the groups are geometrically
    # equivalent. Otherwise false.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # group1 = entities[0]
    # group2 = entities[1]
    # status = group1.show_differences(group2, true)
    # ```
    def show_differences: ((Sketchup::Group | Sketchup::ComponentInstance) group, bool verbose) -> bool

    # The split method is used to compute the boolean split (map overlay) of the
    # two groups representing manifold solid volumes (this ^ arg). If the
    # specified objects (this and arg) do not represent manifold volumes,
    # this method fails.
    # 
    # _@param_ `group` — The group to split this group with.
    # 
    # _@return_ — A vector (array) of the three resultant groups
    # If the two objects (this and arg) represent manifold
    # solids and the operation succeeds otherwise nil is
    # returned. The 3 groups are as follows:
    # The intersection of volume 1 & volume 2,
    # the difference of volume 1 minus volume 2,
    # and the reverse difference of volume 2 minus volume 1.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # group1 = entities[0]
    # group2 = entities[1]
    # result = group1.split(group2)
    # ```
    # 
    # _@note_ — This method is not available in SketchUp Make.
    def split: ((Sketchup::Group | Sketchup::ComponentInstance) group) -> [Sketchup::Group, Sketchup::Group, Sketchup::Group]?

    # The subtract method is used to compute the boolean difference of the two
    # groups representing manifold solid volumes (this - arg).  If the specified
    # objects (this and arg) do not represent manifold volumes, this method fails.
    # 
    # _@param_ `group` — The group to subtract this group from.
    # 
    # _@return_ — The resultant group if the two objects
    # (this and arg) represent manifold solids and the
    # operation succeeds. Otherwise nil is returned.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # group1 = entities[0]
    # group2 = entities[1]
    # result = group1.subtract(group2)
    # ```
    # 
    # _@note_ — This method is not available in SketchUp Make.
    def subtract: ((Sketchup::Group | Sketchup::ComponentInstance) group) -> Sketchup::Group?

    # The to_component method is used to convert the group to a component
    # instance.
    # 
    # _@return_ — the new ComponentInstance object
    # 
    # ```ruby
    # # Add a group to the model.
    # group = Sketchup.active_model.entities.add_group
    # group.entities.add_line([0,0,0],[100,100,100])
    # 
    # # change the group to a component instance
    # group.to_component
    # ```
    def to_component: () -> Sketchup::ComponentInstance

    # The transform! method is used to apply a transformation to a group.
    # 
    # _@param_ `transform` — A Transformation object.
    # 
    # _@return_ — a transformed group object if successful
    # 
    # ```ruby
    # point = Geom::Point3d.new 500,500,500
    # t = Geom::Transformation.new point
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the group to the entities in the model
    # group = entities.add_group
    # 
    # # Get the entities within the group
    # entities2 = group.entities
    # 
    # # Add a face to within the group
    # face = entities2.add_face pts
    # UI.messagebox "Group before Move"
    # group = group.transform! t
    # if (group)
    #   UI.messagebox "Group after move"
    #   UI.messagebox group
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def transform!: (Geom::Transformation transform) -> Sketchup::Group

    # The transformation method is used to retrieve the transformation for the
    # group.
    # 
    # _@return_ — a Transformation object if successful
    # 
    # ```ruby
    # # Add a group to the model.
    # group = Sketchup.active_model.entities.add_group
    # group.entities.add_line([0,0,0],[100,100,100])
    # 
    # trans = group.transformation
    # ```
    def transformation: () -> Geom::Transformation

    # sord omit - no YARD return type given, using untyped
    # The {#transformation=} method is used to set the transformation of this
    # group
    # 
    # _@param_ `transformation`
    # 
    # ```ruby
    # # Add a group to the model.
    # group = Sketchup.active_model.entities.add_group
    # group.entities.add_line([0,0,0],[100,100,100])
    # 
    # new_transformation = Geom::Transformation.new([100,0,0])
    # group.transformation = new_transformation
    # ```
    def transformation=: (Geom::Transformation transformation) -> untyped

    # The trim method is used to compute the (non-destructive) boolean difference
    # of the two groups representing manifold solid volumes (this - arg).  If
    # the specified objects (this and arg) do not represent manifold volumes, this
    # method fails.
    # 
    # _@param_ `group` — The group to trim this group against.
    # 
    # _@return_ — The resultant group if the two objects
    # (this and arg) represent manifold solids and the
    # operation succeeds otherwise nil is returned.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # group1 = entities[0]
    # group2 = entities[1]
    # result = group1.trim(group2)
    # ```
    # 
    # _@note_ — This method is not available in SketchUp Make.
    def trim: ((Sketchup::Group | Sketchup::ComponentInstance) group) -> Sketchup::Group?

    # The union method is used to compute the boolean union of the two groups
    # representing manifold solid volumes (this | arg).  If the specified
    # objects (this and arg) do not represent manifold volumes, this method fails.
    # 
    # _@param_ `group` — The group to union this group with.
    # 
    # _@return_ — The resultant group if the two objects
    # (this and arg) represent manifold solids and the
    # operation succeeds. Otherwise nil is returned.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # group1 = entities[0]
    # group2 = entities[1]
    # result = group1.union(group2)
    # ```
    # 
    # _@note_ — This method is not available in SketchUp Make.
    def union: ((Sketchup::Group | Sketchup::ComponentInstance) group) -> Sketchup::Group?

    # The volume method is used to compute the volume of this group if and only
    # if this group is manifold.
    # 
    # _@return_ — If the group represents a manifold volume,
    # volume will be a positive value. If volume is negative,
    # the group is not manifold.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # group = entities.add_instance(definition, transformation)
    # volume = group.volume
    # ```
    def volume: () -> Float
  end

  # An Image object represents a raster image placed in the Model.
  # 
  # @example Create material from image (SU 2018 and later)
  #   model = Sketchup.active_model
  #   entities = model.active_entities
  #   image = entities.grep(Sketchup::Image).first
  #   img_rep = image.image_rep
  #   material = model.materials.add("New Name")
  #   material.texture = img_rep
  # 
  # @version SketchUp 6.0
  class Image < Sketchup::Drawingelement
    # The explode method is used to explode an image into a face with a texture
    # on it.
    # 
    # Note that current versions of SketchUp will return an empty array here.
    # To work around this limitation you can iterate over your entities collection
    # to determine which new entities were created.
    # 
    # Versions prior to SketchUp 2015 returned an empty array due to a bug.
    # 
    # _@return_ — entitiesarray - an Array object of entities if
    # successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = "Plugins/su_dynamiccomponents/images"
    # image_file = Sketchup.find_support_file("report_tool.png", path)
    # image = model.active_entities.add_image(image_file, ORIGIN, 300)
    # entities = image.explode
    # ```
    def explode: () -> untyped

    # The {#glued_to} method is used to retrieve the entity that this image is
    # glued to.
    # 
    # ```ruby
    # point = Geom::Point3d.new(10, 20, 30)
    # transform = Geom::Transformation.new(point)
    # model = Sketchup.active_model
    # entities = model.active_entities
    # group = entities.add_group
    # group.entities.add_face([[0, 0, 0], [10, 0, 0], [10, 10, 0], [0, 10, 0]])
    # status = group.glued_to
    # ```
    def glued_to: () -> (Sketchup::Face | Sketchup::Group | Sketchup::ComponentInstance | Sketchup::Image)?

    # The {glued_to=} method glues this image to a drawing element.
    # When moving this other drawing elment with the Move tool, the image moves with it.
    # 
    # _@param_ `drawing_element`
    # 
    # _@return_ — the entity the group was glued to.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # 
    # # Create a face
    # face = entities.add_face([[0, 0, 0], [100, 0, 0], [100, 100, 0], [0, 100, 0]])
    # 
    # # Create a group
    # path = "Plugins/su_dynamiccomponents/images"
    # image_file = Sketchup.find_support_file("report_tool.png", path)
    # image = model.active_entities.add_image(image_file, ORIGIN, 300)
    # 
    # # Glue the group to the face.
    # # If you now move the face, the group will follow.
    # image.glued_to = face
    # ```
    def glued_to=: ((Sketchup::Face | Sketchup::Group | Sketchup::ComponentInstance | Sketchup::Image)? drawing_element) -> (Sketchup::Face | Sketchup::Group | Sketchup::ComponentInstance | Sketchup::Image)?

    # The height method is used to retrieve the height of the image.
    # 
    # The height is given in inches.
    # 
    # _@return_ — height - the height of the model if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = Sketchup.find_support_file "report_tool.png", "Tools/DynamicComponents/images"
    # pt = Geom::Point3d.new
    # entities = model.active_entities
    # image = entities.add_image path, pt, 300
    # height = image.height
    # if (height)
    #   UI.messagebox height
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def height: () -> untyped

    # The height= method is used to set the height of the image.
    # 
    # The height is set in inches.
    # 
    # _@param_ `height` — The height, in inches, to set the image.
    # 
    # _@return_ — height - the new height if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = Sketchup.find_support_file "report_tool.png", "Tools/DynamicComponents/images"
    # pt = Geom::Point3d.new
    # entities = model.active_entities
    # image = entities.add_image path, pt, 300
    # UI.messagebox "Before adjustment"
    # height = image.height = 400
    # if (height)
    #   UI.messagebox height
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def height=: (untyped height) -> untyped

    # The {#image_rep} method returns a copy of a {Sketchup::ImageRep} object
    # representing the pixel data.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = "Plugins/su_dynamiccomponents/images"
    # image_file = Sketchup.find_support_file("report_tool.png", path)
    # image = model.active_entities.add_image(image_file, ORIGIN, 300)
    # image_rep = image.image_rep
    # ```
    def image_rep: () -> Sketchup::ImageRep

    # The normal method is used to retrieve the 3D Vector that is perpendicular to
    # the plane of the image.
    # 
    # _@return_ — vector - a Vector3d object if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = Sketchup.find_support_file "report_tool.png", "Tools/DynamicComponents/images"
    # pt = Geom::Point3d.new
    # entities = model.active_entities
    # image = entities.add_image path, pt, 300
    # vector = image.normal
    # if (vector)
    #   UI.messagebox vector
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def normal: () -> untyped

    # The origin method is used to retrieve the 3D point that defines the origin
    # of the image.
    # 
    # _@return_ — point - a Point3d object containing the origin location
    # if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = Sketchup.find_support_file "report_tool.png", "Tools/DynamicComponents/images"
    # pt = Geom::Point3d.new
    # entities = model.active_entities
    # image = entities.add_image path, pt, 300
    # origin = image.origin
    # if (origin)
    #   UI.messagebox origin
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def origin: () -> untyped

    # The origin= method is used to set the 3D point as the origin of the image.
    # 
    # _@param_ `point` — A Point3d object with the new origin.
    # 
    # _@return_ — point - the Point3d object representing the newly
    # established origin if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = Sketchup.find_support_file "report_tool.png", "Tools/DynamicComponents/images"
    # pt = Geom::Point3d.new
    # pt2 = Geom::Point3d.new 100,100,100
    # entities = model.active_entities
    # image = entities.add_image path, pt, 300
    # UI.messagebox "Before Move"
    # origin = image.origin=pt2
    # if (origin)
    #   UI.messagebox origin
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def origin=: (untyped point) -> untyped

    # The path method is used to retrieve the path of the file defining the image.
    # 
    # _@return_ — path - the path for the image file if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = Sketchup.find_support_file "report_tool.png", "Tools/DynamicComponents/images"
    # pt = Geom::Point3d.new
    # entities = model.active_entities
    # image = entities.add_image path, pt, 300
    # path = image.path
    # if (path)
    #   UI.messagebox path
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def path: () -> untyped

    # The pixelheight method is used to retrieve the height of the image file in
    # pixels.
    # 
    # _@return_ — height - the height of the image in pixels if
    # successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = Sketchup.find_support_file "report_tool.png", "Tools/DynamicComponents/images"
    # pt = Geom::Point3d.new
    # entities = model.active_entities
    # image = entities.add_image path, pt, 300
    # pixelheight = image.pixelheight
    # if (pixelheight)
    #   UI.messagebox pixelheight
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def pixelheight: () -> untyped

    # The pixelwidth method is used to retrieve the width of the image file in
    # pixels.
    # 
    # _@return_ — width - the width of the image in pixels if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = Sketchup.find_support_file "report_tool.png", "Tools/DynamicComponents/images"
    # pt = Geom::Point3d.new
    # entities = model.active_entities
    # image = entities.add_image path, pt, 300
    # pixelwidth = image.pixelwidth
    # if (pixelwidth)
    #   UI.messagebox pixelwidth
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def pixelwidth: () -> untyped

    # The size= method is used to set the width and height of the image, in inches.
    # 
    # _@param_ `width` — The width of the image.
    # 
    # _@param_ `height` — The height of the image.
    # 
    # _@return_ — size - the new width and height of the image if
    # successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = Sketchup.find_support_file "report_tool.png", "Tools/DynamicComponents/images"
    # pt = Geom::Point3d.new
    # entities = model.active_entities
    # image = entities.add_image path, pt, 300
    # UI.messagebox "Before Resize"
    # size = image.size= 500,500
    # if (size)
    #   UI.messagebox size
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def size=: (untyped width, untyped height) -> untyped

    # The transform! method is used to apply a transformation to the image.
    # 
    # _@param_ `transform` — A Transformation object.
    # 
    # _@return_ — image - the transformed Image object if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = Sketchup.find_support_file "report_tool.png", "Tools/DynamicComponents/images"
    # point = Geom::Point3d.new 100,100,100
    # t = Geom::Transformation.new point
    # pt = Geom::Point3d.new
    # entities = model.active_entities
    # image = entities.add_image path, pt, 300
    # UI.messagebox "Before Move"
    # image = image.transform! t
    # if (image)
    #   UI.messagebox image
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def transform!: (untyped transform) -> untyped

    # The transformation method is used to retrieve the transformation for the
    # image.
    # 
    # _@return_ — transformation - a Transformation object if successful
    # 
    # ```ruby
    # # Add an image to the model.
    # model = Sketchup.active_model
    # entities = model.active_entities
    # path = Sketchup.find_support_file('report_tool.png', 'Plugins/su_dynamiccomponents/images')
    # point = Geom::Point3d.new(100,100,100)
    # image = entities.add_image(path, point, 300)
    # 
    # trans = image.transformation
    # ```
    def transformation: () -> untyped

    # The transformation= method is used to set the transformation for the
    # image.
    # 
    # _@param_ `transform` — The Transformation object to apply
    # 
    # _@return_ — image - the newly transformed image
    # 
    # ```ruby
    # # Add an image to the model.
    # model = Sketchup.active_model
    # entities = model.active_entities
    # path = Sketchup.find_support_file('report_tool.png', 'Plugins/su_dynamiccomponents/images')
    # point = Geom::Point3d.new(100,100,100)
    # image = entities.add_image(path, point, 300)
    # 
    # new_transform = Geom::Transformation.new([100,0,0])
    # image.transformation = new_transform
    # ```
    def transformation=: (untyped transform) -> untyped

    # The width method is used to retrieve the width of the image.
    # 
    # The width is given in inches.
    # 
    # _@return_ — width - the width of the image if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = Sketchup.find_support_file "report_tool.png",
    #   "Tools/DynamicComponents/images"
    # pt = Geom::Point3d.new
    # entities = model.active_entities
    # image = entities.add_image path, pt, 300
    # width = image.width
    # if (width)
    #   UI.messagebox width
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def width: () -> untyped

    # The width= method is used to set the width of the image.
    # 
    # The width is set in inches.
    # 
    # _@param_ `width` — The width, in inches, to set the image.
    # 
    # _@return_ — width - the new width if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = Sketchup.find_support_file "report_tool.png", "Tools/DynamicComponents/images"
    # pt = Geom::Point3d.new
    # entities = model.active_entities
    # image = entities.add_image path, pt, 300
    # UI.messagebox "Before adjustment"
    # width = image.width=400
    # if (width)
    #   UI.messagebox width
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def width=: (untyped width) -> untyped

    # The zrotation method is used to get the angle that the image is rotated
    # about the normal vector from an arbitrary X axis.
    # 
    # _@return_ — vector - a Vector3d object if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = Sketchup.find_support_file "report_tool.png", "Tools/DynamicComponents/images"
    # pt = Geom::Point3d.new
    # entities = model.active_entities
    # image = entities.add_image path, pt, 300
    # zrotation = image.zrotation
    # if (zrotation)
    #   UI.messagebox zrotation
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def zrotation: () -> untyped
  end

  # The Layer class contains methods modifying and extracting information for a
  # layer.
  # 
  # By default, a SketchUp model has one layer, Layer 0 (Named "Untagged" in the
  # UI since SketchUp 2020), which is the base
  # layer. You can't delete or rename Layer 0. Unlike certain other CAD software
  # packages, entities associated with different layers in SketchUp still
  # intersect with each other. (If you want collections of entities to not
  # intersect, place them in Groups instead.)
  # 
  # Layers are commonly used to organize your model and control the visibility
  # of related groups and components. For example, you could make all of your
  # wall and roof entities different groups, associate layers with those groups,
  # and then hide those layers so as to display just the floor plan in the model.
  # 
  # @example
  #   model = Sketchup.active_model
  #   layers = model.layers
  #   new_layer = layers.add('Doors')
  # 
  # @note As of SketchUp 2020 "Layers" were renamed to "Tags" in the UI.
  #   The API retains the use of "Layer" for compatibility and is synonymous with
  #   "Tag".
  # 
  # @version SketchUp 6.0
  class Layer < Sketchup::Entity
    include Comparable

    # The {#<=>} method is used to compare two layers based on their names.
    # This enables the Ruby +Array#sort+ method to sort SketchUp layers.
    # 
    # _@param_ `layer2`
    # 
    # _@return_ — -1 if layer1 is less than layer2. 1 if layer2
    # is less than layer1. 0 if layer1 and layer2 are equal.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # new_layer = layers.add "test layer"
    # layer1 = layers[0]
    # layer2 = layers[1]
    # status = layer1 <=> layer2
    # ```
    def <=>: (Sketchup::Layer layer2) -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#==} method is used to determine if two layers are the same.
    # 
    # _@param_ `other`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # layer1 = layers.add("Test layer 1")
    # layer2 = layers.add("Test layer 2")
    # equal = layer1 == layer2
    # ```
    def ==: (Object other) -> untyped

    # The {#color} method is used to retrieve the color of the layer.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # new_layer = layers.add('Test layer')
    # color = new_layer.color
    # ```
    def color: () -> Sketchup::Color

    # sord omit - no YARD return type given, using untyped
    # The {#color=} method is used to set the name of a layer.
    # 
    # _@param_ `color`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # new_layer = layers.add('Test layer')
    # new_layer.color = Sketchup::Color.new(192, 0, 0)
    # ```
    def color=: (Sketchup::Color color) -> untyped

    # The {#display_name} method is used to retrieve the display name of the layer.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # new_layer = layers.add ("test layer")
    # name = new_layer.display_name
    # ```
    # 
    # _@see_ `#name`
    def display_name: () -> String

    # The {#folder} method is used to return the parent layer folder of a layer.
    # 
    # _@return_ — +nil+ if the folder is a direct child to
    # the layer manager.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # folder1 = layers.add_folder('Folder1')
    # layer1 = layers.add('Layer1')
    # layer1.folder = folder1
    # parent_folder = layer1.folder # Returns: folder1
    # ```
    def folder: () -> Sketchup::LayerFolder?

    # sord omit - no YARD return type given, using untyped
    # The {#folder=} method is used to set the parent layer folder of a layer.
    # 
    # This will trigger +onParentFolderChanged+ in normal cases and
    # +onLayerChanged+ during undo/redo.
    # 
    # _@param_ `parent` — +nil+ will make the layer a direct child to the layer manager.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # folder = layers.add_folder('Hello')
    # layer = layers.add_layer('World')
    # layer.folder = folder
    # ```
    def folder=: (Sketchup::LayerFolder? parent) -> untyped

    # The {#line_style} method retrieves the line style on this layer.
    # 
    # _@return_ — The line style retrieved.
    # 
    # ```ruby
    # line_style = Sketchup.active_model.layers[0].line_style
    # ```
    def line_style: () -> Sketchup::LineStyle?

    # The {#line_style=} method lets you set a specific line style to a layer
    # 
    # _@param_ `line_style` — The line style to set on this layer.
    # 
    # _@return_ — The layer that the line style was applied on.
    # 
    # ```ruby
    # line_style = Sketchup.active_model.line_styles["Dot"]
    # Sketchup.active_model.layers[0].line_style = line_style
    # ```
    def line_style=: (Sketchup::LineStyle? line_style) -> Sketchup::Layer

    # The {#name} method is used to retrieve the name of the layer.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # new_layer = layers.add "test layer"
    # name = new_layer.name
    # ```
    # 
    # _@see_ `#display_name`
    def name: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#name=} method is used to set the name of a layer.
    # 
    # _@param_ `name`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # new_layer = layers.add "test layer"
    # name = new_layer.name = "new test layer"
    # ```
    def name=: (String name) -> untyped

    # The {#page_behavior} method is used to retrieve the visibility behavior of the
    # layer for new pages and existing pages. For example, you may want your layer
    # to be visible or hidden by default in any new pages (aka Scenes) created by
    # the user.
    # 
    # A page keeps a list of layers that do not have their default behavior.
    # If a layer is not in that list, then it is set to its default visibility
    # determined by one of these values:
    # 
    # The behaviour is composed of a combination of these flags:
    # 
    # [Default visibility]
    #   These flags are used to set the value of {#page_behavior}. A page keeps
    #   a list of layers that do not have their default behavior. If a layer
    #   is not in that list, then it is set to its default visibility which
    #   is determined by one of these flags.
    #   - {LAYER_VISIBLE_BY_DEFAULT}: +0x0000+
    #   - {LAYER_HIDDEN_BY_DEFAULT}: +0x0001+
    # 
    # [Visibility on new pages]
    #   You can also set this addition flag that controls the visibility of
    #   a layer on newly created pages.
    #   - {LAYER_USES_DEFAULT_VISIBILITY_ON_NEW_PAGES}: +0x0000+
    #   - {LAYER_IS_VISIBLE_ON_NEW_PAGES}: +0x0010+
    #   - {LAYER_IS_HIDDEN_ON_NEW_PAGES}: +0x0020+
    # 
    # The default visibility for a layer is set by either
    # {LAYER_VISIBLE_BY_DEFAULT} or
    # {LAYER_HIDDEN_BY_DEFAULT}. This is what will be used when a page
    # does not contain the visibility state of a layer.
    # 
    # The remaining flags control the visibility of the layer for new pages.
    # 
    # _@return_ — an integer representing the current behavior of the layer.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # layer = layers.add('Test Layer')
    # hidden_by_default = (layer.page_behavior & LAYER_HIDDEN_BY_DEFAULT) ==
    #                     LAYER_HIDDEN_BY_DEFAULT
    # ```
    def page_behavior: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#page_behavior=} method is used to control the layer's visibility
    # behavior on existing and new pages.
    # 
    # When you Update a page (as opposed to creating a new page) the current
    # visibility of the layer is used.
    # 
    # The behavior is composed of a combination of these flags:
    # 
    # [Default visibility]
    #   These flags are used to set the value of {#page_behavior}. A page keeps
    #   a list of layers that do not have their default behavior. If a layer
    #   is not in that list, then it is set to its default visibility which
    #   is determined by one of these flags.
    #   - {LAYER_VISIBLE_BY_DEFAULT}: +0x0000+
    #   - {LAYER_HIDDEN_BY_DEFAULT}: +0x0001+
    # 
    # [Visibility on new pages]
    #   You can also set this addition flag that controls the visibility of
    #   a layer on newly created pages.
    #   - {LAYER_USES_DEFAULT_VISIBILITY_ON_NEW_PAGES}: +0x0000+
    #   - {LAYER_IS_VISIBLE_ON_NEW_PAGES}: +0x0010+
    #   - {LAYER_IS_HIDDEN_ON_NEW_PAGES}: +0x0020+
    # 
    # _@param_ `page_behavior`
    # 
    # ```ruby
    # layers = Sketchup.active_model.layers
    # layer = layers.add('Test Layer')
    # behavior = LAYER_HIDDEN_BY_DEFAULT | LAYER_IS_HIDDEN_ON_NEW_PAGES
    # layer.page_behavior = behavior
    # ```
    def page_behavior=: (Integer page_behavior) -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#visible=} method is used to set if the layer is visible.
    # 
    # _@param_ `visible`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # layer = layers.add('Hello World')
    # layer.visible = false
    # ```
    def visible=: (bool visible) -> untyped

    # The {#visible?} method is used to determine if the layer is visible.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # layer = layers.add('Hello World')
    # layer.visible? # Returns: true
    # ```
    def visible?: () -> bool
  end

  # This is the interface to a SketchUp model. The model is the 3D drawing that
  # the user is working with, and it serves as the "entry point" for most Ruby
  # API interactions. The Sketchup.active_model method gives you a handle to the
  # current model, and from there you can use the model-level methods to start
  # getting information and making changes.
  # 
  # Constants:
  # Product Family
  # - Model::ProTrial
  # - Model::ProLicensed
  # - Model::MakeTrial
  # - Model::MakeTrialExpired
  # 
  # @bug Prior to SketchUp 2019.0 this class would yield +TypeError+ for all
  #   method calls if +#singleton_class+ was called on the model object.
  # 
  # @example
  #   # Grab a handle to the currently active model (aka the one the user is
  #   # looking at in SketchUp.)
  #   model = Sketchup.active_model
  # 
  #   # Grab other handles to commonly used collections inside the model.
  #   entities = model.entities
  #   layers = model.layers
  #   materials = model.materials
  #   component_definitions = model.definitions
  #   selection = model.selection
  # 
  #   # Now that we have our handles, we can start pulling objects and making
  #   # method calls that are useful.
  #   first_entity = entities[0]
  #   UI.messagebox("First thing in your model is a #{first_entity.typename}")
  # 
  #   number_materials = materials.length
  #   UI.messagebox("Your model has #{number_materials} materials.")
  # 
  #   new_edge = entities.add_line([0,0,0], [500,500,0])
  # 
  # @version SketchUp 6.0
  class Model
    LOAD_STATUS_SUCCESS: untyped
    LOAD_STATUS_SUCCESS_MORE_RECENT: untyped
    Make: untyped
    MakeTrial: untyped
    ProLicensed: untyped
    ProTrial: untyped
    VERSION_2013: untyped
    VERSION_2014: untyped
    VERSION_2015: untyped
    VERSION_2016: untyped
    VERSION_2017: untyped
    VERSION_2018: untyped
    VERSION_2019: untyped
    VERSION_2020: untyped
    VERSION_2021: untyped
    VERSION_3: untyped
    VERSION_4: untyped
    VERSION_5: untyped
    VERSION_6: untyped
    VERSION_7: untyped
    VERSION_8: untyped

    # The {#abort_operation} method aborts the current operation started with the
    # start_operation method.
    # 
    # The {#abort_operation} method is normally called from inside of a rescue
    # clause to cancel an operation if something goes wrong.
    # 
    # _@return_ — true if successful, false if unsuccessful
    # 
    # ```ruby
    # status = model.abort_operation
    # ```
    # 
    # _@note_ — Never abort a transparent operation. Doing so would abort the operation
    # it chains to. Instead, try to clean up and simply commit in order to make
    # sure the operation is closed.
    def abort_operation: () -> bool

    # Returns an {Sketchup::Entities} object which contains
    # the entities in the open group or component instance. If no group or
    # component is open for editing then this will be the same as {#entities}.
    # 
    # To perform actions upon the current set of entities the user is working with
    # then this is the method to use. Entities selected by the user will be a
    # subset of the active entities.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # entities.each { |entity| puts "#{entity} (#{entity.class})" }
    # ```
    # 
    # _@see_ `#edit_transform`
    def active_entities: () -> Sketchup::Entities

    # The {#active_layer} method retrieves the active Layer.
    # 
    # The default layer in SketchUp is layer 0.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layer = model.active_layer
    # ```
    def active_layer: () -> Sketchup::Layer

    # The {#active_layer=} method sets the active {Sketchup::Layer} object.
    # 
    # _@param_ `layer` — The layer to be set as the active layer.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # layer = layers.add('My Layer')
    # model.active_layer = layer
    # ```
    def active_layer=: (Sketchup::Layer layer) -> Sketchup::Layer

    # Returns an array containing the sequence of entities the user has
    # double-clicked on for editing. This allows one to determine whether they are
    # in component edit mode and where in the model they are.
    # 
    # For example, if a user has double-clicked into a component to
    # edit its geometry, and then double clicked into a sub-group to edit that,
    # the active_path might contain:
    # 
    # <code>[<Sketchup::ComponentInstance>, <Sketchup::Group>]</code>
    # 
    # _@return_ — array of entities showing where the user is
    # currently editing.
    # 
    # ```ruby
    # active_path = Sketchup.active_model.active_path
    # ```
    def active_path: () -> ::Array[Sketchup::Drawingelement]?

    # The {#active_path=} method is used to open a given instance path for editing.
    # 
    # _@param_ `instance_path` — Passing +nil+ or an empty array will close all open instances.
    # 
    # Open an instance
    # ```ruby
    # model = Sketchup.active_model
    # instance = model.active_entities.grep(Sketchup::ComponentInstance).first
    # instance_path = Sketchup::InstancePath.new([instance])
    # model.active_path = instance_path
    # ```
    # 
    # Close all instances
    # ```ruby
    # model = Sketchup.active_model
    # model.active_path = nil
    # ```
    # 
    # _@note_ — An instance path can only be opened if the instances are not locked.
    # This also include instances of the same component definition that are not
    # on the given path. A definition cannot be edited if any of its instances
    # are locked.
    # 
    # _@note_ — Since changing the active entities in SketchUp also changes what
    # coordinate system is used, entities can't be modified in the same operation
    # as the active entities changes. The API handles this automatically by
    # starting and committing transparent operations as needed.
    # 
    # If the API user tries to do this:
    # 
    #     model.start_operation('...', true)
    #     model.active_entities.add_face(...)
    #     model.active_path = instance_path
    #     model.active_entities.add_face(...)
    #     model.commit_operation
    # 
    # Then SketchUp will automatically break it up to something like to this:
    # 
    #     model.start_operation('...', true)
    #     model.active_entities.add_face(...)
    #     model.commit_operation
    # 
    #     model.start_operation('...', true, false, true)
    #     model.active_path = instance_path
    #     model.commit_operation
    # 
    #     model.start_operation('...', true, false, true)
    #     model.active_entities.add_face(...)
    #     model.commit_operation
    # 
    # For the end user this will be experienced as a single operation.
    # 
    # For the API user the side-effect is multiple transaction notifications to
    # {Sketchup::ModelObserver}s.
    def active_path=: ((Sketchup::InstancePath | ::Array[(Sketchup::ComponentInstance | Sketchup::Group)])? instance_path) -> Sketchup::Model

    # The {#active_view} method returns the active View object for this model.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # view = model.active_view
    # ```
    def active_view: () -> Sketchup::View

    # Add a text note to the Model.  The position of the note is given as relative
    # window positions between 0 and 1.  For example, the following command
    # would create a note that start 1/10 of the ways down the screen from the
    # upper left corner of the window.
    # 
    # _@param_ `note` — A string note.
    # 
    # _@param_ `x` — A distance along the x axis between 0 and 1.
    # 
    # _@param_ `y` — A distance along the y axis between 0 and 1.
    # 
    # _@return_ — a note object or an exception if it is
    # unsuccessful.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # # Add a note 1/10 ways down the screen and 1/10 ways right from the
    # # upper left corner of model window.
    # note = Sketchup.active_model.add_note('Hello World', 0.1, 0.1)
    # ```
    def add_note: (String note, Numeric x, Numeric y) -> Sketchup::Text

    # The add_observer method is used to add an observer to the current object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # observer = Sketchup::ModelObserver.new
    # status = model.add_observer(observer)
    # ```
    def add_observer: (Object observer) -> bool

    # The {#attribute_dictionaries} method retrieves the AttributeDictionaries
    # object that is associated with the Model.
    # 
    # _@return_ — the AttributeDictionaries
    # object associated with the entity, or nil if there are
    # no attribute_dictionary objects associated with the
    # model. Care must be taken if nil is returned, for
    # example: invoking attribute_dictionaries.length will
    # throw a NoMethodError exception, not return 0.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # dictionaries = model.attribute_dictionaries
    # if dictionaries
    #   # Code to do something if attribute dictionaries exist (usually you
    #   # parse the array of dictionaries.
    # else
    #   # Code to do something if attribute dictionaries do not exist.
    # end
    # ```
    def attribute_dictionaries: () -> Sketchup::AttributeDictionaries

    # Returns the Sketchup::AttributeDictionary object that is specified by
    # name.  If the model does not have an attribute dictionary that
    # corresponds to name, returns either nil, or a creates an attribute
    # dictionary.  If the optional second argument is true, and there is no
    # attribute dictionary that corresponds to name, a new attribute
    # dictionary is created.
    # 
    # _@param_ `name` — The name of the dictionary you are attempting to retrieve.
    # 
    # _@param_ `create` — if set to true an attribute dictionary of the given "name" will be created if not found.
    # 
    # _@return_ — an attribute dictionary object if
    # successful, nil if unsuccessful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # create_if_empty = true
    # dictionary = model.attribute_dictionary('name', create_if_empty)
    # ```
    def attribute_dictionary: (String name, ?bool create) -> Sketchup::AttributeDictionary

    # The {#axes} method returns the drawing axes for the model.
    # 
    # _@return_ — the axes for the model.
    # 
    # ```ruby
    # # Point for a rectangle.
    # points = [
    #   Geom::Point3d.new( 0,  0, 0),
    #   Geom::Point3d.new(10,  0, 0),
    #   Geom::Point3d.new(10, 20, 0),
    #   Geom::Point3d.new( 0, 20, 0)
    # ]
    # # Transform the points so they are local to the model axes. Otherwise
    # # they would be local to the model origin.
    # tr = Sketchup.active_model.axes.transformation
    # points.each { |point| point.transform!(tr) }
    # Sketchup.active_model.active_entities.add_face(points)
    # ```
    def axes: () -> Sketchup::Axes

    # The behavior method retrieves the behavior of the model.
    # 
    # _@return_ — behavior object for the model if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # behavior = model.behavior
    # ```
    def behavior: () -> Sketchup::Behavior

    # The {#bounds} method is used to retrieve the {Geom::BoundingBox} bounding the
    # contents of a {Sketchup::Model}.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # bounds = model.bounds
    # ```
    def bounds: () -> Geom::BoundingBox

    # The {#classifications} method is used to retrieve the Classifications object
    # for this model.
    # 
    # _@return_ — a Classifications object.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # c = model.classifications
    # ```
    def classifications: () -> Sketchup::Classifications

    # The close method is used to close this model. On Mac OS, only the active
    # model can be closed. On Windows, since there can be only one document open,
    # this method will perform a File/New operation.
    # 
    # _@param_ `ignore_changes` — If true, model changes will be ignored and save prompts will be suppressed. If false, changes will not be ignored and save prompts will be displayed normally.
    # 
    # ```ruby
    # Sketchup.file_new
    # model = Sketchup.active_model
    # model.close
    # ```
    def close: (?bool ignore_changes) -> void

    # The {#close_active} method is used to close the currently active (open) group
    # or component.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # status = model.close_active
    # ```
    # 
    # _@note_ — Before SketchUp 2014 this method had a bug where it didn't create an
    # undo operation and that could lead to corrupted geometry when undo/redo was
    # used after invoking this method.
    def close_active: () -> bool

    # The commit_operation method commits an operation for undo.
    # 
    # The commit_operation method is normally called at the end of a method to
    # commit the operation that the method performs.
    # 
    # _@return_ — true if successful, false if unsuccessful
    # 
    # ```ruby
    # status = model.commit_operation
    # ```
    def commit_operation: () -> bool

    # The {#definitions} method retrieves a definition list containing all of the
    # component definitions in the model.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # definitions = model.definitions
    # ```
    def definitions: () -> Sketchup::DefinitionList

    # The description method retrieves a description of the model as found in the
    # Model Info > Files panel.
    # 
    # The returned description can be empty. The default description for all models
    # is empty.
    # 
    # _@return_ — a description if successful.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # description = model.description
    # ```
    def description: () -> String

    # The {#description=} method sets the description of the model.
    # 
    # _@param_ `description` — the description string to be set.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # description = model.description = "This is a model of a house on the " <<
    #   "North West Corner of 10th and Dolores Street in Carmel, California"
    # ```
    def description=: (String description) -> String

    # The {#drawing_element_visible?} method reports whether the given drawing
    # element in an instance path is visible given the current model options.
    # 
    # _@param_ `instance_path`
    # 
    # Traversing every visible entity in the model
    # ```ruby
    # module Example
    # 
    #   def self.instance?(entity)
    #     entity.is_a?(Sketchup::ComponentInstance) || entity.is_a?(Sketchup::Group)
    #   end
    # 
    #   # Walk the visible entities in the model, taking into account
    #   # "DrawHiddenGeometry" and "DrawHiddenObjects" rendering options.
    #   def self.walk(entities, transformation = IDENTITY, path = [], &block)
    #     entities.each { |entity|
    #       entity_path = path + [entity]
    #       next unless entity.model.drawing_element_visible?(entity_path)
    #       block.call(entity, transformation, path)
    #       if instance?(entity)
    #         child_entities = entity.definition.entities
    #         child_transformation = transformation * entity.transformation
    #         walk(child_entities, child_transformation, entity_path, &block)
    #       end
    #     }
    #   end
    # 
    # end
    # 
    # model = Sketchup.active_model
    # Example.walk(model.entities) do |entity, transformation, path|
    #   # Do something to every visible entity in the model...
    # end
    # ```
    # 
    # _@see_ `Sketchup::RenderingOptions`
    # 
    # _@see_ `Sketchup::Drawingelement#visible?`
    # 
    # _@see_ `Sketchup::Layer#visible?`
    def drawing_element_visible?: ((Sketchup::InstancePath | ::Array[Sketchup::Drawingelement]) instance_path) -> bool

    # Returns the transformation of the current component edit session. If a user
    # has double-clicked to edit a component's geometry, this will
    # return the transformation of that component, relative to its parent's
    # origin. This allows one to correctly calculate "local" transformations of
    # a given entity regardless of whether the user is in edit mode.
    # 
    # _@return_ — the current edit Transformation
    # 
    # ```ruby
    # Sketchup.active_model.edit_transform
    # ```
    def edit_transform: () -> Geom::Transformation

    # The {#entities} method returns an {Sketchup::Entities} object containing the
    # entities in the root of model.
    # 
    # _@return_ — an Entities object if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.entities
    # ```
    # 
    # _@note_ — This does not return a collection of all the entities in the model,
    # only the top level node of the model hierarchy. To get to all entities in
    # a model you must recursivly traverse the model.
    def entities: () -> Sketchup::Entities

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The export method is used to export a given file format. It knows which
    # format to export based on the file extension you place on the file name.
    # For example, a filename of "thing.obj" will export an OBJ file, whereas
    # "thing.dae" will export a COLLADA file.
    # 
    # For SketchUp Pro 7.1+, valid extensions include dae, kmz, 3ds, dwg,
    # dxf, fbx, obj, wrl, and xsi. SketchUp Free only supports dae and kmz.
    # 
    # Format Support Changes:
    # * SketchUp 7.1 added COLLADA (.dae) export capability.
    # * SketchUp Pro 2015+ added IFC export capability.
    # * SketchUp Pro 2016+ added PDF export capability.
    # * SketchUp Pro 2018+ added options for all 3D exporters.
    # 
    # See the {file:pages/exporter_options.md Exporter Options} file for information
    # on creating a valid hash for the various exporters.
    # 
    # General use
    # ```ruby
    # model = Sketchup.active_model
    # show_summary = true
    # 
    # # Export dwg file on a PC, showing a summary when complete.
    # status = model.export('c:\my_export.dwg', show_summary)
    # 
    # # Export kmz file on Mac (note the absolute file path), without summary.
    # status = model.export('/Library/my_export.kmz')
    # 
    # # Export pdf file on a PC, showing a summary when complete.
    # options_hash = { :show_summary => true,
    #                  :output_profile_lines => false,
    #                  :map_fonts => false,
    #                  :model_units => Length::Meter }
    # status = model.export('c:/my_export.pdf', options_hash)
    # 
    # # Or for a COLLADA (.dae) file.
    # options_hash = { :triangulated_faces => true,
    #                  :doublesided_faces => true,
    #                  :edges => false,
    #                  :author_attribution => false,
    #                  :texture_maps => true,
    #                  :selectionset_only => false,
    #                  :preserve_instancing => true }
    # status = model.export('c:/my_export.dae', options_hash)
    # ```
    # 
    # IFC Example
    # ```ruby
    # model = Sketchup.active_model
    # # If no IFC types are passed in, then no geometry will be exported.
    # options_hash = { :hidden_geometry => true,
    #                  :ifc_mapped_items => true,
    #                  :ifc_types => ['IfcBuilding', 'IfcDoor']}
    # status = model.export('c:/my_export.ifc', options_hash)
    # ```
    def export: (*untyped args) -> untyped

    # Finds and returns entities by their entityID or GUID.
    # 
    # GUIDs looked up are only relevant to Group and ComponentInstance as these
    # GUIDs are persistent. ComponentDefinition and Model GUIDs are not persistent
    # and are not looked up.
    # 
    # When given an array of IDs, an array is returned with a 1:1 mapping to the
    # input arguments. This array may contain nil values if some ids were not
    # found. You cannot look up a mix of entityIDs and GUIDs in the same call.
    # 
    # _@param_ `ids_or_array` — Pass either a series of ids or a single array containing ids. Ids must either be entityID Integers or GUID Strings.
    # 
    # _@return_ — Returns an array with Entity  objects for each id
    # found and nil otherwise. Single Entity or nil when
    # called with a single id.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # 
    # # Look up by entityID.
    # entity_id = model.entities.add_line([0,0,0], [9,9,9]).entityID
    # entity = model.find_entity_by_id(entity_id)
    # 
    # # Look up by GUID.
    # guid = model.entities.add_group.guid
    # entity = model.find_entity_by_id(guid)
    # 
    # # Look up multiple.
    # entities = model.find_entity_by_id(id1, id2, id3)
    # entities = model.find_entity_by_id([id1, id2, id3])
    # entities = model.find_entity_by_id(guid1, guid2, guid3)
    # entities = model.find_entity_by_id([guid1, guid2, guid3])
    # ```
    def find_entity_by_id: (::Array[(Integer | String)] ids_or_array) -> ::Array[(Sketchup::Entity | NilClass)]

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # Finds and returns entities by their persistent id.
    # 
    # When given an array of IDs, an array is returned with a 1:1 mapping to the
    # input arguments. This array may contain `nil` values if some ids were not
    # found.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # 
    # # Look up by persistent_id.
    # pid = model.entities.add_line([0,0,0], [9,9,9]).persistent_id
    # entity = model.find_entity_by_persistent_id(pid)
    # 
    # # Look up multiple.
    # entities = model.find_entity_by_persistent_id(id1, id2, id3)
    # entities = model.find_entity_by_persistent_id([id1, id2, id3])
    # ```
    # 
    # Limit search by scope
    # ```ruby
    # model = Sketchup.active_model
    # edge_pid = model.entities.add_line([0,0,0], [9,9,9]).persistent_id
    # layer_pid = model.layers.add('Hello World').persistent_id
    # 
    # # Search in all scopes:
    # entities = model.find_entity_by_persistent_id(edge_pid, layer_pid)
    # # => [#<Sketchup::Edge:0x000002567da4a8f0>, #<Sketchup::Layer:0x000002567da49e50>]
    # 
    # # Search in layer scope:
    # entities = model.find_entity_by_persistent_id(edge_pid, layer_pid, layers: true)
    # # => [nil, #<Sketchup::Layer:0x000002567da49e50>]
    # ```
    def find_entity_by_persistent_id: (*untyped args) -> untyped

    # This methods determines if the model is georeferenced.
    # 
    # ```ruby
    # if model.georeferenced?
    #   UI.messagebox('This model is georeferenced.')
    # else
    #   UI.messagebox('This model is NOT georeferenced.')
    # end
    # ```
    def georeferenced?: () -> bool

    # The get_attribute method gets the value of an attribute that in the
    # AttributeDictionary with the given name. If no value is associated
    # with key, or if the model does not have an attribute dictionary
    # specified by name, the optional third parameter will be returned.
    # 
    # _@param_ `dictname` — The name of the dictionary containing the value.
    # 
    # _@param_ `key` — The key containing the value.
    # 
    # _@param_ `defaultvalue` — default value that will be returned if a value does not exist.
    # 
    # _@return_ — the value for a given key in the given
    # dictionary if a value exists; the default value if a
    # defaultvalue is provided and the value does not exist;
    # nil if the value does not exist and no defaultvalue is
    # provided.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # model.set_attribute('testdictionary', 'test', 115)
    # value = model.get_attribute('testdictionary', 'test', 42)
    # ```
    def get_attribute: (String dictname, String key, ?Object? defaultvalue) -> Object?

    # the get_datum method retrieves the datum, in the form of a string, used in
    # UTM conversions.
    # 
    # _@return_ — a datum represented as a string if successful.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # datum = model.get_datum
    # ```
    def get_datum: () -> String

    # Returns a value which indicates the product family of the installed SketchUp
    # application.
    # As of SketchUp 2013, the return values are:
    # - +0+ = Unknown
    # - +1+ = Pro Trial
    # - +2+ = Pro
    # - +3+ = Pro Expired
    # - +4+ = Make Trial
    # - +5+ = Make Expired
    # - +6+ = Make
    # - +7+ = Pro License Unavailable
    # 
    # The Model class defines some of these values as constants as of SketchUp
    # 2016.
    # 
    # _@return_ — the product family number.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # product_family = model.get_product_family
    # if product_family == Sketchup::Model::ProLicensed then
    #   puts "You are running licensed SketchUp Pro!"
    # end
    # ```
    def get_product_family: () -> Integer

    # The guid method retrieves the globally unique identifier, in the form of a
    # string, for the Model. The guid will change after the model is modified and
    # saved. The Model guid is stored with the SketchUp file; it will not change if the
    # file is moved to another computer.
    # 
    # _@return_ — a globally unique identifier, in the form of a
    # string, for the model
    # 
    # ```ruby
    # model = Sketchup.active_model
    # guid = model.guid
    # ```
    def guid: () -> String

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The import method is used to load a file by recognizing the file extension
    # and calling appropriate importer.
    # 
    # See {Sketchup::DefinitionList#import} for importing a 3d model file as a
    # component definition, without activating the UI for placing an instance.
    # 
    # See the {file:pages/importer_options.md Importer Options} file for information
    # on creating a valid hash for the various importers.
    # 
    # Import for SketchUp 2017 and older
    # ```ruby
    # model = Sketchup.active_model
    # show_summary = true
    # status = model.import("filename", show_summary)
    # ```
    # 
    # Import for SketchUp 2018+ and newer
    # ```ruby
    # model = Sketchup.active_model
    # options = { :units => "model",
    #             :merge_coplanar_faces => true,
    #             :show_summary => true }
    # status = model.import("filename", options)
    # ```
    def import: (*untyped args) -> untyped

    # The {#instance_path_from_pid_path} method returns a instance path given a
    # string with persistent ids representing the path to the entity.
    # 
    # _@param_ `pid_path` — a string with persistent ids delimited by period.
    # 
    # ```ruby
    # points = [
    #   Geom::Point3d.new( 0,  0, 0),
    #   Geom::Point3d.new(10,  0, 0),
    #   Geom::Point3d.new(10, 20, 0),
    #   Geom::Point3d.new( 0, 20, 0)
    # ]
    # model = Sketchup.active_model
    # entities = model.active_entities
    # group = entities.add_group
    # face = group.entities.add_face(points)
    # pid_path = "#{group.persistent_id}.#{face.persistent_id}"
    # # pid_path will look something like this: "658.723"
    # instance_path = model.instance_path_from_pid_path(pid_path)
    # ```
    # 
    # _@see_ `Sketchup::InstancePath#persistent_id_path`
    def instance_path_from_pid_path: (String pid_path) -> Sketchup::InstancePath

    # The latlong_to_point method converts a latitude and longitude to a Point3d
    # object in the model. It does not actually work with a LatLong object, but
    # operates on a 2-element array. The returned point will always be on the
    # ground (z=0).
    # 
    # _@param_ `lnglat_array` — A 2-element array containing first the longitude then the latitude.
    # 
    # _@return_ — a point3d object if successful, false if
    # unsuccessful.
    # 
    # ```ruby
    # # Draw a point in Boulder, Colorado (40.0170N, 105.2830W)
    # lnglat_array = [-105.28300, 40.01700]
    # model = Sketchup.active_model
    # local_point = model.latlong_to_point(lnglat_array)
    # model.entities.add_cpoint(local_point)
    # ```
    def latlong_to_point: ([Numeric, Numeric] lnglat_array) -> Geom::Point3d

    # The {#layers method retrieves a collection of all Layers objects in the model.
    # 
    # _@return_ — a Layers object containing a collection of
    # layers in the model
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # ```
    def layers: () -> Sketchup::Layers

    # The {#line_styles} method returns the line styles manager.
    # 
    # _@return_ — The line styles manager.
    # 
    # ```ruby
    # line_styles = Sketchup.active_model.line_styles
    # ```
    def line_styles: () -> Sketchup::LineStyles

    # This method retrieves an Array of all of the datums recognized by SketchUp.
    # 
    # _@return_ — An Array object containing the datums
    # supported by SketchUp
    # 
    # ```ruby
    # model = Sketchup.active_model
    # datums = model.list_datums
    # ```
    def list_datums: () -> ::Array[String]

    # The {#materials} method returns a collection of all of the materials in the
    # model.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # ```
    def materials: () -> Sketchup::Materials

    # This method can be used to turn mipmapping on or off.
    # 
    # _@param_ `mipmap` — whether mipmapping is turned on or off.
    # 
    # _@return_ — the new mipmapping setting
    # 
    # ```ruby
    # Sketchup.active_model.mipmapping = false
    # ```
    def mipmapping=: (bool mipmap) -> bool

    # This method can be used to find out if mipmapping is on or off.
    # 
    # ```ruby
    # mipmapping = Sketchup.active_model.mipmapping?
    # ```
    def mipmapping?: () -> bool

    # The modified? method determines if the Model has been modified since the
    # last save.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # # Add a group to force the status return value to be true
    # entities.add_group
    # status = model.modified?
    # ```
    def modified?: () -> bool

    # The {#name} method retrieves the name of the model.
    # 
    # This property can be seen in Model Info and maps to the component
    # name if the model is inserted into another model. This property should not
    # be confused with the model {#path}.
    # 
    # _@return_ — string name of the model
    # 
    # ```ruby
    # model = Sketchup.active_model
    # name = model.name
    # ```
    def name: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#name=} method sets the string name of the model.
    # 
    # _@param_ `name`
    # 
    # ```ruby
    # Sketchup.active_model.name = "My New Model Name"
    # ```
    def name=: (String name) -> untyped

    # Returns the number faces in a model.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # number_of_faces = model.number_faces
    # puts "There are #{number_of_faces} faces in the model."
    # ```
    def number_faces: () -> Integer

    # The {#options} method retrieves the options manager that defines the options
    # settings for the model.
    # 
    # Use the string keys instead of numerical indicies when accessing the options
    # as the indicies are not consistent between SketchUp versions.
    # 
    # ```ruby
    # # Output all options available.
    # options_manager = Sketchup.active_model.options
    # options_manager.each { |options_provider|
    #   puts options_provider.name
    #   options_provider.each { |key, value|
    #     puts "> #{key} - #{value}"
    #   }
    # }
    # ```
    def options: () -> Sketchup::OptionsManager

    # The {#pages} method retrieves a {Sketchup::Pages} object containing all of
    # the pages in the model.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # ```
    def pages: () -> Sketchup::Pages

    # The path method retrieves the path of the file from which the model was
    # opened.
    # 
    # An empty string is returned for a model that has not been saved.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # path = model.path
    # ```
    def path: () -> String

    # The place_component method places a new component in the Model using the
    # component placement tool.
    # 
    # _@param_ `componentdef` — A component definition object containing the definition (blueprint) for the component.
    # 
    # _@param_ `repeat` — If set to true, stay in the component placement tool and place multiple components.
    # 
    # _@return_ — The model object on success or Nil
    # 
    # ```ruby
    # model.place_component componentdefinition, repeat
    # ```
    def place_component: (Sketchup::ComponentDefinition componentdef, ?bool repeat) -> Sketchup::Model?

    # The point_to_latlong method converts a point in the model to a LatLong so
    # that you can get its latitude and longitude.
    # 
    # This method uses the location information set in ShadowInfo.
    # 
    # NOTE: SketchUp 6.0 and higher has a change where this method returns a
    # Point3d instead of a LatLong, where the x and y values contain the LatLong
    # coordinates.
    # 
    # _@param_ `point` — A Point3d object.
    # 
    # _@return_ — a LatLong or Point3d object. See
    # details for information.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # local_point = Geom::Point3d.new(10, 10, 10)
    # world_point = model.point_to_latlong(local_point)
    # ```
    def point_to_latlong: (Geom::Point3d point) -> (Geom::Point3d | Geom::LatLong)

    # This method converts a Point3d object in the Model to UTM coordinates.
    # 
    # This method uses the location information set in ShadowInfo. See also UTM.
    # 
    # _@param_ `point` — A Point3d object.
    # 
    # _@return_ — a UTM object
    # 
    # ```ruby
    # model = Sketchup.active_model
    # point = Geom::Point3d.new(10, 10, 10)
    # utm = model.point_to_utm(point)
    # ```
    def point_to_utm: (Geom::Point3d point) -> Geom::UTM

    # The raytest method is used to cast a ray (line) through the model and return
    # the first thing that the ray hits.
    # 
    # A ray is a two element array containing a point and a vector
    # [Geom::Point3d(), Geom::Vector3d()]. The point defines the start point of
    # the ray and the vector defines the direction. If direction can not be
    # normalized (e.g. direction = [0, 0, 0]), direction is taken as a point the
    # ray intersects.
    # 
    # first value is a Point3d where the item that the ray passed through exists. The second element is
    # the instance path array of the entity that the ray hit. For example, if the ray hits a face that
    # is contained by a component instance the instance path would be [Component1]. If the ray hit a
    #   face that is contained by a component instance, which
    #   is contained by another component instance and so on,
    #   the instance path would be [Component1, Component2,
    #   Component3...].
    # 
    # _@param_ `ray` — A two element array containing a point and a vector.
    # 
    # _@param_ `wysiwyg_flag` — An optional boolean, added in SU8 M1, indicating whether or not to consider hidden geometry in intersect computations.  If this flag is not specified, it defaults to true (WYSIWYG) - i.e. hidden geometry is not intersected against.
    # 
    # _@return_ — an array of two values. The
    # 
    # ```ruby
    # model = Sketchup.active_model
    # ray = [Geom::Point3d.new(1, 2, 3), Geom::Vector3d.new(4, 5, 6)]
    # item = model.raytest(ray, false) # Consider hidden geometry when
    #                                  # computing intersections.
    # ```
    # 
    # _@note_ — The parameter wysiwyg_flag was added in SU8 M1.
    def raytest: ([Geom::Point3d, Geom::Vector3d] ray, ?bool wysiwyg_flag) -> [Geom::Point3d, ::Array[Sketchup::Drawingelement]]?

    # The remove_observer method is used to remove an observer from the current
    # object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # observer = Sketchup::ModelObserver.new
    # model.add_observer(observer)
    # status = model.remove_observer(observer)
    # ```
    def remove_observer: (Object observer) -> bool

    # The {#rendering_options} method retrieves the RenderingOptions object for
    # this model.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # renderingoptions = model.rendering_options
    # ```
    def rendering_options: () -> Sketchup::RenderingOptions

    # sord omit - no YARD type given for "*args", using untyped
    # This method is used to save the model to a file.
    # 
    # _@return_ — +true+ if successful, +false+ if unsuccessful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # # Save the model using the current SketchUp format
    # path = File.join(ENV['HOME'], 'Desktop', 'mysketchup.skp')
    # status = model.save(path)
    # 
    # # Save the model to the current file using the current SketchUp format
    # status = model.save
    # 
    # # Save the model to the current file in SketchUp 8 format
    # status = model.save("", Sketchup::Model::VERSION_8)
    # 
    # # Save the model in SketchUp 8 format
    # path = File.join(ENV['Home'], 'Desktop', 'mysketchup_v8.skp')
    # status = model.save(path, Sketchup::Model::VERSION_8)
    # ```
    # 
    # _@note_ — A bug in SketchUp 2016 and older caused the +.skb+ backup file
    # written during save to be empty. The +.skp+ file was however valid.
    def save: (*untyped args) -> bool

    # This method is used to save the copy of the current model to a file.
    # 
    # _@param_ `path` — The path of the file to save the model copy to.
    # 
    # _@param_ `version` — Optional SketchUp file format to use. If not provided, latest file format will be used. Possible values are: - Sketchup::Model::VERSION_3, - Sketchup::Model::VERSION_4, - Sketchup::Model::VERSION_5, - Sketchup::Model::VERSION_6, - Sketchup::Model::VERSION_7, - Sketchup::Model::VERSION_8, - Sketchup::Model::VERSION_2013, - Sketchup::Model::VERSION_2014, - Sketchup::Model::VERSION_2015, - Sketchup::Model::VERSION_2016, - Sketchup::Model::VERSION_2017, - Sketchup::Model::VERSION_2018, - Sketchup::Model::VERSION_2019, - Sketchup::Model::VERSION_2020, - Sketchup::Model::VERSION_2021
    # 
    # _@return_ — true if successful, false if unsuccessful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # # Save copy of the model using the current SketchUp format
    # path = File.join(ENV['Home'], 'Desktop', 'myModelCopy.skp')
    # status = model.save_copy(path)
    # 
    # # Save copy of the model in SketchUp 8 format
    # path = File.join(ENV['Home'], 'Desktop', 'mysketchupcopy_v8.skp')
    # status = model.save_copy(path, Sketchup::Model::VERSION_8)
    # ```
    def save_copy: (String path, Integer version) -> bool

    # The save_thumbnail method is used to save a thumbnail image to a file.
    # The image format is specified by the file extension of filename.  Supported
    # formats are bmp, jpg, png, tif, pct, and gif.
    # 
    # _@param_ `filename` — The name of the file, with extension, to save the thumbnail as.
    # 
    # _@return_ — true if successful, false if unsuccessful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # status = model.save_thumbnail('testthumbnail2.jpg')
    # ```
    def save_thumbnail: (String filename) -> bool

    # This method is used to select a SketchUp Tool object s the active tool. You
    # must implement the SketchUp Tool interface to create a tool prior to calling
    # this method.
    # 
    # The select tool is activated if you pass nil to the select_tool method. You
    # must implement the SketchUp Tool interface to create a tool, prior to calling
    # this method, and then instance the tool implementation and pass the object to
    # this method. If you attempt to set the select_tool to nil in the initialize
    # method of a tool you have written, it will be ignored.
    # 
    # _@param_ `tool` — The Tool object you want to select.
    # 
    # _@return_ — The Model object.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # tool = model.select_tool(nil)
    # ```
    def select_tool: (Object tool) -> Sketchup::Model

    # This method retrieves a Selection object for the model, containing the
    # currently selected entities. The entries in the selection list are not
    # necessarily in the same order in which the user selected them.
    # 
    # _@return_ — A Selection object with 0 or more entities
    # that are currently selected.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # selection = model.selection
    # ```
    def selection: () -> Sketchup::Selection

    # This method is used to set the value of an attribute in an attribute
    # dictionary with the given name.
    # 
    # This method can be used create a new AttributeDictionary object, if needed.
    # 
    # _@param_ `attrdictname` — The name of the attribute dictionary whose attribute you wish to set.
    # 
    # _@param_ `key` — The attribute name.
    # 
    # _@param_ `value` — The value to set.
    # 
    # _@return_ — the value that was set
    # 
    # ```ruby
    # model = Sketchup.active_model
    # value = model.set_attribute('attributedictionaryname', 'key', 'value')
    # ```
    def set_attribute: (String attrdictname, String key, Object value) -> Object

    # This method sets the datum used in conversions between the internal
    # coordinate system and UTM.
    # 
    # The default datum is WGS84. You can use the method list_datums to get a list
    # of all of the datums supported in SketchUp. If you pass an invalid datum to
    # set_datum, set_datum returns the default datum.
    # 
    # _@param_ `datum`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # value = model.set_datum('Adindan')
    # ```
    def set_datum: (String datum) -> void

    # This method is used to retrieve the shadow information for the Model.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # shadowinfo = model.shadow_info
    # ```
    def shadow_info: () -> Sketchup::ShadowInfo

    # The {#start_operation} method is used to notify SketchUp that a new
    # operation (which can be undone) is starting.
    # 
    # The +op_name+ argument is a description for the operation that is displayed
    # adjacent to the Edit > Undo menu item. Make sure to provide a user friendly
    # name for your operation.
    # 
    # Starting with SketchUp 7.0, there are three additional booleans that one can
    # pass in when starting an operation. It is recommended to always set
    # +disable_ui+ to +true+. It's left to +false+ for default for compatibility
    # reasons.
    # 
    # _@param_ `op_name` — name of the operation visible in the UI
    # 
    # _@param_ `disable_ui` — if set to true, then SketchUp's tendency to update the user interface after each geometry change will be suppressed. This can result in much faster Ruby code execution if the operation involves updating the model in any way.
    # 
    # _@param_ `next_transparent` — <b>Deprecated!</b> if set to true, then whatever operation comes after this one will be appended into one combined operation, allowing the user the undo both actions with a single undo command. This flag is a highly difficult one, since there are so many ways that a SketchUp user can interrupt a given operation with one of their own. <b>Use extreme caution</b> and test thoroughly when setting this to true.
    # 
    # _@param_ `transparent` — if set to true, then this operation will append to the previous operation. This is particularly useful for creating observers that react to user actions without littering the undo stack with extra steps that Ruby is performing.
    # 
    # _@return_ — +true+ if successful, +false+ if unsuccessful
    # 
    # Observer Operation since SU2016
    # ```ruby
    # class MyDefinitionsObserver < Sketchup::DefinitionObserver
    #   def onComponentAdded(definitions, definition)
    #     return if definition.deleted?
    #     # The operation name won't be displayed when the fourth argument is
    #     # +true+. It will absorb into the previous operation.
    #     definition.model.start_operation('Tag It', true, false, true)
    #     definition.set_attribute('MyExtension', 'Tag', 'You are it')
    #     definition.model.commit_operation
    #   end
    # end
    # 
    # observer = MyDefinitionsObserver.new
    # model = Sketchup.active_model
    # model.definitions.add_observer(observer)
    # ```
    # 
    # Typical Operation
    # ```ruby
    # model = Sketchup.active_model
    # model.start_operation('Generate House', true)
    # model.entities.add_line([0, 0, 0], [9, 0, 0])
    # model.entities.add_line([9, 0, 0], [9, 0, 9])
    # model.commit_operation
    # ```
    # 
    # _@note_ — Operations in SketchUp are sequential and cannot be nested. If you start a
    # new Ruby operation while another is still open, you will implicitly close
    # the first one.
    def start_operation: (
                           String op_name,
                           ?bool disable_ui,
                           ?bool next_transparent,
                           ?bool transparent
                         ) -> bool

    # The {#styles} method retrieves the styles associated with the model.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # styles = model.styles
    # ```
    def styles: () -> Sketchup::Styles

    # The tags method retrieves the string tags of the model.
    # 
    # _@return_ — string tags of the model
    # 
    # ```ruby
    # model = Sketchup.active_model
    # tags = model.tags
    # ```
    def tags: () -> String

    # The tags= method sets the string tags of the model.
    # 
    # _@param_ `tags` — new tags of the model
    # 
    # _@return_ — the new tags
    # 
    # ```ruby
    # Sketchup.active_model.tags = "Building, House, Brick"
    # ```
    def tags=: (String tags) -> String

    # The tile method retrieves the name of the model. If the model is saved on
    # disk, returns the file name without extension. Otherwise returns an empty
    # string.
    # 
    # _@return_ — the title of the model or an empty string (if
    # the title is not set)
    # 
    # ```ruby
    # model = Sketchup.active_model
    # title = model.title
    # ```
    def title: () -> String

    # The {#tools} method is used to retrieve the current {Sketchup::Tools} object.
    # 
    # _@return_ — a Tools object.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # tools = model.tools
    # ```
    def tools: () -> Sketchup::Tools

    # The utm_to_point method converts a position given in UTM coordinates to a
    # Point3d in the Model.
    # 
    # _@param_ `utm` — A UTM object.
    # 
    # _@return_ — A Point3d object.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # utm = Geom::UTM.new([+1, "A", 0.12333333, 0.12321321])
    # point = model.utm_to_point(utm)
    # ```
    def utm_to_point: (Geom::UTM utm) -> Geom::Point3d

    # Determine if a model is a valid Sketchup::Model object. Returns false
    # if the model has been closed.
    # 
    # This is useful on the mac where one can have multiple models open at the
    # same time. In such a case, this method can tell you if the user has closed
    # the model before you perform operations on it.
    # 
    # ```ruby
    # # This is a silly example since the active model is generally going to
    # # be valid, but it illustrates the idea.
    # model = Sketchup.active_model
    # if model.valid?
    #   UI.messagebox('This model is valid.')
    # else
    #   UI.messagebox('This model is NOT valid.')
    # end
    # ```
    def valid?: () -> bool
  end

  # The Pages class contains methods for manipulating a collection of Pages
  # (Named "scenes" in the UI.) in a model.
  # 
  # You get a handle to this collection by calling Model.pages.
  # 
  # @example
  #   model = Sketchup.active_model
  #   pages = model.pages
  # 
  # @version SketchUp 6.0
  class Pages < Sketchup::Entity
    include Enumerable[Sketchup::Page]
    ImageEmbedded: untyped
    ImageEmbeddedAndLinked: untyped
    ImageLinked: untyped
    UnitsNormalizedX: untyped
    UnitsNormalizedY: untyped
    UnitsPixels: untyped

    # sord duck - #frameChange looks like a duck type, replacing with untyped
    # The {.add_frame_change_observer} method is used to add a new frame change
    # observer that is called with each frame of an animation, meaning the
    # end user has clicked on a Scene tab (aka Page) inside SketchUp and
    # the camera is animating to that scene.
    # 
    # The method returns an integer id that can be stored and later used to remove
    # the observer with the {Sketchup::Pages.remove_frame_change_observer} method.
    # 
    # _@param_ `object` — An object that implements the {Sketchup::FrameChangeObserver#frameChange} method.
    # 
    # _@return_ — A unique id of the observer
    # 
    # ```ruby
    # class MyFrameChangeObserver
    #   def frameChange(from_page, to_page, percent_done)
    #     puts "From page #{from_page.name} to #{to_page.name} (#{percent_done * 100}%)"
    #   end
    # end
    # id = Sketchup::Pages.add_frame_change_observer(MyFrameChangeObserver.new)
    # ```
    # 
    # _@see_ `Sketchup::FrameChangeObserver#frameChange`
    def self.add_frame_change_observer: (untyped object) -> Integer

    # The {.remove_frame_change_observer} method is used to remove a frame change
    # observer
    # 
    # _@param_ `observer_id` — The unique id returned by {.add_frame_change_observer}
    # 
    # ```ruby
    # Sketchup::Pages.remove_frame_change_observer(id)
    # ```
    def self.remove_frame_change_observer: (Integer observer_id) -> bool

    # The [] method retrieves a page by either name or index.
    # 
    # _@param_ `index_or_name` — The index or the string name of the specific page.
    # 
    # _@return_ — page - a Page object if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # status = pages.add "Page 1"
    # status = pages.add "Page 2"
    # page = pages["Page 2"]
    # if (page)
    #   UI.messagebox page
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def []: (untyped index_or_name) -> untyped

    # The {#add} method is used to add a new Page object to the collection.
    # 
    # If no name is given, then a new name is generated using the default name for
    # new Pages. If a name is given, then a new Page with that name is
    # added.
    # 
    # If the flags parameter is given, it controls which properties are saved with
    # the Page. See the {Page#update} method for a description of the flags that
    # can be set.
    # 
    # If index is given, it specifies the position in the page list that the new
    # page is added.  Otherwise the new page is added to the end.
    # 
    # _@param_ `name` — The name of the specific page.
    # 
    # _@param_ `flags` — Bit flags in integer form.
    # 
    # _@param_ `index` — Index of where to inset.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # status = pages.add "Page 1"
    # status = pages.add "Page 2"
    # if (status)
    #   UI.messagebox status
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def add: (?String? name, ?Integer flags, ?Integer index) -> Sketchup::Page

    # The add_matchphoto_page method is used to add a photomatch page to the
    # model. This is an advanced feature that was added to support internal
    # SketchUp work, so it is unlikely to be useful to you.
    # 
    # _@param_ `image_name` — String image name.
    # 
    # _@param_ `camera` — Camera object.
    # 
    # _@param_ `page_name` — String page name.
    # 
    # _@return_ — page - the new photomatch page.
    # 
    # ```ruby
    # pages = Sketchup.active_model.pages
    # page = pages.add_matchphoto_page "Test"
    # ```
    def add_matchphoto_page: (untyped image_name, ?untyped camera, ?untyped page_name) -> untyped

    # The add_observer method is used to add an observer to the Pages object.
    # See the PagesObserver interface for more details.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # pages = Sketchup.active_model.pages
    # status = pages.add_observer observer
    # ```
    def add_observer: (untyped observer) -> untyped

    # ```ruby
    # pages = Sketchup.active_model.pages
    # pages.add('Page 1')
    # pages.add('Page 2')
    # number = pages.count
    # ```
    # 
    # _@note_ — Since SketchUp 2014 the count method is inherited from Ruby's
    # +Enumerable+ mix-in module. Prior to that the {#count} method is an alias
    # for {#length}.
    # 
    # _@see_ `#length`
    def count: () -> Integer

    # The each method is used to iterate through pages.
    # 
    # _@return_ — nil
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # status = pages.add "Page 1"
    # status = pages.add "Page 2"
    # pages.each {|page| puts page}
    # ```
    def each: () ?{ (Page) -> void } -> untyped

    # The {#erase} method is used to remove a page from the collection.
    # 
    # _@param_ `page`
    # 
    # ```ruby
    # page = Sketchup.active_model.pages.add('Hello World')
    # Sketchup.active_model.pages.erase(page)
    # ```
    def erase: (Sketchup::Page page) -> bool

    # The {#length} method is an alias for {#size}.
    # 
    # ```ruby
    # pages = Sketchup.active_model.pages
    # pages.add('Page 1')
    # pages.add('Page 2')
    # number = pages.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The parent method is used to determine the model for the Pages collection.
    # 
    # _@return_ — model - the model that contains the pages if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # status = pages.add "Page 1"
    # status = pages.add "Page 2"
    # model = pages.parent
    # ```
    def parent: () -> untyped

    # The remove_observer method is used to remove an observer from the current
    # object. See the PagesObserver interface for more details.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # pages = Sketchup.active_model.pages
    # status = pages.remove_observer observer
    # ```
    def remove_observer: (untyped observer) -> untyped

    # The selected_page method is used to retrieve the currently selected page.
    # 
    # _@return_ — page - the currently selected Page object if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # status = pages.add "Page 1"
    # status = pages.add "Page 2"
    # page = pages.selected_page
    # ```
    def selected_page: () -> untyped

    # The selected_page method is used to set the currently selected page. Once
    # you set this, SketchUp will animate to that page as if the user had clicked
    # on its scene tab.
    # 
    # _@param_ `page`
    # 
    # _@return_ — status - true if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # status = pages.add "Page 1"
    # status = pages.add "Page 2"
    # pages.selected_page = model.pages[1]
    # ```
    def selected_page=: (Sketchup::Page page) -> untyped

    # The {#show_frame_at} method is used to show a frame in animation (of the
    # slide show) at a given time in seconds.
    # 
    # _@param_ `seconds` — The time in seconds.
    # 
    # _@return_ — Upon success it returns the
    # page that is displayed and a parameter between +0.0+ and +1.0+ that is
    # tells how far along the transition to next page you are at.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # pages = model.pages
    # pages.add("Page 1")
    # pages.add("Page 2")
    # page, ratio = pages.show_frame_at(1.8)
    # ```
    # 
    # _@note_ — In versions prior to SketchUp 2019 this method will crash if called
    # when there are no pages in the model.
    def show_frame_at: (Float seconds) -> [Sketchup::Page, Float]?

    # The {#size} method is used to retrieve the number of pages.
    # 
    # ```ruby
    # pages = Sketchup.active_model.pages
    # pages.add('Page 1')
    # pages.add('Page 2')
    # number = pages.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer

    # The slideshow_time method is used to get the amount of time that a slideshow
    # of all of the pages will take. This takes into account the transition time
    # for each Page and the amount of time that each Page is displayed.
    # 
    # _@return_ — status - true if successful
    # 
    # ```ruby
    # pages = Sketchup.active_model.pages
    # time = pages.slideshow_time
    # ```
    def slideshow_time: () -> untyped
  end

  # The Style class contains methods for modifying information about a specific
  # style. Styles are a collection of display settings that tell SketchUp how to
  # draw the model.
  # 
  # @example
  #   styles = Sketchup.active_model.styles
  #   puts "Your first style is named #{styles.first.name}"
  # 
  # @version SketchUp 6.0
  class Style < Sketchup::Entity
    # The {#description} method gets the description for a {Sketchup::Style}.
    # 
    # _@return_ — description
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # style = styles.first
    # puts "Your first style description is: #{style.description}"
    # ```
    def description: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#description=} method sets the description for a {Sketchup::Style}.
    # 
    # _@param_ `description`
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # style = styles.first
    # style.description = "My new style description."
    # ```
    def description=: (String description) -> untyped

    # The {#name} method gets the name for a {Sketchup::Style}.
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # style = styles.first
    # name = style.name
    # ```
    def name: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#name=} method sets the name for a {Sketchup::Style}.
    # 
    # _@param_ `name`
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # style = styles.first
    # style.name = 'My Very Own Style'
    # ```
    def name=: (String name) -> untyped
  end

  # The Tools class contains methods to manipulate a collection of SketchUp
  # tools. You access this collection by calling the Model.tools method.
  # 
  # @example
  #   tools = Sketchup.active_model.tools
  # 
  # @version SketchUp 6.0
  class Tools
    # The {#active_tool} method is used to obtain the active Ruby tool.
    # 
    # _@return_ — Returns the active Ruby tool, or `nil` otherwise.
    # 
    # ```ruby
    # tools = Sketchup.active_model.tools
    # tool = tools.active_tool
    # ```
    def active_tool: () -> Object?

    # The active_tool_id method is used to retrieve the active tool's id.
    # 
    # _@return_ — id - the active tool's id.
    # 
    # ```ruby
    # tools = Sketchup.active_model.tools
    # id = tools.active_tool_id
    # ```
    def active_tool_id: () -> untyped

    # The active_tool_name method is used to retrieve the active tool's name.
    # 
    # _@return_ — name = the active tool's name.
    # 
    # ```ruby
    # tools = Sketchup.active_model.tools
    # if tools.active_tool_id.equal? 0
    #   puts "Tools collection is empty"
    # else
    #   name = tools.active_tool_name
    # end
    # ```
    def active_tool_name: () -> untyped

    # The add_observer method is used to add an observer to the current object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — status - true if successful, false if unsuccessful.
    # 
    # ```ruby
    # tools = Sketchup.active_model.tools
    # observer = Sketchup::ToolsObserver.new
    # status = tools.add_observer observer
    # ```
    def add_observer: (untyped observer) -> untyped

    # The model method is used to get the model associated with this tools object.
    # 
    # _@return_ — model - the Model object associated with this tools
    # collection.
    # 
    # ```ruby
    # tools = Sketchup.active_model.tools
    # model = tools.model
    # ```
    def model: () -> untyped

    # The pop_tool method is used to pop the last pushed tool on the tool stack.
    # 
    # _@return_ — the last pushed Tool object, if it is a Ruby tool. If a
    # native tool is active, selects the default native tool
    # and returns nil.
    # 
    # ```ruby
    # tools = Sketchup.active_model.tools
    # tool = tools.pop_tool
    # ```
    def pop_tool: () -> untyped

    # The push_tool method is used to push (aka activate) a user-defined tool.
    # See the Tool interface for details on creating your own SketchUp tool.
    # 
    # _@param_ `tool` — A user.
    # 
    # _@return_ — status - true if successful, false if unsuccessful.
    # 
    # ```ruby
    # tools = Sketchup.active_model.tools
    # status = tools.push_tool tool
    # ```
    def push_tool: (untyped tool) -> untyped

    # The remove_observer method is used to remove an observer from the current
    # object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # tools = Sketchup.active_model.tools
    # observer = Sketchup::ToolsObserver.new
    # tools.add_observer observer
    # status = tools.remove_observer observer
    # ```
    def remove_observer: (untyped observer) -> untyped
  end

  # The Camera class contains methods for creating and manipulating a camera.
  # The camera in SketchUp is the "point of view" from which you look at the
  # model.
  # 
  # @example
  #   # Create a camera from scratch with an "eye" position in
  #   # x, y, z coordinates, a "target" position that
  #   # defines what to look at, and an "up" vector.
  #   eye = [1000,1000,1000]
  #   target = [0,0,0]
  #   up = [0,0,1]
  #   my_camera = Sketchup::Camera.new eye, target, up
  # 
  #   # Get a handle to the current view and change its camera.
  #   view = Sketchup.active_model.active_view
  #   view.camera = my_camera
  # 
  # @version SketchUp 6.0
  class Camera
    # The {#aspect_ratio} method is used to retrieve the aspect ratio of the Camera.
    # 
    # `0.0` is the default value and denotes an aspect ratio matching that of the
    # View.
    # 
    # ```ruby
    # camera = Sketchup.active_model.active_view.camera
    # aspect_ratio = camera.aspect_ratio
    # ```
    def aspect_ratio: () -> Float

    # sord omit - no YARD return type given, using untyped
    # The {#aspect_ratio=} method is used to set the aspect ratio for a Camera.
    # Changing this value will cause SketchUp to show gray bars over the screen
    # to show the resulting view.
    # 
    # If you set the value to `0.0`, then the aspect ratio of the Camera will match
    # the aspect ratio of its View.
    # 
    # _@param_ `ratio`
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # camera.aspect_ratio = 1.85
    # ```
    def aspect_ratio=: (Float ratio) -> untyped

    # The {#center_2d} method returns a point with the x and y offset of the camera
    # when it's in two-point perspective or math photo mode. When the camera is
    # in two-point perspective and the user pans around, the x and y values will
    # change. These values are in normalized device coordinates, so for instance,
    # the range [-1.0, 1.0] spans the full width or height of the screen.
    # 
    # The z value is unused and it is always zero.
    # 
    # _@return_ — ]
    # 
    # ```ruby
    # Sketchup.active_model.active_view.camera.center_2d
    # ```
    def center_2d: () -> Geom::Point3d

    # The {#description} method is used to retrieve the description for a Camera.
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # description = camera.description
    # ```
    def description: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#description=} method is used to set the description for the Camera.
    # 
    # _@param_ `description`
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # description = camera.description = "35 mm Camera"
    # ```
    def description=: (String description) -> untyped

    # The {#direction} method is used to retrieve a Vector3d object in the
    # direction that the Camera is pointing.
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # direction = camera.direction
    # ```
    def direction: () -> Geom::Vector3d

    # The {#eye} method is used to retrieve the eye Point3d object for the Camera.
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # eye = camera.eye
    # ```
    def eye: () -> Geom::Point3d

    # sord omit - no YARD type given for "length", using untyped
    # The focal_length method is used to get the focal length in millimeters of
    # perspective Camera.
    # 
    # This value is computed on the fly based on the camera {#fov} value and
    # the camera {#image_width} value.
    # 
    # ```ruby
    # # Calculate focal length based on camera's current #image_width.
    # camera = Sketchup::Camera.new
    # focal_length = camera.focal_length
    # 
    # # If you want the 35 mm focal length equivalent, a common measurement of
    # # camera field of view, you can instead calculate it from the #fov angle.
    # camera = Sketchup.active_model.active_view.camera
    # focal_length_35_eqv = 36.0 / (2 * Math.tan(camera.fov.degrees / 2))
    # ```
    def focal_length: (untyped length) -> Float

    # sord omit - no YARD return type given, using untyped
    # The {#focal_length=} method allows you to set the field of view by specifying
    # a focal length in millimeters. Focal length must be between 1 and 3000,
    # inclusive.
    # 
    # The camera {#fov} value is set based on the provided +focal_length+ and
    # the current {#image_width} for the camera.
    # 
    # _@param_ `focal_length`
    # 
    # ```ruby
    # # Set field of view from focal length using camera's current #image_width.
    # camera = Sketchup.active_model.active_view.camera
    # camera.focal_length = 120
    # 
    # # If you instead want to set the 35 mm focal length equivalent, a common
    # # measurement of camera field of view, you can first convert it to an angle
    # # and use #fov=.
    # camera = Sketchup.active_model.active_view.camera
    # focal_length_35_eqv = 120
    # camera.fov = 2 * Math.atan(36.0 / (2 * focal_length_35_eqv)).radians
    # ```
    def focal_length=: (Float focal_length) -> untyped

    # The {#fov} method retrieves the field of view of the Camera.
    # 
    # This is only applicable to perspective cameras.
    # 
    # _@return_ — Field of view in degrees
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # fov = camera.fov
    # ```
    def fov: () -> Float

    # sord omit - no YARD return type given, using untyped
    # The {#fov=} method sets the field of view for a Camera. Field of view
    # must be between 1 and 120 degrees, inclusive.
    # 
    # This is only valid on a perspective camera.
    # 
    # _@param_ `fov` — Field of view in degrees
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # fov = camera.fov = 56.78
    # ```
    def fov=: (Numeric fov) -> untyped

    # The {#fov_is_height?} method indicates whether the field of view is
    # measured vertically, as opposed horizontally.
    # 
    # ```ruby
    # camera = Sketchup.active_model.active_view.camera
    # if camera.fov_is_height?
    #   fov_vertical = camera.fov
    #   # Compute the horizontal FOV.
    # else
    #   fov_horizontal = camera.fov
    #   # Compute the vertical FOV.
    # end
    # ```
    def fov_is_height?: () -> bool

    # The {#height} method retrieves the height of a Camera.
    # 
    # This is only valid if it is not a perspective camera.
    # 
    # _@return_ — height in inches.
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # camera.perspective = false
    # height = camera.height
    # ```
    def height: () -> Float

    # sord omit - no YARD return type given, using untyped
    # The {#height=} method is used to set the height for the Camera in inches.
    # 
    # This is only valid if it is not a perspective camera.
    # 
    # _@param_ `value`
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # camera.perspective = false
    # camera.height = 20
    # ```
    def height=: (Float value) -> untyped

    # The {#image_width} method returns the width of the image, as used to
    # calculate the {#focal_length}. This value has no effect on how the view
    # is displayed in SketchUp.
    # 
    # The default value, 0, is interpreted by SketchUp as 36 mm (the width of
    # traditional 35 mm film).
    # 
    # _@return_ — Width in mm.
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # width = camera.image_width
    # ```
    def image_width: () -> Float

    # sord omit - no YARD return type given, using untyped
    # The {#image_width=} method is used to set the width of the image, as used to
    # calculate the {#focal_length}. This value has no effect on how the view
    # is displayed in SketchUp.
    # 
    # The default value, 0, is interpreted by SketchUp as 36 mm (the width of
    # traditional 35 mm film).
    # 
    # _@param_ `image_width` — Width in mm.
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # camera.image_width = 1.0
    # focal_length = camera.focal_length
    # ```
    def image_width=: (Float image_width) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # Returns a new camera with eye (where the camera is) and targets (where the
    # camera is looking).
    # 
    # ```ruby
    # eye = Geom::Point3d.new(20, 5, 30)
    # target = Geom::Point3d.new(20, 60, 25)
    # up = Z_AXIS
    # camera = Sketchup::Camera.new(eye, target, up)
    # ```
    # 
    # Arbitrary camera
    # ```ruby
    # camera = Sketchup::Camera.new
    # ```
    def initialize: (*untyped args) -> void

    # The {#is_2d?} method indicates if the camera two-point perspective or match photo
    # mode.
    # 
    # ```ruby
    # Sketchup.active_model.active_view.camera.is_2d?
    # ```
    def is_2d?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#perspective=} method is used to set whether or not this is a
    # perspective camera or an orthographic camera.
    # 
    # _@param_ `perspective`
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # camera.perspective = false
    # ```
    def perspective=: (bool perspective) -> untyped

    # The {#perspective?} method is used to determine whether a camera is a
    # perspective or orthographic camera.
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # status = camera.perspective?
    # if (status)
    #   puts "Perspective"
    # else
    #   puts "Orthographic"
    # end
    # ```
    def perspective?: () -> bool

    # The {#scale_2d} method returns a float indicating the scaling factor of 2
    # point perspective cameras.
    # 
    # When the camera is in two-point perspective and the user uses the zoom tools,
    # this value will change. Zooming out will produce a value greater than 1.0.
    # 
    # _@return_ — float
    # 
    # ```ruby
    # Sketchup.active_model.active_view.camera.scale_2d
    # ```
    def scale_2d: () -> untyped

    # The {#set} method sets the camera orientation. You have to set the camera eye,
    # target and up parameters at the same time to make sure that you have a valid
    # camera definition.
    # 
    # _@param_ `eye` — See {#eye}.
    # 
    # _@param_ `target` — See {#target}.
    # 
    # _@param_ `up` — See {#up}.
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # eye = Geom::Point3d.new(20, 5, 30)
    # target = Geom::Point3d.new(20, 60, 25)
    # up = Z_AXIS
    # camera.set(eye, target, up)
    # ```
    def set: (Geom::Point3d eye, Geom::Point3d target, Geom::Point3d up) -> Sketchup::Camera

    # The {#target} method retrieves Point3d that the camera is pointing at.
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # target = camera.target
    # ```
    def target: () -> Geom::Point3d

    # The {#up} method is used to retrieve the up vector for the camera. This is
    #  the direction that the top of the camera is facing.
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # up = camera.up
    # ```
    def up: () -> Geom::Vector3d

    # The {#xaxis} method is used to retrieve the x axis of the camera coordinate
    # system.
    # 
    # This value is computed from the cross product between the camera direction
    # and the up vector.
    # 
    # _@return_ — ]
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # xaxis = camera.xaxis
    # ```
    def xaxis: () -> Geom::Vector3d

    # The {#yaxis} method retrieves the y axis of the camera coordinate system.
    # 
    # This value is computed to be perpendicular the camera x and z axes. It is
    # equivalent to the up direction, but is computed to make sure that it is
    # perpendicular to the direction.
    # 
    # _@return_ — ]
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # # 0.0, 1.0, 0.0
    # yaxis = camera.yaxis
    # ```
    def yaxis: () -> Geom::Vector3d

    # The {#zaxis} method retrieves the z axis of the camera coordinate system.
    # 
    # This value is computed. It is the same as Camera.direction
    # 
    # _@return_ — vector - a Vector3d object if successful
    # 
    # ```ruby
    # camera = Sketchup::Camera.new
    # # 0.0, 1.0, 0.0
    # v = camera.zaxis
    # if (v)
    #   UI.messagebox v.to_s
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def zaxis: () -> untyped
  end

  # This is the base class for all SketchUp entities. Entities are basically
  # anything that can be contained in a model, including Drawingelements
  # such as Edges, SectionPlanes, Groups, etc. and entities that relate to
  # those Drawingelements, such as Loops, Layers, etc.
  # 
  # Keep in mind that the methods below are available on all subclasses.
  # For example, an Edge's parent class is Drawingelement, and a
  # Drawingelement's parent class is Entity. Therefore an Edge has all of the
  # methods defined in Drawingelement and Entity.
  # 
  # The Object.is_a? method is the common way of determining what sort of Entity
  # you're dealing with.
  # 
  # @example
  #   # Count how many faces are in the current selection.
  #   selection = Sketchup.active_model.selection
  #   face_count = 0
  # 
  #   # Look at all of the entities in the selection.
  #   selection.each { |entity|
  #     if entity.is_a? Sketchup::Face
  #       face_count = face_count + 1
  #     end
  #   }
  # 
  #   UI.messagebox("There are " + face_count.to_s + " faces selected.")
  # 
  # @version SketchUp 6.0
  class Entity
    # The add_observer method is used to add an observer to the current object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # entity = Sketchup.active_model.entities[0]
    # if entity.valid?
    #   status = entity.add_observer observer
    # end
    # ```
    def add_observer: (Object observer) -> bool

    # The attribute_dictionaries method is used to retrieve the
    # AttributeDictionaries collection attached to the entity.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # 
    # # I just happen to know that the second and third entities in the
    # # entities objects are edges.
    # entity1 = entities[1]
    # status = entity1.set_attribute "testdictionary", "test", 115
    # attrdicts = entity1.attribute_dictionaries
    # ```
    # 
    # _@note_ — The return value may be either +nil+ or an empty
    # {Sketchup::AttributeDictionaries} collection if this entity has no
    # {Sketchup::AttributeDictionary}s.
    def attribute_dictionaries: () -> Sketchup::AttributeDictionaries?

    # The attribute_dictionary method is used to retrieve an attribute dictionary
    # with a given name that is attached to an Entity.
    # 
    # _@param_ `name` — The name of the attribute dictionary.
    # 
    # _@param_ `create` — boolean, if set to true then the attribute dictionary will be created if it does not exist.
    # 
    # _@return_ — - an AttributeDictionary object
    # if successful, or nil if there is no attribute dictionary
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # 
    # # I just happen to know that the second and third entities in the
    # # entities objects are edges.
    # entity1 = entities[1]
    # status = entity1.set_attribute "testdictionary", "test", 115
    # attrdict = entity1.attribute_dictionary "testdictionary"
    # ```
    def attribute_dictionary: (String name, ?bool create) -> Sketchup::AttributeDictionary?

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#delete_attribute} method is used to delete an attribute from an entity.
    # 
    # If only the dictionary_name is given, then it deletes the entire
    # AttributeDictionary. Otherwise, {#delete_attribute} deletes the attribute with
    # the given key from the given dictionary.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # 
    # # I just happen to know that the second and third entities in the
    # # entities objects are edges.
    # entity1 = entities[1]
    # status = entity1.set_attribute "testdictionary", "test", 115
    # status = entity1.delete_attribute "testdictionary"
    # ```
    # 
    # _@note_ — In SketchUp 2018, special attribute dictionaries have been added.
    # The name of these dictionaries are "SU_InstanceSet" and "SU_DefinitionSet".
    # The dictionaries cannot be deleted via ruby and an ArgumentError will be
    # raised. The key/value pairs in the dictionary can be deleted safely.
    def delete_attribute: (*untyped args) -> untyped

    # The deleted? method is used to determine if your entity is still valid (not
    # deleted by another script, for example.)
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # entity1 = entities[1]
    # status = entity1.deleted?
    # ```
    def deleted?: () -> bool

    # The entityID method is used to retrieve a unique ID assigned to an entity.
    # 
    # The entityID is not persistent between sessions.
    # 
    # _@return_ — the id for the Entity object
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # entity1 = entities[1]
    # id = entity1.entityID
    # ```
    def entityID: () -> Integer

    # The {#get_attribute} method is used to retrieve the value of an attribute in
    # the entity's attribute dictionary.
    # 
    # If the third parameter, +default_value+, is not passed and there is no
    # attribute that matches the given name, it returns +nil+.
    # 
    # If +default_value+ is provided and there is no matching attribute it returns
    # the given value. It does not create an attribute with that name though.
    # 
    # _@param_ `dict_name` — The name of an attribute dictionary.
    # 
    # _@param_ `key` — An attribute key.
    # 
    # _@param_ `default_value` — A default value to return if no attribute is found.
    # 
    # _@return_ — the retrieved value
    # 
    # ```ruby
    # # Add an entity to the model:
    # model = Sketchup.active_model
    # entities = model.active_entities
    # edge = entities.add_line([0, 0, 0], [9, 9, 9])
    # 
    # # Read an attribute value from the edge. In this case this will return the
    # # default value provided; 42.
    # value = edge.get_attribute("MyExtension", "MyProperty", 42)
    # ```
    def get_attribute: (String dict_name, String key, ?Object? default_value) -> Object

    # The to_s method is used to retrieve the string representation of the entity.
    # 
    # _@return_ — the string representation of the entity if
    # successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # 
    # # I just happen to know that the second and third entities in the
    # # entities objects are edges.
    # entity1 = entities[1]
    # st = entity1.to_s
    # ```
    def inspect: () -> String

    # The model method is used to retrieve the model for the entity.
    # 
    # _@return_ — the model that contains the Entity object
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # 
    # # I just happen to know that the second and third entities in the
    # # entities objects are edges.
    # entity1 = entities[1]
    # m = entity1.model
    # ```
    def model: () -> Sketchup::Model

    # The parent method is used to retrieve the parent of the entity.
    # 
    # The parent will be a ComponentDefinition, a Group, or a Model, whatever
    # the entity is contained within.
    # 
    # _@return_ — a Entity object
    # representing the parent of this entity
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # 
    # # I just happen to know that the second and third entities in the
    # # entities objects are edges.
    # entity1 = entities[1]
    # parent = entity1.parent
    # ```
    def parent: () -> (Sketchup::ComponentDefinition | Sketchup::Model)

    # The {#persistent_id} method is used to retrieve a unique persistent id
    # assigned to an entity.
    # 
    # The persistent id persistent between sessions.
    # 
    # [SketchUp 2020.1]
    #   - {Sketchup::ComponentDefinition}
    #   - {Sketchup::Material}
    #   - {Sketchup::Style}
    # [SketchUp 2020.0]
    #   - {Sketchup::Layer}
    #   - {Sketchup::LineStyle}
    # [SketchUp 2018]
    #   - {Sketchup::Page}
    # [SketchUp 2017]
    #   - {Sketchup::ComponentInstance}
    #   - {Sketchup::ConstructionLine}
    #   - {Sketchup::ConstructionPoint}
    #   - {Sketchup::Curve}
    #   - {Sketchup::Dimension}
    #   - {Sketchup::Edge}
    #   - {Sketchup::Face}
    #   - {Sketchup::Group}
    #   - {Sketchup::Image}
    #   - {Sketchup::SectionPlane}
    #   - {Sketchup::Text}
    #   - {Sketchup::Vertex}
    #   - Polyline3d entities exposed only as {Sketchup::Drawingelement} Use
    #     {#typename} to determine if a {Sketchup::Drawingelement} is
    #     a +"Polyline3d"+.
    # 
    # _@return_ — the id for the {Sketchup::Entity} object
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = [
    #   Geom::Point3d.new(0, 0, 0),
    #   Geom::Point3d.new(9, 0, 0),
    #   Geom::Point3d.new(9, 9, 0),
    #   Geom::Point3d.new(0, 9, 0),
    # ]
    # 
    # # Add the face to the entities in the model
    # group = entities.add_group
    # face = group.entities.add_face(pts)
    # pid = face.persistent_id
    # # Exploding the group will preserve the pid.
    # pid == face.persistent_id # Should return true
    # ```
    # 
    # _@note_ — Only a subset of entity types support PIDs. Refer to the table
    # below for which and when support was added. In general it is entities that
    # you can iterate over in a {Sketchup::Entities} collection.
    def persistent_id: () -> Integer

    # The remove_observer method is used to remove an observer from the current
    # object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # entity = Sketchup.active_model.entities[0]
    # if entity.valid?
    #   status = entity.remove_observer observer
    # end
    # ```
    def remove_observer: (Object observer) -> bool

    # The set attribute is used to set the value of an attribute in an attribute
    # dictionary with the given name.
    # 
    # This method will create a new AttributeDictionary if none exists.
    # 
    # Note, a bug prior to SketchUp 2015 would corrupt the model if the key is
    # an empty string. This also includes values that will evaluate to empty
    # strings, such as nil.
    # 
    # _@param_ `dict_name` — The name of an attribute dictionary.
    # 
    # _@param_ `key` — An attribute key.
    # 
    # _@param_ `value` — The value for the attribute.
    # 
    # _@return_ — the newly set value if successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # 
    # # I just happen to know that the second and third entities in the
    # # entities objects are edges.
    # entity1 = entities[1]
    # status = entity1.set_attribute "testdictionary", "test", 115
    # ```
    def set_attribute: (String dict_name, String key, Object value) -> Object

    # The to_s method is used to retrieve the string representation of the entity.
    # 
    # _@return_ — the string representation of the entity if
    # successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # 
    # # I just happen to know that the second and third entities in the
    # # entities objects are edges.
    # entity1 = entities[1]
    # st = entity1.to_s
    # ```
    def to_s: () -> String

    # The typename method retrieves the type of the entity, which will be a string
    # such as "Face", "Edge", or "Group".
    # 
    # _@return_ — the type of the entity
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # 
    # # I just happen to know that the second and third entities in the
    # # entities objects are edges.
    # entity1 = entities[1]
    # type = entity1.typename
    # ```
    # 
    # _@note_ — Prefer +is_a?+ over +typename+ when possible as it is faster.
    def typename: () -> String

    # The {#valid?} method is used to determine if your entity is still valid (not
    # deleted by another script, for example).
    # 
    # This method is functionally the inverse to the {#deleted?} method.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # entity1 = entities[1]
    # status = entity1.valid?
    # ```
    def valid?: () -> bool
  end

  # The Layers collection allows you to see and manage all of the layers in a
  # model. You get a pointer to the Layers object from within the Model.
  # 
  # @example
  #   model = Sketchup.active_model
  #   layers = model.layers
  # 
  # @note As of SketchUp 2020 "Layers" were renamed to "Tags" in the UI.
  #   The API retains the use of "Layer" for compatibility and is synonymous with
  #   "Tag".
  # 
  # @version SketchUp 6.0
  class Layers < Sketchup::Entity
    include Enumerable[Sketchup::Layer]

    # The {#[]} method is used to retrieve a layer by index or name.
    # 
    # _@param_ `index_or_name` — A number representing the layer's index in an array of Layer objects, or the name of the layer.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # new_layer = layers.add "test layer"
    # layer_by_number = layers[1]
    # layer_by_name = layers["test layer"]
    # ```
    # 
    # _@see_ `#at`
    def []: ((Integer | String) index_or_name) -> Sketchup::Layer?

    # The {#add} method is used to add a new layer.
    # 
    # If you give the name of a Layer that is already defined, it will return the
    # existing Layer rather than adding a new one.
    # 
    # _@param_ `layer_name` — The name of the added layer.
    # 
    # ```ruby
    # layers = Sketchup.active_model.layers
    # layer = layers.add("Test Layer")
    # ```
    def add: (String layer_name) -> Sketchup::Layer

    # sord omit - no YARD type given for "arg", using untyped
    # The {#add_folder} method adds or moves a layer folder.
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # folder = manager.add_folder('Doors')
    # ```
    # 
    # _@see_ `#count_layers`
    def add_folder: (untyped arg) -> Sketchup::LayerFolder

    # The {#add_observer} method is used to add an observer to the layers
    # collection.
    # 
    # _@param_ `observer`
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # layers = Sketchup.active_model.layers
    # status = layers.add_observer observer
    # ```
    def add_observer: (Sketchup::LayersObserver observer) -> bool

    # sord omit - no YARD type given for "index_or_name", using untyped
    # The {#at} method is an alias for {#[]}.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # new_layer = layers.add "test layer"
    # layer_by_number = layers.at(1)
    # layer_by_name = layers.at("test layer")
    # ```
    # 
    # _@see_ `#[]`
    def at: (untyped index_or_name) -> Sketchup::Layer?

    # _@return_ — integer - the number of layers in the collection
    # 
    # ```ruby
    # layers = Sketchup.active_model.layers
    # number = layers.count
    # ```
    # 
    # _@note_ — Since SketchUp 2014 the count method is inherited from Ruby's
    # +Enumerable+ mix-in module. Prior to that the {#count} method is an alias
    # for {#length}.
    # 
    # _@see_ `#length`
    def count: () -> untyped

    # The {#count_folders} method counts the number of folders which are direct
    # children of the layer manager.
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # folder = manager.add_folder('Doors')
    # num_folders = manager.count_folders
    # ```
    def count_folders: () -> Integer

    # The {#count_layers} method retrieves the number of layers not in a folder.
    # 
    # ```ruby
    # layers = Sketchup.active_model.layers
    # number = layers.count_layers
    # ```
    # 
    # _@see_ `#size`
    # 
    # _@see_ `#length`
    def count_layers: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#each} method is used to iterate through all of the layers in the model.
    # This include layers that are nested inside folders.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # layers.add("Test layer")
    # layers.each { | layer | puts layer.name }
    # ```
    # 
    # _@note_ — Don't remove content from this collection while iterating over it with
    # {#each}. This would change the size of the collection and cause elements to
    # be skipped as the indices change. Instead copy the current collection to an
    # array using +to_a+ and then use +each+ on the array, when removing content.
    def each: () ?{ (Sketchup::Layer layer) -> void } -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#each_folder} method is used to iterate through the folders that are
    # direct children to the layer manager.
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # folder = manager.add_folder('Doors')
    # folder = manager.add_folder('Windows')
    # manager.each_folder { |folder|
    #   puts folder.name
    # }
    # ```
    def each_folder: () ?{ (Sketchup::LayerFolder folder) -> void } -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#each_layer} method is used to iterate through the layers that are not
    # inside a layer folder.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # layers.add('Test layer')
    # layers.each_layer { | layer | puts layer.name }
    # ```
    def each_layer: () ?{ (Sketchup::Layer layer) -> void } -> untyped

    # The {#folders} method returns the folders of the layer manager.
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # manager.add_folder('Doors')
    # manager.add_folder('Windows')
    # folders = manager.folders
    # ```
    # 
    # _@note_ — This does not return all the folders in the model, only those that are
    # direct children of the layer manager.
    def folders: () -> ::Array[Sketchup::LayerFolder]

    # The {#layers} method retrieves the layers not in a folder.
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # layers = manager.layers
    # ```
    def layers: () -> ::Array[Sketchup::Layer]

    # The {#length} method retrieves the number of layers.
    # 
    # ```ruby
    # layers = Sketchup.active_model.layers
    # number = layers.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The {#purge_unused} method is used to remove unused layers.
    # 
    # _@return_ — Number of unused layers removed
    # 
    # ```ruby
    # layers = Sketchup.active_model.layers
    # num_layers_removed = layers.purge_unused
    # ```
    # 
    # _@see_ `#purge_unused_folders`
    def purge_unused: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#purge_unused_folders} method is used to remove all layer folder with
    # no children.
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # folder = manager.add_folder('Doors')
    # folder = manager.add_folder('Windows')
    # manager.purge_unused_folders
    # ```
    def purge_unused_folders: () ?{ (Sketchup::LayerFolder folder) -> void } -> untyped

    # Remove the given layer from the model, optionally removing the geometry.
    # 
    # _@param_ `layer`
    # 
    # _@param_ `remove_geometry` — If true, geometry in the removed layer will be removed as well. If false (which is the default), this geometry will be placed on Layer 0.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # # Remove layer by layer reference.
    # layer = Sketchup.active_model.layers.add("MyLayer")
    # Sketchup.active_model.layers.remove(layer)
    # 
    # # Remove layer by name.
    # Sketchup.active_model.layers.add("MyLayer")
    # Sketchup.active_model.layers.remove("MyLayer")
    # 
    # # Remove layer by index.
    # Sketchup.active_model.layers.remove(1)
    # 
    # # Remove layer and the entities on the layer.
    # edge = Sketchup.active_model.entities.add_line([0, 0, 0], [9, 9, 9])
    # edge.layer = Sketchup.active_model.layers.add("MyLayer")
    # Sketchup.active_model.layers.remove("MyLayer", true)
    # ```
    def remove: ((Sketchup::Layer | Integer | String) layer, ?bool remove_geometry) -> bool

    # The {#remove_folder} method removes the folder from the model. All children are
    # preserved, but moved up one level.
    # 
    # _@param_ `folder`
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # folder = manager.add_folder('Doors')
    # manager.remove_folder(folder)
    # ```
    def remove_folder: (Sketchup::LayerFolder folder) -> void

    # The {#remove_observer} method is used to remove an observer from the current
    # object.
    # 
    # _@param_ `observer`
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # layers = Sketchup.active_model.layers
    # status = layers.remove_observer observer
    # ```
    def remove_observer: (Sketchup::LayersObserver observer) -> bool

    # The {#size} method is an alias of {#length}.
    # 
    # ```ruby
    # layers = Sketchup.active_model.layers
    # number = layers.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#unique_name} method can be used to get a string that will be a unique
    # layer name inside this collection.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # # Will return "Joe" since there are probably no other layers named that.
    # # Or might return something like "Joe #2" if there is already a layer
    # # named Joe.
    # good_name = layers.unique_name("Joe")
    # ```
    def unique_name: (*untyped args) -> untyped
  end

  # The Styles class contains methods for manipulating a collection of styles in
  # a model. Typically, you will access this via the active_model:
  # 
  # @example
  #   styles = Sketchup.active_model.styles
  #   puts "There are #{styles.size} styles in your model."
  # 
  # @version SketchUp 6.0
  class Styles < Sketchup::Entity
    include Enumerable[Style]

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#[]} method is used to retrieves a style by either name or index.
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # style1 = styles[0]
    # style2 = styles["MyStyle"]
    # ```
    def []: (untyped arg) -> untyped

    # The {#active_style} method is used to retrieve the active style.
    # 
    # While {#selected_style} is the style being selected in the Style Browser,
    # the #{active_style} is a different object also including any unsaved style
    # changes. These changes are silently dropped once a new style is selected.
    # To save these changes to the selected style, call #{update_selected_style}.
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # style = styles.active_style
    # ```
    def active_style: () -> Sketchup::Style

    # The {#active_style_changed} method tells you if the active style has been
    # edited by the user since it was last saved.
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # style_changed = styles.active_style_changed
    # ```
    def active_style_changed: () -> bool

    # The {#add_style} method is used to create and load a style from the given
    # file.
    # 
    # _@param_ `filename`
    # 
    # _@param_ `select` — +true+ if you want to set the style to be the active style.
    # 
    # ```ruby
    # filename = File.expand_path('./MyStyle.style')
    # styles = Sketchup.active_model.styles
    # status = styles.add_style(filename, true)
    # ```
    def add_style: (String filename, bool select) -> bool

    # ```ruby
    # styles = Sketchup.active_model.styles
    # number = styles.count
    # ```
    # 
    # _@note_ — Since SketchUp 2014 the count method is inherited from Ruby's
    # +Enumerable+ mix-in module. Prior to that the {#count} method is an alias
    # for {#length}.
    def count: () -> Integer

    # The {#each} method is used to iterate through styles.
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # styles.each { |style|
    #   puts style.name
    # }
    # ```
    def each: () ?{ (Sketchup::Style style) -> void } -> void

    # The {#length} method is an alias of {#size}.
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # number = styles.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The {#parent} method is used to return the model for the styles.
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # model = styles.parent
    # ```
    def parent: () -> Sketchup::Model

    # The {#purge_unused} method is used to remove unused styles from the model.
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # styles.purge_unused
    # ```
    def purge_unused: () -> bool

    # The {#selected_style} method is used to retrieve the style currently
    # selected in the Styles Browser.
    # 
    # _@return_ — style
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # style = styles.selected_style
    # ```
    def selected_style: () -> Sketchup::Style

    # The {#selected_style=} method is used to set the currently selected style.
    # 
    # _@param_ `style`
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # styles.selected_style = styles.last
    # ```
    def selected_style=: (Sketchup::Style style) -> bool

    # The {#size} method is used to retrieve the number of styles in the
    # collection.
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # number = styles.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer

    # The {#update_selected_style} method commits the current style settings to the
    # style selected in the Style Browser.
    # 
    # ```ruby
    # styles = Sketchup.active_model.styles
    # styles.update_selected_style
    # ```
    # 
    # _@see_ `#selected_style`
    def update_selected_style: () -> bool
  end

  # A Vertex. A Vertex represents the end of an Edge or a point inside a Face.
  # 
  # @version SketchUp 6.0
  class Vertex < Sketchup::Entity
    # The common_edge method is used to find a common edge that is defined by this
    # vertex and another vertex
    # 
    # _@param_ `vertex2` — A Vertex object.
    # 
    # _@return_ — an Edge object common to both vertices if
    # successful. Returns nil if there is no edge between the
    # two vertices.
    # 
    # ```ruby
    # edge = entities[0]
    # # returns array of vertices that make up the line
    # verticies = edge.vertices
    # vertex1 = verticies[0]
    # vertex2 = verticies[1]
    # edge = vertex1.common_edge vertex2
    # if (edge)
    #   UI.messagebox edge
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def common_edge: (Sketchup::Vertex vertex2) -> Sketchup::Edge?

    # The {#curve_interior?} method is used to determine if this vertex is on the
    # interior of a Curve.
    # 
    # ```ruby
    # edge = entities[0]
    # # returns array of vertices that make up the line
    # verticies = edge.vertices
    # vertex1 = verticies[0]
    # status = vertex1.curve_interior?
    # if (status)
    #   UI.messagebox status
    # else
    #   #returns nil if vertex is not on interior of a Curve
    #   UI.messagebox "Failure"
    # end
    # ```
    # 
    # _@note_ — This method doesn't actually return a boolean as the question mark
    # post-fix would normally indicate. But the result still evaluates to
    # truthy or falsy.
    def curve_interior?: () -> bool

    # The edges method is used to retrieve an Array of edges that use the Vertex.
    # 
    # _@return_ — an Array of edge objects if successful
    # 
    # ```ruby
    # edge = entities[0]
    # # Returns array of vertices that make up the line.
    # verticies = edge.vertices
    # vertex1 = verticies[0]
    # edges = vertex1.edges
    # ```
    def edges: () -> ::Array[Sketchup::Edge]

    # The faces method is used to retrieve an Array of faces that use the vertex.
    # 
    # _@return_ — an Array of faces that use the vertex if
    # successful
    # 
    # ```ruby
    # edge = entities[0]
    # # Returns array of vertices that make up the line.
    # verticies = edge.vertices
    # vertex1 = verticies[0]
    # faces = vertex1.faces
    # ```
    def faces: () -> ::Array[Sketchup::Face]

    # The loops method is used to retrieve an Array of loops that use the vertex.
    # 
    # _@return_ — an Array of loops that use the vertex if
    # successful
    # 
    # ```ruby
    # edge = entities[0]
    # # Returns array of vertices that make up the line.
    # verticies = edge.vertices
    # vertex1 = verticies[0]
    # loops = vertex1.loops
    # ```
    def loops: () -> ::Array[Sketchup::Loop]

    # The position method is used to retrieve the Point3d position of a vertex.
    # 
    # _@return_ — a Point3d object representing the position of
    # the vertex if successful
    # 
    # ```ruby
    # edge = entities[0]
    # # Returns array of vertices that make up the line.
    # verticies = edge.vertices
    # vertex1 = verticies[0]
    # position = vertex1.position
    # ```
    def position: () -> Geom::Point3d

    # The used_by? method is used to determine if the Vertex is used by a given
    # Edge or Face.
    # 
    # _@param_ `face_or_edge` — A Face or Edge ot test against.
    # 
    # ```ruby
    # used = vertex1.used_by? my_face
    # ```
    def used_by?: ((Sketchup::Edge | Sketchup::Face) face_or_edge) -> bool
  end

  # The Console class is used by SketchUp to direct $stdout and $stderr to the
  # Ruby Console. It is a singleton class that only has one instance available.
  # This instance is accessible via the SKETCHUP_CONSOLE constant.
  # 
  # In SketchUp 2014 methods were added to allow developers to control the
  # visibility of the Ruby Console.
  # 
  # Also note that in SketchUp 2014, writing to the console does not work from
  # within Ruby threads other than the main thread. So the following code will
  # not produce any output.
  # 
  # @example
  #   # By default $stdout is directed to SKETCHUP_CONSOLE.
  #   p $stdout
  # 
  #   # $stdout can however be redirected so the safe way to access the
  #   # SketchUp console is by using the SKETCHUP_CONSOLE constant.
  #   p SKETCHUP_CONSOLE
  # 
  # @example
  #   t = Thread.new { puts 'This will not be written to the console.' }
  #   t.join
  # 
  # @version SketchUp 2014
  class Console
    # Clears the contents of SketchUp's Ruby Console.
    # 
    # _@return_ — true.
    # 
    # ```ruby
    # SKETCHUP_CONSOLE.clear
    # ```
    def clear: () -> untyped

    # Hides the SketchUp Ruby Console.
    # 
    # _@return_ — true.
    # 
    # ```ruby
    # SKETCHUP_CONSOLE.hide
    # ```
    def hide: () -> untyped

    # Displays the SketchUp Ruby Console.
    # 
    # _@return_ — true.
    # 
    # ```ruby
    # SKETCHUP_CONSOLE.show
    # ```
    def show: () -> untyped

    # Returns the visibility state of the SketchUp Ruby Console.
    # 
    # _@return_ — true if visible, false if not.
    # 
    # ```ruby
    # puts SKETCHUP_CONSOLE.visible?
    # ```
    def visible?: () -> bool
  end

  # The EdgeUse class defines how an Edge is used in the definition of a Face.
  # 
  # @version SketchUp 6.0
  class EdgeUse < Sketchup::Entity
    # The edge method is used to retrieve the edge for the edge use.
    # 
    # _@return_ — edge - an Edge object used by this edge use
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points = []
    # points << Geom::Point3d.new(0, 0, 0)
    # points << Geom::Point3d.new(100, 0, 0)
    # points << Geom::Point3d.new(100, 200, 0)
    # points << Geom::Point3d.new(0, 200, 0)
    # face = entities.add_face(points)
    # loop = face.outer_loop
    # edgeuses = loop.edgeuses
    # edgeuse = edgeuses[0]
    # edge = edgeuse.edge
    # ```
    def edge: () -> untyped

    # The end_vertex_normal method is used to retrieve the vertex normal for the
    # end point of this edgeuse.
    # 
    # _@return_ — vector3d - a vector3d object if successful.
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points = []
    # points << Geom::Point3d.new(0, 0, 0)
    # points << Geom::Point3d.new(100, 0, 0)
    # points << Geom::Point3d.new(100, 200, 0)
    # points << Geom::Point3d.new(0, 200, 0)
    # face = entities.add_face(points)
    # loop = face.outer_loop
    # edgeuses = loop.edgeuses
    # edgeuse = edgeuses[0]
    # vector3d = edgeuse.end_vertex_normal
    # ```
    def end_vertex_normal: () -> untyped

    # The face method is used to retrieve the face used by this edge use.
    # 
    # _@return_ — face - a Face object used by this edge use
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points = []
    # points << Geom::Point3d.new(0, 0, 0)
    # points << Geom::Point3d.new(100, 0, 0)
    # points << Geom::Point3d.new(100, 200, 0)
    # points << Geom::Point3d.new(0, 200, 0)
    # face = entities.add_face(points)
    # loop = face.outer_loop
    # edgeuses = loop.edgeuses
    # edgeuse = edgeuses[0]
    # face = edgeuse.face
    # ```
    def face: () -> untyped

    # The loop method is used to retrieve the loop for this edge use.
    # 
    # _@return_ — loop - a Loop object that contains this edge use.
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points = []
    # points << Geom::Point3d.new(0, 0, 0)
    # points << Geom::Point3d.new(100, 0, 0)
    # points << Geom::Point3d.new(100, 200, 0)
    # points << Geom::Point3d.new(0, 200, 0)
    # face = entities.add_face(points)
    # loop = face.outer_loop
    # edgeuses = loop.edgeuses
    # edgeuse = edgeuses[0]
    # loop = edgeuse.loop
    # ```
    def loop: () -> untyped

    # The next method is used to retrieve the next edge use in a loop.
    # 
    # _@return_ — edgeuse - the next EdgeUse object in a loop
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points = []
    # points << Geom::Point3d.new(0, 0, 0)
    # points << Geom::Point3d.new(100, 0, 0)
    # points << Geom::Point3d.new(100, 200, 0)
    # points << Geom::Point3d.new(0, 200, 0)
    # face = entities.add_face(points)
    # loop = face.outer_loop
    # edgeuses = loop.edgeuses
    # edgeuse = edgeuses[0]
    # next_edgeuse = edgeuse.next
    # ```
    def next: () -> untyped

    # The partners method is used to retrieve all of the partner edge uses that
    # uses the same edge.
    # 
    # _@return_ — array - an array of partner Edge Use objects.
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points1 = []
    # points1 << Geom::Point3d.new(0, 0, 0)
    # points1 << Geom::Point3d.new(100, 0, 0)
    # points1 << Geom::Point3d.new(100, 200, 0)
    # points1 << Geom::Point3d.new(0, 200, 0)
    # face1 = entities.add_face(points1)
    # points2 = []
    # points2 << Geom::Point3d.new(100, 0, 0)
    # points2 << Geom::Point3d.new(200, 0, 0)
    # points2 << Geom::Point3d.new(200, 200, 0)
    # points2 << Geom::Point3d.new(100, 200, 0)
    # face2 = entities.add_face(points2)
    # loop = face1.outer_loop
    # edgeuses = loop.edgeuses
    # edgeuse = edgeuses[1]
    # partners = edgeuse.partners
    # ```
    def partners: () -> untyped

    # The previous method is used to retrieve the previous edge use in a loop.
    # 
    # _@return_ — edgeuse - the previous Edge Use object in the loop
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points = []
    # points << Geom::Point3d.new(0, 0, 0)
    # points << Geom::Point3d.new(100, 0, 0)
    # points << Geom::Point3d.new(100, 200, 0)
    # points << Geom::Point3d.new(0, 200, 0)
    # face = entities.add_face(points)
    # loop = face.outer_loop
    # edgeuses = loop.edgeuses
    # edgeuse = edgeuses[0]
    # previous_edgeuse = edgeuse.previous
    # ```
    def previous: () -> untyped

    # The reversed? method is used to determine if the edge direction is opposite
    # of the edge use direction. The edge use direction is the same as the loop
    # it belongs to.
    # 
    # _@return_ — boolean - true if reversed, false if not reversed.
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points = []
    # points << Geom::Point3d.new(0, 0, 0)
    # points << Geom::Point3d.new(100, 0, 0)
    # points << Geom::Point3d.new(100, 200, 0)
    # points << Geom::Point3d.new(0, 200, 0)
    # face = entities.add_face(points)
    # loop = face.outer_loop
    # edgeuses = loop.edgeuses
    # edgeuse = edgeuses[0]
    # reversed = edgeuse.reversed?
    # ```
    def reversed?: () -> bool

    # The start_vertex_normal method is used to retrieve the vertex normal for
    # the start point of this edgeuse.
    # 
    # _@return_ — vector3d - a vector3d object if successful.
    # 
    # ```ruby
    # entities = Sketchup.active_model.active_entities
    # points = []
    # points << Geom::Point3d.new(0, 0, 0)
    # points << Geom::Point3d.new(100, 0, 0)
    # points << Geom::Point3d.new(100, 200, 0)
    # points << Geom::Point3d.new(0, 200, 0)
    # face = entities.add_face(points)
    # loop = face.outer_loop
    # edgeuses = loop.edgeuses
    # edgeuse = edgeuses[0]
    # vector3d = edgeuse.start_vertex_normal
    # ```
    def start_vertex_normal: () -> untyped
  end

  # The Texture class contains methods for obtaining information about textures
  # that are part of your materials in your model (within the In-Model section
  # of the Materials Browser). Remember, textures are repeatable images that
  # "tile" when painted on a surface.
  # 
  # @version SketchUp 6.0
  class Texture < Sketchup::Entity
    # The average_color method retrieves a color object with the average color
    # found in the texture.
    # 
    # _@return_ — a color object (if successful), nil if
    # unsuccessful.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials=model.materials
    # # Adds a material as an in model material
    # m = materials.add "Test Color"
    # begin
    #   # Returns nil if not successful, path if successful
    #   m.texture = "c:\\Materials\\Carpet.jpg"
    # rescue
    #   UI.messagebox $!.message
    # end
    # texture = m.texture
    # # Returns a color object
    # color = texture.average_color
    # if (color)
    #   UI.messagebox color
    # else
    #   UI.messagebox "Failure: No average color"
    # end
    # ```
    def average_color: () -> Sketchup::Color?

    # The {#filename} method retrieves the entire path, including the file, for a
    # texture object.
    # 
    # _@return_ — a string representation of the path and
    # filename used for the texture.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # material = materials.add("Test Color")
    # material.texture = "c:\\Materials\\Carpet.jpg"
    # texture = material.texture
    # filename = texture.filename
    # ```
    # 
    # _@note_ — Since SketchUp 2021.0 this method will append a file extension matching
    # the image format if the file extension is missing from stored filepath.
    def filename: () -> String

    # The height method is used to get the height of a repeatable texture image,
    # in inches.
    # 
    # _@return_ — the height, in inches, of the texture pattern
    # 
    # ```ruby
    # height = texture.height
    # ```
    def height: () -> Integer

    # The image_height method retrieves the height of the repeatable texture
    # image, in pixels.
    # 
    # _@return_ — the height, in pixels, of the texture
    # pattern
    # 
    # ```ruby
    # imageheight = texture.image_height
    # if (imageheight)
    #   UI.messagebox imageheight
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def image_height: () -> Integer

    # The {#image_rep} method returns a copy of a {Sketchup::ImageRep} object
    # representing the texture pixel data.
    # 
    # _@param_ `colorized` — Set to +true+ to obtain the colorized version.
    # 
    # ```ruby
    # texture = Sketchup.active_model.materials[0].texture
    # image_rep = texture.image_rep
    # ```
    def image_rep: (?bool colorized) -> Sketchup::ImageRep

    # The image_width method retrieves the width of the repeatable texture image,
    # in pixels.
    # 
    # _@return_ — the width, in pixels, of the texture
    # pattern
    # 
    # ```ruby
    # imagewidth = texture.image_width
    # if (imagewidth)
    #   UI.messagebox imagewidth
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def image_width: () -> Integer

    # The size= method allows you to set the size of the repeatable texture image,
    # in inches,
    # 
    # _@param_ `size` — The size, in inches, of the texture. This number will apply to height and width to keep aspect ratio. You can also pass as a parameter an array of two numeric values which will set width and height regardless of maintaining the height/width ratio.
    # 
    # _@return_ — the size, in inches, of the texture. This number
    # will apply to height and width to keep aspect ratio.
    # If you have passed in an array of two numbers for width
    # and height, the same array will be returned if
    # successful.
    # 
    # ```ruby
    # size = texture.size = 60
    # imagewidth = texture.width
    # 
    # if (imagewidth)
    #   UI.messagebox imagewidth
    # else
    #   UI.messagebox "Failure"
    # end
    # 
    # # Using two values which will not preserve ratio
    # width_height = texture.size = [10,100]
    # if (width_height)
    #   UI.messagebox width_height
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def size=: ((Integer | [Integer, Integer]) size) -> (Integer | [Integer, Integer])

    # The valid? method ensures that a texture is valid.
    # 
    # ```ruby
    # status = texture.valid?
    # if (status)
    #   UI.messagebox status
    # else
    #   UI.messagebox status
    # end
    # ```
    def valid?: () -> bool

    # The width method is used to get the width of a repeatable texture image,
    # in inches.
    # 
    # _@return_ — the width, in inches, of the texture pattern
    # 
    # ```ruby
    # width = texture.width
    # ```
    def width: () -> Integer

    # Writes the texture to file with option to preserve the color adjustments made
    # by the material.
    # 
    # _@param_ `path` — The file path to write the texture to.
    # 
    # _@param_ `colorize` — Boolean - Allows for the texture to be exported with the color adjustments.
    # 
    # _@return_ — true if the method succeeded
    # 
    # ```ruby
    # material = Sketchup.active_model.materials[0]
    # basename = File.basename(material.texture.filename)
    # path = File.join(Sketchup.temp_dir, basename)
    # material.texture.write(path)
    # ```
    def write: (String path, ?bool colorize) -> bool
  end

  # An ArcCurve is a Curve that makes up part of a circle. This is the
  # underlying class for circles as well.
  # 
  # You can think of ArcCurves as entities that were created with SketchUp's
  # Arc or Circle drawing tools and Curves as entities that were created with
  # the Freehand drawing tool.
  # 
  # However, keep in mind that all Curves in SketchUp are really edges with
  # some extra data attached to them. When you use the API to draw a Curve or
  # ArcCurve, you are really drawing edges.
  # 
  # ArcCurve is a subclass of Curve, so all of the methods that are available
  # to Curves are also available to ArcCurves.
  # 
  # @example
  #   # Draw a circle on the ground plane around the origin.
  #   center_point = Geom::Point3d.new(0,0,0)
  #   normal_vector = Geom::Vector3d.new(0,0,1)
  #   radius = 10
  # 
  #   entities = Sketchup.active_model.entities
  #   edgearray = entities.add_circle center_point, normal_vector, radius
  #   first_edge = edgearray[0]
  #   arccurve = first_edge.curve
  # 
  # @version SketchUp 6.0
  class ArcCurve < Sketchup::Curve
    # The center method is used to retrieve the Point3d that is at the center of
    # the circular arc.
    # 
    # _@return_ — point - a Point3d at the center of the arc if
    # successful
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.entities
    # edgearray = entities.add_circle centerpoint, vector2, 10
    # edge = edgearray[0]
    # arccurve = edge.curve
    # point = arccurve.center
    # ```
    def center: () -> untyped

    # The {#end_angle} method is used to retrieve the angle of the end of the arc
    # measured from the X axis in radians.
    # 
    # ```ruby
    # # Create a 1/2 circle, normal to the Z axis
    # start_a = 0.0
    # end_a = 180.degrees
    # model = Sketchup.active_model
    # entities = model.entities
    # edges = entities.add_arc(ORIGIN, X_AXIS, Z_AXIS, 5, start_a, end_a)
    # arc_curve = edges.first.curve
    # end_angle = arc_curve.end_angle
    # ```
    # 
    # _@note_ — A bug in SketchUp 2017 and older will report the end-angle for some
    # circles as more than 360 degrees. In such case, subtract +2 * PI+ from
    # the end angle value.
    def end_angle: () -> Float

    # The normal method retrieves a Vector3d that is perpendicular to the plane of
    # the arc.
    # 
    # _@return_ — vector - a Vector3d object if successful
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.entities
    # edgearray = entities.add_circle centerpoint, vector2, 10
    # edge = edgearray[0]
    # arccurve = edge.curve
    # v = arccurve.normal
    # ```
    def normal: () -> untyped

    # The plane method is used to retrieve the plane of the arc.
    # 
    # Refer to the Geom module for instructions to create a plane.
    # 
    # _@return_ — plane - the plane of the arc if successful
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.entities
    # edgearray = entities.add_circle centerpoint, vector2, 10
    # edge = edgearray[0]
    # arccurve = edge.curve
    # plane = arccurve.plane
    # ```
    def plane: () -> untyped

    # The radius method is used to retrieve the radius of the arc.
    # 
    # _@return_ — radius - the radius of the arc if successful
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.entities
    # edgearray = entities.add_circle centerpoint, vector2, 10
    # edge = edgearray[0]
    # arccurve = edge.curve
    # radius = arccurve.radius
    # ```
    def radius: () -> untyped

    # The start_angle method is used to retrieve the angle of the start of the
    # arc, measured from the X axis in radians.
    # 
    # _@return_ — angle - the angle of the start of the arc if successful
    # 
    # ```ruby
    # # Create a 1/4 circle, radius of 5, normal to the Z axis
    # center = Geom::Point3d.new 0, 0, -1
    # normal = Geom::Vector3d.new 0,0,1
    # xaxis = Geom::Vector3d.new 1,0,0
    # start_a = Math::PI/2
    # end_a = Math::PI
    # model = Sketchup.active_model
    # entities = model.entities
    # edgearray = entities.add_arc center, xaxis, normal, 5, start_a, end_a
    # edge = edgearray[0]
    # arccurve = edge.curve
    # start_angle = arccurve.start_angle
    # ```
    def start_angle: () -> untyped

    # The xaxis method is used to retrieve the X axis of the coordinate system for
    # the curve. Note that the length of the returned vector is equal to the radius
    # of the underlying curve.
    # 
    # _@return_ — vector - a Vector3d object if successful
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.entities
    # edgearray = entities.add_circle centerpoint, vector2, 10
    # edge = edgearray[0]
    # arccurve = edge.curve
    # v = arccurve.xaxis
    # ```
    def xaxis: () -> untyped

    # The yaxis method is used to retrieve the Y axis of the coordinate system for
    # the curve. Note that the length of the returned vector is equal to the radius
    # of the underlying curve.
    # 
    # _@return_ — vector - a Vector3d object if successful
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.entities
    # edgearray = entities.add_circle centerpoint, vector2, 10
    # edge = edgearray[0]
    # arccurve = edge.curve
    # v = arccurve.yaxis
    # ```
    def yaxis: () -> untyped
  end

  # The Behavior class is used to control the "behavior" of components, which
  # roughly correlates to the series of options that you see in the
  # Components dialog under the "edit" tab, such as whether it casts shadows,
  # glues to walls, etc.
  # 
  # A Behavior object is accessed from a ComponentDefinition object, not created
  # with a Behavior.new call.
  # 
  # @example
  #   # Grab the Behavior object from the first component definition.
  #   model = Sketchup.active_model
  #   definition = model.definitions[0]
  #   behavior = definition.behavior
  # 
  # @version SketchUp 6.0
  class Behavior < Sketchup::Entity
    # The always_face_camera= method is used to set the always_face_camera
    # behavior for a component.
    # 
    # If the always_face_camera behavior is true, a component will always try to
    # orient itself so that the Y axis of the component is facing the camera.
    # 
    # _@param_ `setting` — Sets the always_face_camera behavior to true or false.
    # 
    # _@return_ — status - the status of the always_face_camera behavior.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # behavior = model.definitions[0].behavior
    # status = behavior.always_face_camera = false
    # ```
    def always_face_camera=: (untyped setting) -> untyped

    # The always_face_camera? method is used to retrieve the  always_face_camera
    # behavior for a component.
    # 
    # If the always_face_camera behavior is true, then a component will always try
    # to orient itself so that the -Y axis of the component is facing the camera.
    # 
    # _@return_ — behavior - true if the component is set to always face
    # the camera, false if the component is not set to always
    # face camera.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # # Returns a DefinitionList
    # definitions = model.definitions
    # path = Sketchup.find_support_file "Bed.skp",
    #   "Components/Components Sampler/"
    # 
    # begin
    #   definition = definitions.load path
    # rescue
    #   UI.messagebox $!.message
    # end
    # 
    # behavior = definition.behavior
    # b = behavior.always_face_camera?
    # if (b)
    #   UI.messagebox b
    # else
    #   UI.messagebox "Always Face Camera is equal to false"
    # end
    # status = behavior.always_face_camera = true
    # b = behavior.always_face_camera?
    # if (b)
    #   UI.messagebox b
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def always_face_camera?: () -> bool

    # The cuts_opening= method is used to set the cut opening behavior for a
    # component.
    # 
    # _@param_ `setting` — Sets the cuts_opening behavior to true or false.
    # 
    # _@return_ — status - the status of the cuts_opening behavior
    # (either true or false)
    # 
    # ```ruby
    # model = Sketchup.active_model
    # behavior = model.definitions[0].behavior
    # behavior.cuts_opening = false
    # ```
    # 
    # _@note_ — To enable cut opening, also set {#is2d=} to true.
    def cuts_opening=: (untyped setting) -> untyped

    # The cuts_opening? method is used to get the status of a component's cut
    # opening behavior.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # behavior = model.definitions[0].behavior
    # status = behavior.cuts_opening?
    # ```
    def cuts_opening?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#is2d=} method is used to set whether the component can glue to other
    # entities or not.
    # 
    # _@param_ `is2d`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # behavior = model.definitions[0].behavior
    # behavior.is2d = false
    # ```
    def is2d=: (bool is2d) -> untyped

    # The {#is2d?} method is used to get whether the component can glue to other
    # entities or not.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # behavior = model.definitions[0].behavior
    # if behavior.is2d?
    #   # We can also set what planes component can glue to.
    #   behavior.snapto = SnapTo_Arbitrary
    # end
    # ```
    def is2d?: () -> bool

    # Sets an integer that is really a bit-by-bit description of which scale
    # tool handles are hidden on a given component. This is useful for creating
    # definitions that can only be scaled in particular ways. If a bit contains a
    # a 1, then a certain handle set will be hidden when the user selects the
    # component and activates the Scale tool. Here is the map of which bits
    # control which handles.
    # 
    # - Bit0: disable scale along red (X),
    # - Bit1: disable scale along green (Y),
    # - Bit2: disable scale along blue (Z),
    # - Bit3: disable scale in red/blue plane (X+Z),
    # - Bit4: disable scale in green/blue plane (Y+Z),
    # - Bit5: disable scale in red/green plane (X+Y),
    # - Bit6: disable scale uniform (from corners) (XYZ).
    # 
    # Note that for 2-dimensional components (such as face-me components), not all
    # of the handles in the list above are even used. Also, if the component you
    # are modifying is already selected with the scale tool, then you or your user
    # must deactivate and reactivate the scale tool for your new behavior to take
    # effect.
    # 
    # _@param_ `scale_mask` — An integer describing which scale tool handles are hidden.
    # 
    # _@return_ — behavior - the Behavior object
    # 
    # ```ruby
    # # Disable the green and red-axes handles by setting bits 1 and 2 to 1.
    # definition = Sketchup.active_model.definitions[0]
    # behavior = definition.behavior
    # behavior.no_scale_mask = (1 << 1) + (1 << 2)
    # ```
    def no_scale_mask=: (untyped scale_mask) -> untyped

    # The no_scale_mask? method returns an integer that is a bit-by-bit
    # description of which scale tool handles are hidden when the user selects
    # this single component with the scale tool. See the no_scale_mask=
    # method for details on the bit encodings used.
    # 
    # _@return_ — scale_mask - an integer describing which scale tool
    # handles are hidden.
    # 
    # ```ruby
    # definition = Sketchup.active_model.definitions[0]
    # behavior = definition.behavior
    # no_scale_mask = behavior.no_scale_mask?
    # ```
    def no_scale_mask?: () -> bool

    # The shadows_face_sun= method is used to identify whether the component's
    # shadow will be cast from the component's current position as though the
    # component were facing the sun. See the Component entity within the SketchUp
    # User's guide for more information on this feature.
    # 
    # _@param_ `status` — true if the component's is to be cast from the component's current position as though the component were facing the sun. False to cause the shadow to be cast from the component's current position.
    # 
    # _@return_ — behavior - the Behavior object
    # 
    # ```ruby
    # model = Sketchup.active_model
    # behavior = model.definitions[0].behavior
    # behavior = behavior.shadows_face_sun = true
    # ```
    def shadows_face_sun=: (untyped status) -> untyped

    # The shadows_face_sun? method is used to determine whether the component's
    # shadow is being cast from the component's current position (as though the
    # component were facing the sun). See the Component entity within the SketchUp
    # User's guide for more information on this feature.
    # 
    # _@return_ — status - true if the component's is to be cast from the
    # component's current position as though the component
    # were facing the sun. False to cause the shadow to be
    # cast from the component's current position.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # # Returns a DefinitionList
    # definitions = model.definitions
    # path = Sketchup.find_support_file "Bed.skp",
    #   "Components/Components Sampler/"
    # begin
    #   definition = definitions.load path
    # rescue
    #   UI.messagebox $!.message
    # end
    # ```
    def shadows_face_sun?: () -> bool

    # The {#snapto} method is used to see how a component can glue to other
    # entities.
    # 
    # Returns a value indicating the snapping behavior of the component. Snapping
    # behavior is how the x-y plane of a component instance will be snapped against
    # a face. Possible values are:
    # 
    # - +SnapTo_Arbitrary+ => Snap to any arbitrary face,
    # - +SnapTo_Horizontal+ => Snap to horizontal face like floors,
    # - +SnapTo_Vertical+ => Snap to vertical face like walls,
    # - +SnapTo_Sloped+ => Snap to sloped face like sloping roofs.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # behavior = model.definitions[0].behavior
    # snapto = behavior.snapto
    # ```
    def snapto: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#snapto=} method is used to set how a component can glue to other
    # entities.
    # 
    # Snapping behavior is how the x-y plane of a component instance will be
    # snapped against a face. Possible constant values are:
    # 
    # - +SnapTo_Arbitrary+ => Snap to any arbitrary face,
    # - +SnapTo_Horizontal+ => Snap to horizontal face like floors,
    # - +SnapTo_Vertical+ => Snap to vertical face like walls,
    # - +SnapTo_Sloped+ => Snap to sloped face like sloping roofs.
    # 
    # _@param_ `snapto`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # behavior = model.definitions[0].behavior
    # behavior.is2d = true
    # behavior.snapto = SnapTo_Horizontal
    # ```
    # 
    # _@note_ — To enable gluing, also set {#is2d=} to true.
    # 
    # _@note_ — To disable gluing, set {#is2d=} to false.
    def snapto=: (Integer snapto) -> untyped
  end

  # The {Sketchup::Entities} class is a collection of Entity objects, either in a
  # {Sketchup::ComponentDefinition} or directly in the {Sketchup::Model}. A
  # {Sketchup::Entities} object corresponds to a drawing context in the GUI.
  # 
  # @version SketchUp 6.0
  class Entities
    include Enumerable[Sketchup::Entity]

    # The {#[]} method is used to retrieve an entity by its index in an array of
    # entities. The index is a number between +0+ and entities.length - 1. In
    # general, it is preferable to use the {#each} method to iterate though all
    # of the entities in the collection as it will be much more efficient.
    # 
    # _@param_ `entity_index` — The index for a specific entity.
    # 
    # _@return_ — an {Sketchup::Entity} object if successful,
    # +nil+ if not found
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # entity = entities[0]
    # ```
    # 
    # _@see_ `#at`
    def []: (Integer entity_index) -> Sketchup::Entity?

    # The active_section_plane method is used to access the currently active
    # section plane in the Entities object.
    # 
    # _@return_ — the active SectionPlane or nil if none is active.
    # 
    # ```ruby
    # sp = Sketchup.active_model.entities.active_section_plane
    # puts "Active section plane is #{sp}" if !sp.nil?
    # ```
    def active_section_plane: () -> Sketchup::SectionPlane?

    # The active_section_plane= method is used to set the active section plane in
    # the Entities object.
    # 
    # _@param_ `sec_plane` — the SectionPlane object to be set active. Pass nil to deactivate any active section plane.
    # 
    # _@return_ — the SectionPlane object that was set active.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # sp = entities.add_section_plane([50, 50, 0], [1.0, 1.0, 0])
    # entities.active_section_plane = sp
    # ```
    def active_section_plane=: (Sketchup::SectionPlane? sec_plane) -> Sketchup::SectionPlane?

    # sord omit - no YARD type given for "string", using untyped
    # sord omit - no YARD type given for "alignment", using untyped
    # sord omit - no YARD type given for "font", using untyped
    # sord omit - no YARD type given for "is_bold", using untyped
    # sord omit - no YARD type given for "is_italic", using untyped
    # sord omit - no YARD type given for "letter_height", using untyped
    # The add_3d_text is used to create 3D text. It will be added as edges and
    # faces drawn at the origin.
    # 
    # = 1.0, tolerance = 0.0, z = 0.0, is_filled = true, extrusion = 0.0)
    # 
    #   @param [String] string
    #     The text to create.
    # 
    #   @param [Integer] alignment
    #     Number that defines the alignment. There are constants
    #     called TextAlignLeft, TextAlignRight, and
    #     TextAlignCenter that can be passed.
    # 
    #   @param [String] font
    #     font name.
    # 
    #   @param [Boolean] is_bold
    #     true for bold.
    # 
    #   @param [Boolean] is_italic
    #     true for italic.
    # 
    #   @param [Numeric] letter_height
    #     Height of the text in inches.
    # 
    #   @param [Numeric] tolerance
    #     Tolerance of the curve creation. Defaults to
    #     0.0, which creates the highest possible curve quality.
    # 
    #   @param [Numeric] z
    #     z position in inches.
    # 
    #   @param [Boolean] is_filled
    #     true for filled, which will put a face between the edges of the letters.
    # 
    #   @param [Numeric] extrusion
    #     Extrusion depth in inches.
    # 
    # _@return_ — true if successful
    # 
    # ```ruby
    # # Draw the word "test" at the origin of the model, aligned left, in
    # # Arial Bold, not italics, 1" in size, best tolerance quality, filled,
    # # with an extrusion size of 5".
    # entities = Sketchup.active_model.entities
    # success = entities.add_3d_text('test', TextAlignLeft, "Arial",
    #   true, false, 1.0, 0.0, 0.5, true, 5.0)
    # ```
    def add_3d_text: (
                       untyped string,
                       untyped alignment,
                       untyped font,
                       ?untyped is_bold,
                       ?untyped is_italic,
                       untyped letter_height
                     ) -> bool

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The add_arc method is used to create an arc curve segment.
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = Geom::Vector3d.new 1,0,0
    # vector3 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.active_entities
    # edges = entities.add_arc centerpoint, vector2, vector3, 10, 15.degrees, 135.degrees
    # arccurve = edges.first.curve
    # ```
    def add_arc: (*untyped args) -> untyped

    # The add_circle method is used to create a circle.
    # 
    # _@param_ `center` — A Point3d object representing the center.
    # 
    # _@param_ `normal` — A Vector3d object representing normal for the arc.
    # 
    # _@param_ `radius` — The radius of the arc.
    # 
    # _@param_ `numsegs` — The number of segments.
    # 
    # _@return_ — an Array object containing edges if successful
    # 
    # ```ruby
    # centerpoint = Geom::Point3d.new
    # # Create a circle perpendicular to the normal or Z axis
    # vector = Geom::Vector3d.new 0,0,1
    # vector2 = vector.normalize!
    # model = Sketchup.active_model
    # entities = model.active_entities
    # edges = entities.add_circle centerpoint, vector2, 10
    # ```
    def add_circle: (
                      Geom::Point3d center,
                      Geom::Vector3d normal,
                      Numeric radius,
                      ?Integer numsegs
                    ) -> ::Array[Sketchup::Edge]

    # sord omit - no YARD type given for "*args", using untyped
    # The {#add_cline} method is used to create a construction line. This can be
    # finite or infinite.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(0, 0, 0)
    # point2 = Geom::Point3d.new(20, 20, 20)
    # cline = entities.add_cline(point1, point2)
    # ```
    def add_cline: (*untyped args) -> Sketchup::ConstructionLine

    # The add_cpoint method is used to create a construction point.
    # 
    # _@param_ `point` — A Point3d object.
    # 
    # _@return_ — a ConstructionPoint object if
    # successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(100,200,300)
    # constpoint = entities.add_cpoint point1
    # if (constpoint)
    #   UI.messagebox constpoint
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def add_cpoint: (Geom::Point3d point) -> Sketchup::ConstructionPoint

    # sord omit - no YARD type given for "*args", using untyped
    # The add_curve method is used to create a curve from a collection of edges.
    # 
    # The arguments are either Points or an Array of Points. At least 2 points are
    # required.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # curve = entities.add_curve [0,0,0], [0,10,0], [1,20,0]
    # ```
    def add_curve: (*untyped args) -> ::Array[Sketchup::Edge]

    # sord omit - no YARD type given for "*args", using untyped
    # The {#add_dimension_linear} method adds a linear dimension to the entities.
    # 
    # [instance_path, end_point], vector)
    # 
    # vector)
    # 
    # _@return_ — the created dimension
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # # From point to point
    # dim = entities.add_dimension_linear [50, 10, 0], [100, 10, 0], [0, 20, 0]
    # # Between edge vertices
    # edge = entities.add_edges([50,50,0], [40,10,0])[0]
    # v0 = edge.start
    # v1 = edge.end
    # dim = entities.add_dimension_linear v0, v1, [0, 0, 20]
    # # From an edge's midpoint to a construction point
    # p0 = edge.start.position
    # p1 = edge.end.position
    # mp = Geom::Point3d.new((p0.x+p1.x)/2.0, (p0.y+p1.y)/2.0, (p0.z+p1.z)/2.0)
    # cp = entities.add_cpoint [50, 10, 0]
    # dim = entities.add_dimension_linear [edge, mp], cp, [20, 0, 0]
    # # alternatively, the start params could be passed in separately
    # dim = entities.add_dimension_linear edge, mp, cp, [20, 0, 0]
    # ```
    # 
    # Instance path
    # ```ruby
    # instance = Sketchup.active_model.active_entities.grep(Sketchup::ComponentInstance).first
    # edge = instance.definition.entities.grep(Sketchup::Edge).first
    # instance_path = Sketchup::InstancePath.new([instance, edge])
    # start_point = edge.start.position
    # end_point = edge.end.position
    # vector = Geom::Vector3d.new(30, 30, 0)
    # Sketchup.active_model.entities.add_dimension_linear([instance_path, start_point],
    # ```
    # 
    # Instance path as an array
    # ```ruby
    # instance = Sketchup.active_model.active_entities.grep(Sketchup::ComponentInstance).first
    # edge = instance.definition.entities.grep(Sketchup::Edge).first
    # path = [instance, edge]
    # start_point = edge.start.position
    # end_point = edge.end.position
    # vector = Geom::Vector3d.new(30, 30, 0)
    # Sketchup.active_model.entities.add_dimension_linear([path, start_point], [path, end_point],
    # ```
    def add_dimension_linear: (*untyped args) -> Sketchup::DimensionLinear

    # The add_dimension_radial method adds a radial dimension (i.e arc/circle
    # radius/diameter dimension) to the entities.
    # 
    # _@param_ `arc_curve` — an ArcCurve object to which the dimension is to be attached.
    # 
    # _@param_ `leader_break_pt` — a Point3d for the break point on the leader where the dimension text is attached.
    # 
    # _@return_ — the created dimension
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # # Create a circle
    # centerpoint = Geom::Point3d.new(10, 10, 0)
    # vector = Geom::Vector3d.new(0, 0, 1)
    # edges = entities.add_circle centerpoint, vector, 10
    # circle = edges[0].curve
    # dim = entities.add_dimension_radial circle, [30, 30, 0]
    # ```
    def add_dimension_radial: (Sketchup::ArcCurve arc_curve, Geom::Point3d leader_break_pt) -> Sketchup::DimensionRadial

    # sord omit - no YARD type given for "*args", using untyped
    # The {#add_edges} method is used to add a set of connected edges to the
    # {Sketchup::Entities} collection.
    # 
    # _@return_ — an array of Edge objects if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(0,0,0)
    # point2 = Geom::Point3d.new(20,20,20)
    # edges = entities.add_edges point1, point2
    # ```
    # 
    # _@note_ — If the points form a closed loop, the first and last vertex will not
    # merge. If you intend to create a face from the edges, use {#add_face}
    # directly.
    # 
    # _@see_ `Sketchup::EntitiesBuilder#add_edges` — EntitiesBuilder#add_edges, alternative
    # for generating bulk geometry with performance in mind.
    def add_edges: (*untyped args) -> ::Array[Sketchup::Edge]

    # sord omit - no YARD type given for "*args", using untyped
    # The add_face method is used to create a face. You can call this method a
    # number of ways:
    # 
    #   - entities.add_face(edge1, edge2, edge3, ...)
    #   - entities.add_face(edgearray)
    #   - entities.add_face(pt1, pt2, pt3, ...)
    #   - entities.add_face([pt1, pt2, pt3,...])
    #   - entities.add_face(curve)
    # 
    # For the last form that takes a Curve, the curve must be closed - like a
    # circle.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face(pts)
    # ```
    # 
    # _@note_ — A special case exists for any face created on the ground plane, in
    # which case the vertex order is ignored and the face is always facing down.
    # 
    # _@see_ `Sketchup::EntitiesBuilder#add_face` — EntitiesBuilder#add_face, alternative
    # for generating bulk geometry with performance in mind.
    # 
    # _@see_ `file:pages/generating_geometry.md` — Guide on Generating Geometry
    def add_face: (*untyped args) -> Sketchup::Face?

    # The {#add_faces_from_mesh} method is used to add {Sketchup::Face} entities to the
    # collection of entities from a {Geom::PolygonMesh}.
    # 
    # The +smooth_flags+ parameter can contain any of the following values if
    # passed. The constants were added in SketchUp 2014. For previous versions,
    # numeric values have to be specified instead of the Ruby constants.
    # 
    # - 0: {Geom::PolygonMesh::NO_SMOOTH_OR_HIDE}
    # - 1: {Geom::PolygonMesh::HIDE_BASED_ON_INDEX} (Negative point index will hide the edge.)
    # - 2: {Geom::PolygonMesh::SOFTEN_BASED_ON_INDEX} (Negative point index will soften the edge.)
    # - 4: {Geom::PolygonMesh::AUTO_SOFTEN} (Interior edges are softened.)
    # - 8: {Geom::PolygonMesh::SMOOTH_SOFT_EDGES} (All soft edges will also be smooth.)
    # 
    # The 3rd and 4th parameters will accept a {Sketchup::Material} object or a
    # string name of a material currently in the model.
    # 
    # _@param_ `polygon_mesh`
    # 
    # _@param_ `smooth_flags` — flags for softening and smoothing of edges.
    # 
    # _@param_ `f_material` — material to paint front faces with.
    # 
    # _@param_ `b_material` — material to paint back faces with.
    # 
    # _@return_ — Number of faces created
    # 
    # ```ruby
    # pm = Geom::PolygonMesh.new
    # pm.add_point([ 0, 0, 0]) # 1
    # pm.add_point([10, 0, 0]) # 2
    # pm.add_point([10,10, 0]) # 3
    # pm.add_point([ 0,10, 0]) # 4
    # pm.add_point([20, 0, 5]) # 5
    # pm.add_point([20,10, 5]) # 6
    # pm.add_polygon(1, -2, 3, 4)
    # pm.add_polygon(2, 5,6, -3)
    # 
    # # Create a new group that we will populate with the mesh.
    # group = Sketchup.active_model.entities.add_group
    # material = Sketchup.active_model.materials.add('green')
    # smooth_flags = Geom::PolygonMesh::NO_SMOOTH_OR_HIDE
    # group.entities.add_faces_from_mesh(pm, smooth_flags, material)
    # ```
    # 
    # _@see_ `Sketchup::EntitiesBuilder` — EntitiesBuilder, alternative interface
    # for generating bulk geometry with performance in mind.
    # 
    # _@see_ `file:pages/generating_geometry.md` — Guide on Generating Geometry
    def add_faces_from_mesh: (
                               Geom::PolygonMesh polygon_mesh,
                               ?Integer smooth_flags,
                               ?(Sketchup::Material | String)? f_material,
                               ?(Sketchup::Material | String)? b_material
                             ) -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # The add_group method is used to create an empty group or a group with
    # entities.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # group = entities.add_group
    # ```
    # 
    # _@note_ — Calling add_group with entities in its parameters has been known to
    # crash SketchUp before version 8.0. It is preferable to create an empty
    # group and then add things to its Entities collection.
    def add_group: (*untyped args) -> Sketchup::Group

    # The add_image method is used to add an image to the collection of entities.
    # 
    # The width and height are measured in model units (i.e. inches). If the
    # height is not given, then it is computed from the width to preserve the
    # aspect ratio of the image.
    # 
    # _@param_ `path` — A path for the image file.
    # 
    # _@param_ `point` — A Point3d object representing the insertion point of the image.
    # 
    # _@param_ `width` — Width for the image.
    # 
    # _@param_ `height` — height for the image if you want to control width and height independently. Leave as default +0.0+ when you want it to be relative to the aspect ratio.
    # 
    # _@return_ — an Image object if successful.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point = Geom::Point3d.new 10,20,30
    # image = entities.add_image "Shapes.jpg", point, 300
    # if (image)
    #   UI.messagebox image
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def add_image: (
                     String path,
                     Geom::Point3d point,
                     Numeric width,
                     ?Numeric height
                   ) -> Sketchup::Image?

    # The add_instance method adds a component instance to the collection of
    # entities.
    # 
    # _@param_ `definition` — A ComponentDefinition object.
    # 
    # _@param_ `transform` — A Transformation object.
    # 
    # _@return_ — a ComponentInstance object if successful
    # 
    # ```ruby
    # point = Geom::Point3d.new 10,20,30
    # transform = Geom::Transformation.new point
    # model = Sketchup.active_model
    # entities = model.active_entities
    # path = Sketchup.find_support_file "Bed.skp",
    #   "Components/Components Sampler/"
    # definitions = model.definitions
    # componentdefinition = definitions.load path
    # instance = entities.add_instance componentdefinition, transform
    # if (instance)
    #   UI.messagebox instance
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def add_instance: (Sketchup::ComponentDefinition definition, Geom::Transformation transform) -> Sketchup::ComponentInstance

    # The add_line method is used to add an edge to the collection of entities.
    # This is not to be confused with the concept of a "line" from a geometric
    # sense, which is an invisible object represented by an Array of a point
    # and a vector. (See the Array class for more information on geometric lines in
    # SketchUp.)
    # 
    # This method is the same as add_edges method, but returns a single edge.
    # 
    # _@param_ `point1` — Point3d object representing the edge's starting point.
    # 
    # _@param_ `point2` — Point3d object representing the edge's ending point.
    # 
    # _@return_ — a Edge object if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(0,0,0)
    # point2 = Geom::Point3d.new(20,20,20)
    # line = entities.add_line point1,point2
    # if (line)
    #   UI.messagebox line
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    # 
    # _@see_ `Sketchup::EntitiesBuilder#add_edge` — EntitiesBuilder#add_edge, alternative
    # for generating bulk geometry with performance in mind.
    # 
    # _@see_ `file:pages/generating_geometry.md` — Guide on Generating Geometry
    def add_line: (Geom::Point3d point1, Geom::Point3d point2) -> Sketchup::Edge

    # The add_ngon method is used to create a multi-sided polygon.
    # 
    # _@param_ `center` — A Point3d object representing the center of the polygon.
    # 
    # _@param_ `normal` — A Vector3d object.
    # 
    # _@param_ `radius` — A radius.
    # 
    # _@param_ `numsides` — The number of sides for the polygon.
    # 
    # _@return_ — an array of Edges that make up the polygon if
    # successful
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # center = Geom::Point3d.new
    # normal = Geom::Vector3d.new(0,0,1)
    # radius = 100
    # numsides = 6
    # edges = entities.add_ngon center, normal, radius, numsides
    # ```
    def add_ngon: (
                    Geom::Point3d center,
                    Geom::Vector3d normal,
                    Numeric radius,
                    ?Integer numsides
                  ) -> ::Array[Sketchup::Edge]

    # The add_observer method is used to add an observer to the current object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # status = entities.add_observer observer
    # ```
    def add_observer: (Object observer) -> bool

    # The add_section_plane method adds a section plane object to the entities.
    # 
    # _@param_ `plane` — the geometric plane where the SectionPlane object is to be created. Refer to the Geom module for information on how planes are represented.
    # 
    # _@return_ — the created SectionPlane object if
    # successful, nil on failure.
    # 
    # ```ruby
    # # Create a section plane
    # model = Sketchup.active_model
    # sp = model.entities.add_section_plane([50, 50, 0], [1.0, 1.0, 0])
    # # Activate it
    # sp.activate
    # # Make sure section planes are visible
    # model.rendering_options['DisplaySectionPlanes'] = true
    # ```
    def add_section_plane: (untyped plane) -> Sketchup::SectionPlane?

    # sord omit - no YARD type given for "*args", using untyped
    # The {#add_text} method adds a note or label text entity to the entities.
    # 
    # _@return_ — a Text object if successful
    # 
    # ```ruby
    # coordinates = [10, 10, 10]
    # model = Sketchup.active_model
    # entities = model.entities
    # point = Geom::Point3d.new coordinates
    # text = entities.add_text "This is a Test", point
    # ```
    # 
    # Instance path
    # ```ruby
    # instance = Sketchup.active_model.active_entities.grep(Sketchup::ComponentInstance).first
    # edge = instance.definition.entities.grep(Sketchup::Edge).first
    # instance_path = Sketchup::InstancePath.new([instance, edge])
    # point = edge.start.position
    # vector = Geom::Vector3d.new(30, 30, 0)
    # Sketchup.active_model.entities.add_text("mytext", [instance_path, point], vector)
    # ```
    # 
    # Instance path as an array
    # ```ruby
    # instance = Sketchup.active_model.active_entities.grep(Sketchup::ComponentInstance).first
    # edge = instance.definition.entities.grep(Sketchup::Edge).first
    # path = [instance, edge]
    # point = edge.start.position
    # vector = Geom::Vector3d.new(30, 30, 0)
    # Sketchup.active_model.entities.add_text("mytext", [path, point], vector)
    # ```
    def add_text: (*untyped args) -> Sketchup::Text

    # The {#at} method is an alias for {#[]}.
    # 
    # _@param_ `entity_index` — The index for a specific entity.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # entity = entities.at(0)
    # ```
    # 
    # _@see_ `#[]`
    def at: (Integer entity_index) -> Sketchup::Entity?

    # Creates an {Sketchup::EntitiesBuilder} that can be used to generate bulk
    # geometry with performance in mind. This is particularly useful for importers
    # where the geometry is already well defined and one wants to recreate it
    # without further processing.
    # 
    # The call to {#build} starts an implicit operation, even if no other model
    # changes are made within the block. This is not the same as
    # {Sketchup::Model#start_operation}, so it's still recommended to wrap all
    # model changes, including {#build} with {Sketchup::Model#start_operation} and
    # {Sketchup::Model#commit_operation}.
    # 
    # Refer to the documentation of {Sketchup::EntitiesBuilder} for more details.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # model.entities.build { |builder|
    #   edge = builder.add_edge([0, 0, 0], [9, 0, 0])
    #   edge.material = 'red'
    #   face = builder.add_face([[0, 0, 0], [9, 0, 0], [9, 9, 0], [0, 9, 0]])
    #   face.material = 'maroon'
    # }
    # ```
    # 
    # _@note_ — While using {Sketchup::Entities#build} it is important to not
    # add or remove vertices by other means of the builder. Also don't modify the
    # position of the vertices in the {Sketchup::Entities} container geometry is
    # added to. Doing so can break the vertex-cache that de-duplicates the vertices.
    # 
    # _@see_ `Sketchup::EntitiesBuilder`
    def build: () ?{ (Sketchup::EntitiesBuilder builder) -> void } -> void

    # The clear! method is used to remove all entities from the collection of
    # entities.
    # 
    # _@return_ — true if successful, false if unsuccessful
    # 
    # ```ruby
    # coordinates = [10, 10, 10]
    # model = Sketchup.active_model
    # entities = model.entities
    # point = Geom::Point3d.new coordinates
    # text = entities.add_text "This is a Test", point
    # UI.messagebox "Clearing All"
    # status = entities.clear!
    # ```
    def clear!: () -> bool

    # ```ruby
    # model = Sketchup.active_model
    # entities = model.entities
    # entities.add_cpoint([10, 10, 10])
    # number = entities.count
    # ```
    # 
    # _@note_ — Since SketchUp 2014 the count method is inherited from Ruby's
    # +Enumerable+ mix-in module. Prior to that the {#count} method is an alias
    # for {#length}.
    # 
    # _@see_ `#length`
    def count: () -> Integer

    # The {#each} method is used to iterate through the entities in the collection
    # of entities.
    # 
    # ```ruby
    # coordinates = [10, 10, 10]
    # model = Sketchup.active_model
    # entities = model.entities
    # point = Geom::Point3d.new coordinates
    # text = entities.add_text "This is a Test", point
    # entities.each { | entity| puts entity }
    # ```
    # 
    # _@note_ — Don't remove content from this collection while iterating over it with
    # {#each}. This would change the size of the collection and cause elements to
    # be skipped as the indices change. Instead copy the current collection to an
    # array using +to_a+ and then use +each+ on the array, when removing content.
    def each: () ?{ (Sketchup::Entity entity) -> void } -> void

    # sord omit - no YARD type given for "*args", using untyped
    # The erase_entities method is used to erase one or more entities from the
    # model.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # 
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # 
    # # I just happen to know that the second entity in the
    # # entities objects is an edge, so erase it.
    # UI.messagebox entities
    # entities.erase_entities entities[1]
    # UI.messagebox entities
    # ```
    def erase_entities: (*untyped args) -> void

    # The {#fill_from_mesh} method is used to add faces and edges to the collection
    # of entities from a {Geom::PolygonMesh}. It requires that the entities
    # collection to be filled is empty. It has higher performance than
    # {#add_faces_from_mesh}, but does less error checking as it builds the
    # geometry.
    # 
    # The +smooth_flags+ parameter can contain any of the following values if
    # passed. The constants were added in SketchUp 2014. For previous versions,
    # numeric values have to be specified instead of the Ruby constants:
    # 
    # - 0: {Geom::PolygonMesh::NO_SMOOTH_OR_HIDE}
    # - 1: {Geom::PolygonMesh::HIDE_BASED_ON_INDEX} (Negative point index will hide the edge.)
    # - 2: {Geom::PolygonMesh::SOFTEN_BASED_ON_INDEX} (Negative point index will soften the edge.)
    # - 4: {Geom::PolygonMesh::AUTO_SOFTEN} (Interior edges are softened.)
    # - 8: {Geom::PolygonMesh::SMOOTH_SOFT_EDGES} (All soft edges will also be smooth.)
    # 
    # The 4rd and 5th parameters will accept a {Sketchup::Material} object or a
    # string name of a material currently in the model.
    # 
    # _@param_ `polygon_mesh`
    # 
    # _@param_ `weld_vertices` — This argument has no effect and is kept for compatibility reasons. Points are always merged.
    # 
    # _@param_ `smooth_flags` — flags for softening and smoothing of edges.
    # 
    # _@param_ `f_material` — material to paint front faces with.
    # 
    # _@param_ `b_material` — material to paint back faces with.
    # 
    # ```ruby
    # pm = Geom::PolygonMesh.new
    # pm.add_point([ 0, 0, 0]) # 1
    # pm.add_point([10, 0, 0]) # 2
    # pm.add_point([10,10, 0]) # 3
    # pm.add_point([ 0,10, 0]) # 4
    # pm.add_point([20, 0, 5]) # 5
    # pm.add_point([20,10, 5]) # 6
    # pm.add_polygon(1, -2, 3, 4)
    # pm.add_polygon(2, 5, 6, -3)
    # 
    # # Create a new group that we will populate with the mesh.
    # group = Sketchup.active_model.entities.add_group
    # material = Sketchup.active_model.materials.add('red')
    # smooth_flags = Geom::PolygonMesh::HIDE_BASED_ON_INDEX
    # group.entities.fill_from_mesh(pm, true, smooth_flags, material)
    # ```
    # 
    # _@see_ `Sketchup::EntitiesBuilder` — EntitiesBuilder, alternative interface
    # for generating bulk geometry with performance in mind.
    # 
    # _@see_ `file:pages/generating_geometry.md` — Guide on Generating Geometry
    def fill_from_mesh: (
                          Geom::PolygonMesh polygon_mesh,
                          ?bool weld_vertices,
                          ?Integer smooth_flags,
                          ?(Sketchup::Material | String)? f_material,
                          ?(Sketchup::Material | String)? b_material
                        ) -> bool

    # The intersect_with method is used to intersect an entities, component
    # instance, or group object with a entities object.
    # 
    # _@param_ `recurse` — true if you want this entities object to be recursed (intersection lines will be put inside of groups and components within this entities object).
    # 
    # _@param_ `transform1` — The transformation for this entities object.
    # 
    # _@param_ `entities1` — The entities object where you want the intersection lines to appear.
    # 
    # _@param_ `transform2` — The transformation for entities1.
    # 
    # _@param_ `hidden` — true if you want hidden geometry in this entities object to be used in the intersection.
    # 
    # _@param_ `entities2` — A single entity, or an array of entities.
    # 
    # ```ruby
    # entities.intersect_with recurse, transformation1, entities1,
    #   transformation2, hidden, entities2
    # ```
    def intersect_with: (
                          bool recurse,
                          Geom::Transformation transform1,
                          Sketchup::Entities entities1,
                          Geom::Transformation transform2,
                          bool hidden,
                          (Sketchup::Entity | ::Array[Sketchup::Entity]) entities2
                        ) -> void

    # The {#length} method is used to retrieve the number of entities in the
    # collection of entities.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.entities
    # entities.add_cpoint([10, 10, 10])
    # number = entities.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The model method is used to retrieve the model that contains the collection
    # of entities.
    # 
    # _@return_ — the model that contains the collection of
    # entities if successful.
    # 
    # ```ruby
    # coordinates = [10, 10, 10]
    # model = Sketchup.active_model
    # entities = model.entities
    # point = Geom::Point3d.new coordinates
    # text = entities.add_text "This is a Test", point
    # model = entities.model
    # ```
    def model: () -> Sketchup::Model

    # The parent method is used to retrieve the parent or object that contains the
    # collection of entities. A parent can be either a Model or
    # ComponentDefinition object.
    # 
    # _@return_ — the object that
    # contains the collection of entities if successful
    # 
    # ```ruby
    # coordinates = [10, 10, 10]
    # model = Sketchup.active_model
    # entities = model.entities
    # point = Geom::Point3d.new coordinates
    # text = entities.add_text "This is a Test", point
    # parent = entities.parent
    # ```
    def parent: () -> (Sketchup::ComponentDefinition | Sketchup::Model)

    # The remove_observer method is used to remove an observer from the current
    # object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # status = entities.remove_observer observer
    # ```
    def remove_observer: (Object observer) -> bool

    # The {#size} method is an alias for the {#length} method.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.entities
    # entities.add_cpoint([10, 10, 10])
    # number = entities.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer

    # The transform_by_vectors method is used to apply several vectors to several
    # sub-entities all at once.
    # 
    # _@param_ `sub_entities` — An array of entities to transform.
    # 
    # _@param_ `vectors` — An array of vectors to apply.
    # 
    # ```ruby
    # # Raise vertices in selection by their distance to the origin.
    # model = Sketchup.active_model
    # entities = model.active_entities
    # with_vertices = entities.select { |entity| entity.respond_to?(:vertices) }
    # vertices = with_vertices.flat_map(&:vertices).uniq
    # lengths = vertices.map { |vertex| vertex.position.distance(ORIGIN) }
    # vectors = lengths.map { |length| Geom::Vector3d.new(0, 0, length) }
    # 
    # entities.transform_by_vectors(vertices, vectors)
    # ```
    def transform_by_vectors: (::Array[Sketchup::Entity] sub_entities, ::Array[Geom::Vector3d] vectors) -> Sketchup::Entities

    # The transform_entities method is used to apply a transform to several
    # sub-entities all at once.
    # 
    # If you are transforming entities in the active drawing context or any of its
    # parent drawing contexts, the transformation will be interpreted as relative
    # to the global coordinate system. Otherwise the transformation will be
    # interpreted as being on the local coordinate system.
    # 
    # _@param_ `transform` — The Transformation to apply.
    # 
    # _@param_ `entities` — An array or series of entities to transform.
    # 
    # _@return_ — +false+ if the entities array was empty.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # entity1 = entities.add_line([0,0,0],[100,100,100])
    # entity2 = entities.add_line([0,0,0],[200,-10,-10])
    # 
    # transformation = Geom::Transformation.new([100,0,0])
    # entities.transform_entities(transformation, [entity1, entity2])
    # ```
    def transform_entities: (Geom::Transformation transform, ::Array[Sketchup::Entity] entities) -> bool

    # The {#weld} method takes a set of edges and find all possible chains of edges
    # and connect them with a {Sketchup::Curve}.
    # 
    # A curve will not cross another curve. They will split where multiple curves
    # meet.
    # 
    # _@param_ `edges`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # edges = model.selection.grep(Sketchup::Edge)
    # curves = model.active_entities.weld(edges)
    # ```
    def weld: (::Array[Sketchup::Edge] edges) -> ::Array[Sketchup::Curve]
  end

  # References an image representation object.
  # 
  # @example
  #   # Get the color of the center of the first material texture found in model.
  #   texture = Sketchup.active_model.materials.map(&:texture).compact.first
  #   image_rep = texture.image_rep
  #   color = image_rep.color_at_uv(0.5, 0.5)
  # 
  # @version SketchUp 2018
  class ImageRep
    # The {#bits_per_pixel} method gets the number of bits per pixel in the
    # image.
    # 
    # ```ruby
    # image_rep = Sketchup::ImageRep.new
    # image_rep.load_file("/path/to/image.jpg")
    # bpp = image_rep.bits_per_pixel
    # ```
    def bits_per_pixel: () -> Integer

    # The {#color_at_uv} method returns a color corresponding to the UV texture
    # coordinates. +0.0, 0.0+ maps to the bottom left and +1.0, 1.0+ to the top
    # right of the image.
    # 
    # _@param_ `u` — The U texture coordinate.
    # 
    # _@param_ `v` — The V texture coordinate.
    # 
    # _@param_ `bilinear` — Use bilinear texture filtering. This interpolates the colors instead of picking the nearest neighbor.
    # 
    # ```ruby
    # image_rep = Sketchup::ImageRep.new
    # image_rep.load_file("/path/to/image.jpg")
    # color = image_rep.color_at_uv(0.7, 0.5, false)
    # ```
    def color_at_uv: (Float u, Float v, ?bool bilinear) -> Sketchup::Color?

    # The {#colors} method returns an array of {Sketchup::Color} for each pixel in
    # the image.
    # 
    # ```ruby
    # image_rep = Sketchup::ImageRep.new
    # image_rep.load_file("/path/to/image.jpg")
    # colors = image_rep.colors
    # ```
    def colors: () -> ::Array[Sketchup::Color]?

    # The {#data} method gets the pixel data for an image in a string of bytes.
    # 
    # ```ruby
    # image_rep = Sketchup::ImageRep.new
    # image_rep.load_file("/path/to/image.jpg")
    # byte_string = image_rep.data
    # byte_string.each_byte { |byte| puts byte, ' ' }
    # ```
    # 
    # _@note_ — The byte order of the pixels are RGB(A) on macOS and BGR(A) on Windows.
    def data: () -> String?

    # The {#height} method returns the height of an image.
    # 
    # ```ruby
    # image_rep = Sketchup::ImageRep.new
    # image_rep.load_file("/path/to/image.jpg")
    # image_rep.height
    # ```
    def height: () -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # The {#initialize} method creates a new image object. The image object will
    # have no data if a path to the image is not provided.
    # 
    # Default constructor
    # ```ruby
    # image_rep = Sketchup::ImageRep.new
    # # Use #set_data or #load_file to add image data.
    # ```
    # 
    # Construct from file
    # ```ruby
    # image_rep = Sketchup::ImageRep.new("/path/to/image.jpg")
    # ```
    def initialize: (*untyped args) -> void

    # sord omit - no YARD return type given, using untyped
    # The {#load_file} method loads image data from the specified file.
    # 
    # _@param_ `filepath`
    # 
    # ```ruby
    # image_rep = Sketchup::ImageRep.new
    # image_rep.load_file("/path/to/image.jpg")
    # ```
    def load_file: (String filepath) -> untyped

    # The {#row_padding} method returns the size of the row padding of an image
    # in bytes.
    # 
    # ```ruby
    # image_rep = Sketchup::ImageRep.new
    # image_rep.load_file("/path/to/image.jpg")
    # image_rep.row_padding
    # ```
    def row_padding: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#save_file} method saves an image data object to an image file
    # specified by a path.
    # 
    # _@param_ `filepath`
    # 
    # ```ruby
    # image_rep = Sketchup::ImageRep.new
    # image_rep.load_file("/path/to/image1.jpg")
    # # do stuff with the image representation
    # image_rep.save_file("/path/to/save/image2.jpg")
    # ```
    def save_file: (String filepath) -> untyped

    # The {#set_data} method discards any existing data and sets new pixel data for
    # the {Sketchup::ImageRep}.
    # 
    # _@param_ `width` — The width of the pixel data. Must be greater than 0.
    # 
    # _@param_ `height` — The height of the pixel data. Must be greater than 0.
    # 
    # _@param_ `bits_per_pixel` — The bits per pixel for the pixel data. Must be either 8/24/32.
    # 
    # _@param_ `row_padding` — The row padding for the pixel data which is sized in bytes. Row padding is used to pad each row with zeros so that each scanline on the pixel data will end on the data-type boundary.
    # 
    # _@param_ `pixel_data` — The binary string containing the pixel data representing the new image.
    # 
    # Setting new data
    # ```ruby
    # image_rep = Sketchup::ImageRep.new
    # width = 800
    # height = 600
    # bpp = 24
    # pixel = [127, 127, 127].pack("C*")
    # pixels = pixel * width * height
    # image_rep.set_data(width, height, bpp, 0, pixels)
    # image_rep.save_file(UI.savepanel)
    # ```
    # 
    # Handling system color differences
    # ```ruby
    # # Generates red image on Mac and blue on Windows.
    # image_rep = Sketchup::ImageRep.new
    # color = Sketchup::Color.new("Red")
    # rgba = color.to_a # Red, green , blue, alpha
    # color_data = rgba.pack("C*")
    # image_rep.set_data(1, 1, 32, 0, color_data)
    # image_rep.save_file(UI.savepanel)
    # 
    # # Generates red image on both systems.
    # image_rep = Sketchup::ImageRep.new
    # color = Sketchup::Color.new("Red")
    # color_code = color.to_a # Red, green, blue, alpha
    # if Sketchup.platform == :platform_win
    #   # Change order to Blue, green, red, alpha on Windows.
    #   color_code = color_code.values_at(2, 1, 0, 3)
    # end
    # color_data = color_code.pack("C*")
    # image_rep.set_data(1, 1, 32, 0, color_data)
    # image_rep.save_file(UI.savepanel)
    # ```
    # 
    # _@note_ — The byte order of the pixels are RGB(A) on macOS and BGR(A) on Windows.
    # 
    # _@note_ — The encoding of the pixel_data {String} parameter should be ASCII-8BIT.
    # Any other encoding could corrupt the binary data. Using
    # `Array#pack("C*")` gives correct encoding.
    def set_data: (
                    Integer width,
                    Integer height,
                    Integer bits_per_pixel,
                    Integer row_padding,
                    String pixel_data
                  ) -> Sketchup::ImageRep

    # The {#size} method gets the total size of the image data in bytes.
    # 
    # ```ruby
    # image_rep = Sketchup::ImageRep.new
    # image_rep.load_file("/path/to/image.jpg")
    # data_size = image_rep.size
    # ```
    def size: () -> Integer

    # The {#width} method returns the width of an image.
    # 
    # ```ruby
    # image_rep = Sketchup::ImageRep.new
    # image_rep.load_file("/path/to/image.jpg")
    # image_rep.width
    # ```
    def width: () -> Integer
  end

  # The Importer interface lets you build your own importers for SketchUp. To
  # use this, you create a subclass of Importer and implement all of the
  # methods described below. This will make your importer appear in the list
  # that users see under File > Import, and you can use Ruby to do all of the
  # work of opening the file and creating whatever you need inside SketchUp.
  # 
  # Here is an example of a complete script that imports a .txt file and
  # displays its contents in a messagebox.
  # 
  # @example
  #   class TextImporter < Sketchup::Importer
  # 
  #     # This method is called by SketchUp to determine the description that
  #     # appears in the File > Import dialog's pulldown list of valid
  #     # importers.
  #     def description
  #       return "Custom Text Importer (*.txt)"
  #     end
  # 
  #     # This method is called by SketchUp to determine what file extension
  #     # is associated with your importer.
  #     def file_extension
  #       return "txt"
  #     end
  # 
  #     # This method is called by SketchUp to get a unique importer id.
  #     def id
  #       return "com.sketchup.importers.custom_txt"
  #     end
  # 
  #     # This method is called by SketchUp to determine if the "Options"
  #     # button inside the File > Import dialog should be enabled while your
  #     # importer is selected.
  #     def supports_options?
  #       return true
  #     end
  # 
  #     # This method is called by SketchUp when the user clicks on the
  #     # "Options" button inside the File > Import dialog. You can use it to
  #     # gather and store settings for your importer.
  #     def do_options
  #       # In a real use you would probably store this information in an
  #       # instance variable.
  #       my_settings = UI.inputbox(['My Import Option:'], ['1'],
  #         "Import Options")
  #     end
  # 
  #     # This method is called by SketchUp after the user has selected a file
  #     # to import. This is where you do the real work of opening and
  #     # processing the file.
  #     def load_file(file_path, status)
  #       UI.messagebox(file_path)
  # 
  #       return Sketchup::Importer::ImportSuccess
  #     end
  #   end
  # 
  #   Sketchup.register_importer(TextImporter.new)
  # 
  # @version SketchUp 6.0
  class Importer
    ImportCanceled: untyped
    ImportFail: untyped
    ImportFileNotFound: untyped
    ImportSuccess: untyped

    # This method is called by SketchUp to determine the description that appears
    # in the File > Import dialog's pulldown list of valid importers.
    # 
    # Though it is common for the description to include the file extension
    # supported by the importer (such as "Text Importer (.txt)"), the actual
    # extension is defined in the file_extension method.
    # 
    # _@return_ — description - a brief string description
    # 
    # ```ruby
    # def description
    #   return "Custom Text Importer (*.txt)"
    # end
    # ```
    def description: () -> untyped

    # This method is called by SketchUp when the user clicks on the "Options"
    # button inside the File > Import dialog. You can use it to gather and store
    # settings for your importer.
    # 
    # Only applicable if the importer supports options, meaning its
    # supports_options method returns true.
    # 
    # _@return_ — id - an id string
    # 
    # ```ruby
    # def id
    #   return "com.sketchup.importers.custom_txt"
    # end
    # ```
    def do_options: () -> untyped

    # This method is called by SketchUp to determine a single file extension is
    # associated with your importer. Only files that match this extension will be
    # shown to the user as they browse their harddrive for things to import.
    # 
    # Ruby importers are only allowed to support a single extension.
    # 
    # _@return_ — extension - typically a 3-letter string
    # 
    # ```ruby
    # def file_extension
    #   return "txt"
    # end
    # ```
    def file_extension: () -> untyped

    # This method is called by SketchUp to determine a unique identifier for
    # your importer, typically something like "com.sketchup.importers.dxf".
    # 
    # _@return_ — id - an id string
    # 
    # ```ruby
    # def id
    #   return "com.sketchup.importers.custom_txt"
    # end
    # ```
    def id: () -> untyped

    # This method is called by SketchUp after the user has selected a file to
    # import. This is where you do the real work by opening the file via Ruby's
    # File object and processing it in whatever way you need.
    # 
    # You must return an integer success code to SketchUp when you are done.
    # These are the codes that SketchUp understands:
    # 
    #   - Sketchup::Importer::ImportSuccess
    #   - Sketchup::Importer::ImportFail
    #   - Sketchup::Importer::ImportCanceled - SketchUp will show a "cancelled" dialog
    #   - Sketchup::Importer::ImportFileNotFound - SketchUp will show a "not found" dialog
    # 
    # _@param_ `file_path` — Absolute path to the file the user selected
    # 
    # _@param_ `status` — The status of the import so far. Contains true.
    # 
    # _@return_ — success - an integer status code. See above.
    # 
    # ```ruby
    # def load_file(file_path, status)
    #   # Here is where you would open the file and process it.
    #   puts file_path
    # 
    #   return Sketchup::Importer::ImportSuccess
    # end
    # ```
    def load_file: (untyped file_path, untyped status) -> untyped

    # This method is called by SketchUp to determine if the "Options"
    # button inside the File > Import dialog should be enabled while your
    # importer is selected.
    # 
    # _@return_ — supports_options - a boolean
    # 
    # ```ruby
    # def supports_options?
    #   return true
    # end
    # ```
    def supports_options?: () -> bool
  end

  # The Material class represents a texture or color that can be applied to
  # Drawingelements. It is most often applied to Faces.
  # 
  # You can pass any object that can be used as a material to a method that
  # requires a material. Objects include actual materials, color, and classes
  # that can be converted to a color.
  # 
  # The following are valid (assuming the existence of a Material mat1.)
  # 
  # @example
  #   face.material = mat1
  #   face.material = "red"
  #   face.material = 0xff0000
  # 
  # @version SketchUp 6.0
  class Material < Sketchup::Entity
    include Comparable
    COLORIZE_SHIFT: untyped
    COLORIZE_TINT: untyped
    MATERIAL_COLORIZED_TEXTURED: untyped
    MATERIAL_SOLID: untyped
    MATERIAL_TEXTURED: untyped
    OWNER_IMAGE: untyped
    OWNER_LAYER: untyped
    OWNER_MANAGER: untyped

    # The <=> method is used to compare two materials based on name. The number
    # returned relates to the "string distance" between the names.
    # 
    # _@param_ `material2` — A Material object.
    # 
    # _@return_ — 0 if they are equal, positive number if
    # material1 > material2, negative if material1 < material2
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # m1 = materials.add('Joe')
    # m2 = materials.add('Fred')
    # p m1 <=> m2
    # ```
    def <=>: (Sketchup::Material material2) -> Integer

    # The == method is used to test if two materials are the same.
    # 
    # _@param_ `material2` — A Material object.
    # 
    # _@return_ — true if the materials are the same, false if
    # they are different
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # m1 = materials.add('Joe')
    # m2 = materials.add('Fred')
    # if (m1 == m2)
    #   UI.messagebox('The Materials are equal.')
    # else
    #   UI.messagebox('The Materials are not equal.')
    # end
    # ```
    def ==: (Sketchup::Material material2) -> bool

    # The alpha method is used to get the opacity of the material.
    # 
    # The value will be between 0.0 and 1.0. A value of 0.0 means that the material is
    # completely transparent. A value of 1.0 means that the Material is completely
    # opaque.
    # 
    # _@return_ — a number between 0 and 1
    # 
    # ```ruby
    # alpha_value = Sketchup.active_model.materials[0].alpha
    # ```
    def alpha: () -> Float

    # The alpha= method is used to set the opacity of the material.
    # 
    # The value must be between 0.0 and 1.0. A value of 0.0 means that the material is
    # completely transparent. A value of 1.0 means that the Material is completely
    # opaque.
    # 
    # _@param_ `alpha` — An opacity value.
    # 
    # _@return_ — the newly set opacity value
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # material = materials.add('Joe')
    # material.alpha = 0.5
    # ```
    def alpha=: (Float alpha) -> Float

    # The color method is used to retrieve the color of the material.
    # 
    # If it uses a Texture, this will return the average color.
    # 
    # _@return_ — a Color object
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # material = materials.add('Joe')
    # material.color = 'red'
    # color = material.color
    # ```
    def color: () -> Sketchup::Color

    # The color= method is used to set the color of the material.
    # 
    # If the Material has a texture, then this turns it into a colorized
    # texture.
    # 
    # To reset the color of a Material with a texture, set the color
    # to nil.
    # 
    # _@param_ `color` — A Color object.
    # 
    # _@return_ — the newly set Color object
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # material = materials.add('Joe')
    # material.color = 'red'
    # ```
    def color=: ((Sketchup::Color | String)? color) -> (Sketchup::Color | String)?

    # The colorize_deltas method retrieves the HLS delta for colorized materials.
    # 
    # _@return_ — An array of floats representing the HLS delta.
    # 
    # ```ruby
    # material = Sketchup.active_model.materials[0]
    # h, l, s = material.colorize_deltas
    # ```
    def colorize_deltas: () -> [Float, Float, Float]

    # The colorize_type method retrieves the type of colorization of the material.
    # This value is only relevant when the materialType is set to 2
    # (colorized textured).
    # Types include:
    # 
    #   - 0 = shift (Sketchup::Material::COLORIZE_SHIFT),
    #   - 1 = tint (Sketchup::Material::COLORIZE_TINT),
    # 
    # _@return_ — the colorize type for the Material object.
    # 
    # ```ruby
    # material = Sketchup.active_model.materials[0]
    # type = material.colorize_type
    # ```
    def colorize_type: () -> Integer

    # The colorize_type method set the type of colorization of the material.
    # This value is only relevant when the materialType is set to 2
    # (colorized textured).
    # Types include:
    # 
    #   - 0 = shift (Sketchup::Material::COLORIZE_SHIFT),
    #   - 1 = tint (Sketchup::Material::COLORIZE_TINT),
    # 
    # _@param_ `type` — the new colorize type for the Material object.
    # 
    # _@return_ — the colorize type for the Material object.
    # 
    # ```ruby
    # material = Sketchup.active_model.materials[0]
    # material.colorize_type = Sketchup::Material::COLORIZE_TINT
    # ```
    def colorize_type=: (Integer _type) -> Integer

    # The display_name method retrieves the name that is displayed within SketchUp
    # for the material.
    # 
    # This should be used when presenting the name in the UI, but the returned name
    # cannot be used as a key in model.materials.
    # 
    # _@return_ — the display name for the material
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # material = materials.add('[Joe]')
    # # Use .name for the internal name of a material
    # puts material.name # Outputs "[Joe]"
    # # Use .display_name for presenting the material name
    # # to the UI like SketchUp does.
    # puts material.display_name # Outputs "Joe"
    # ```
    def display_name: () -> String

    # The materialType method retrieves the type of the material. Types include:
    # 
    #   - 0 = solid (Sketchup::Material::MATERIAL_SOLID),
    #   - 1 = textured (Sketchup::Material::MATERIAL_TEXTURED),
    #   - 2 = colorized textured (Sketchup::Material::MATERIAL_COLORIZED_TEXTURED).
    # 
    # The constants where added in SketchUp 2015.
    # 
    # _@return_ — the material type for the Material object. See
    # summary for details.
    # 
    # ```ruby
    # material = Sketchup.active_model.materials[0]
    # type = material.materialType
    # ```
    def materialType: () -> Integer

    # The name method retrieves the name of the material. This is the
    # internal name of the object which should be used for retrieving
    # the material from the model's material list.
    # 
    # Use .display_name to display the name in the UI.
    # 
    # _@return_ — the name of the Material object
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # material = materials.add('[Joe]')
    # # Use .name for the internal name of a material
    # puts material.name # Outputs "[Joe]"
    # # Use .display_name for presenting the material name
    # # to the UI like SketchUp does.
    # puts material.display_name # Outputs "Joe"
    # ```
    def name: () -> String

    # The {#name=} method sets the name of the material.
    # 
    # _@param_ `str` — the new material name
    # 
    # _@return_ — the newly set material name.
    # 
    # Safely change name without raising errors
    # ```ruby
    # materials = Sketchup.active_model.materials
    # material = materials.add("Joe")
    # material.name = materials.unique_name('Jeff')
    # ```
    # 
    # _@note_ — Since SketchUp 2018 this method will raise an `ArgumentError` if the
    # name is not unique.
    # 
    # _@note_ — SketchUp 2018 would raise an error if you named material the name it
    # already had.
    def name=: (String str) -> String

    # The {#owner_type} method is used to determine if the material is owned
    # by a {Sketchup::Materials}.
    # 
    # Returned value is one of:
    # * +Sketchup::Material::OWNER_MANAGER+
    # * +Sketchup::Material::OWNER_IMAGE+
    # * +Sketchup::Material::OWNER_LAYER+
    def owner_type: () -> Integer

    # The {#save_as} method is used to write a material to a SKM file.
    # 
    # You must remember to append ".skm" to the filename as this will not be done
    # automatically.
    # 
    # _@param_ `filename` — the path to the SKM file to load.
    # 
    # _@return_ — `true` if successful
    # 
    # ```ruby
    # filename = File.join(ENV['HOME'], 'Desktop', 'su_test.skm')
    # materials = Sketchup.active_model.materials
    # material = materials.add("Hello World")
    # material.color = 'red'
    # material.save_as(filename)
    # ```
    def save_as: (String filename) -> bool

    # The texture method retrieves the texture of the material.
    # 
    # _@return_ — the Texture object within the Material.
    # Returns nil if the Material does not have a texture.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # material = materials.add('Joe')
    # material.texture = "C:/Materials/Carpet.jpg"
    # texture = material.texture
    # ```
    def texture: () -> Sketchup::Texture?

    # sord infer - inferred type of parameter "arg" as Nilable<Sketchup::Texture> using getter's return type
    # sord omit - no YARD return type given, using untyped
    # The texture= method sets the texture for the material.
    # 
    # Setting the texture to +nil+ will turn it into a solid color
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # material = materials.add('Joe')
    # material.texture = "C:/Materials/Carpet.jpg"
    # ```
    def texture=: (Sketchup::Texture? arg) -> untyped

    # The use_alpha? method tells if the material uses transparency.
    # 
    # Note that this is not affected by the alpha value of the color object. Only
    # the .alpha value and transparent texture will make this method return true.
    # 
    # ```ruby
    # material = Sketchup.active_model.materials[0]
    # is_alpha = material.use_alpha?
    # ```
    def use_alpha?: () -> bool

    # The write_thumbnail method writes a bitmap thumbnail to the given file name.
    # 
    # _@param_ `path` — The file path for the thumbnail.
    # 
    # _@param_ `resolution` — The resolution of the thumbnail.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # model.materials.each { |material|
    #   thumbnail_file = "C:/tmp/materials/#{material.display_name}.png"
    #   material.write_thumbnail(thumbnail_file, 128)
    # }
    # ```
    def write_thumbnail: (String path, Integer resolution) -> bool
  end

  # The UV Helper class contains methods allowing you to determine the location
  # (UV coordinates) of a texture on a face. This class is particularly useful
  # in determining how textures that have been manipulated using the Texture
  # Tweaker should appear when exported to another file type
  # 
  # Use the Face.get_UVHelper method to create a UVHelper for a given face.
  # See the TextureWriter class as well.
  # 
  # @version SketchUp 6.0
  class UVHelper
    # The {#get_back_UVQ} method is used to get the UV texture coordinates on the
    # back of a face.
    # 
    # _@param_ `point` — A point on the face.
    # 
    # _@return_ — Point where X represents U, Y represents V and Z represents Q.
    # 
    # ```ruby
    # uv_helper = face.get_UVHelper(true, true, my_texture_writer)
    # face.outer_loop.vertices.each do |vert|
    #   uvq = uv_helper.get_back_UVQ(vert.position)
    #   # "Normalize" UVQ to UV.
    #   # #x, #y and #z corresponds to U, V and Q respectively,
    #   # as SketchUp re-uses the normal Point3d objects for UVQs
    #   u = uvq.x / uvq.z
    #   v = uvq.y / uvq.z
    #   puts "u=#{u} v=#{v}""
    # end
    # ```
    # 
    # _@note_ — To convert UVQ coordinates to UV,
    # divide U and V by Q.
    #     u = uvq.u / uvq.q
    #     v = uvq.v / uvq.q
    def get_back_UVQ: (Geom::Point3d point) -> Geom::Point3d

    # The {#get_front_UVQ} method is used to get the UV texture coordinates on the
    # front of a face.
    # 
    # _@param_ `point` — A point on the face.
    # 
    # _@return_ — Point where X represents U, Y represents V and Z represents Q.
    # 
    # ```ruby
    # uv_helper = face.get_UVHelper(true, true, my_texture_writer)
    # face.outer_loop.vertices.each do |vert|
    #   uvq = uv_helper.get_front_UVQ(vert.position)
    #   # "Normalize" UVQ to UV.
    #   # #x, #y and #z corresponds to U, V and Q respectively,
    #   # as SketchUp re-uses the normal Point3d objects for UVQs
    #   u = uvq.x / uvq.z
    #   v = uvq.y / uvq.z
    #   puts "u=#{u} v=#{v}""
    # end
    # ```
    # 
    # _@note_ — To convert UVQ coordinates to UV,
    # divide U and V by Q.
    #     u = uvq.u / uvq.q
    #     v = uvq.v / uvq.q
    def get_front_UVQ: (Geom::Point3d point) -> Geom::Point3d
  end

  # The {Sketchup::Animation} interface is implemented to create animations
  # inside SketchUp. At any given time, a single animation can be active on a
  # {Sketchup::View}. To make your own, build a Ruby class that contains the
  # methods described below:
  # 
  #   # This is an example of a simple animation that floats the camera up to
  #   # a z position of 200". The only required method for an animation is
  #   # nextFrame. It is called whenever you need to show the next frame of
  #   # the animation. If nextFrame returns false, the animation will stop.
  #   class FloatUpAnimation
  #     def nextFrame(view)
  #       new_eye = view.camera.eye
  #       new_eye.z = new_eye.z + 1.0
  #       view.camera.set(new_eye, view.camera.target, view.camera.up)
  #       view.show_frame
  #       return new_eye.z < 500.0
  #     end
  #   end
  # 
  #   # This adds an item to the Camera menu to activate our custom animation.
  #   UI.menu("Camera").add_item("Run Float Up Animation") {
  #     Sketchup.active_model.active_view.animation = FloatUpAnimation.new
  #   }
  # 
  # {Sketchup::Animation} objects are activated by using the
  # {Sketchup::View#animation=} method on a {Sketchup::View}
  # object. To stop an animation set the view's animation object to +nil+, like
  # so:
  # 
  #   Sketchup.active_model.active_view.animation = nil
  # 
  # @abstract Implement the methods described in this class to create a an
  #   animation. You can not sub-class this class because it is not defined by
  #   the API.
  # 
  # @version SketchUp 6.0
  class Animation
    # The {#nextFrame} method is invoked by SketchUp to tell the animation to
    # display its next frame. This method should set up the camera and then call
    # {Sketchup::View#show_frame}.
    # 
    # The {#nextFrame} method is the only required method of the
    # {Sketchup::Animation} interface that you must implement.
    # 
    # _@param_ `view` — The view for the animation.
    # 
    # _@return_ — continue - +true+ if you want the animation to continue
    # on to the next frame, +false+ if you want the animation
    # to stop after this frame.
    # 
    # ```ruby
    # def nextFrame(view)
    #   # Insert your handler code for updating the camera or other entities.
    #   view.show_frame
    #   return true
    # end
    # ```
    def nextFrame: (Sketchup::View view) -> bool

    # The {#pause} method is invoked by SketchUp when the animation is paused.
    # 
    # This method is optional (you do not need to implement this method unless you
    # want to perform some specialized function when the animation is paused). You
    # cannot call this method in your code explicitly and expect an animation to
    # pause, only certain SketchUp events cause the method to be called.
    # 
    # ```ruby
    # def pause
    #   # Insert handler code for whatever you need to do when it is paused.
    # end
    # ```
    # 
    # _@note_ — The user interface for pausing and resuming animations isn't integrated
    # with the Ruby API in the current version, so this method is probably not
    # useful to you.
    def pause: () -> void

    # The {#resume} method is invoked by SketchUp when the animation is resumed
    # after being paused.
    # 
    # This method is optional (you do not need to implement this method unless you
    # want to perform some specialized function when the animation is resumed).
    # You cannot call this method in your code explicitly and expect an animation
    # to stop, only certain SketchUp events cause the method to be called.
    # 
    # ```ruby
    # def resume
    #   # Insert your handler code for whatever you need to do as you resume.
    # end
    # ```
    # 
    # _@note_ — The user interface for pausing and resuming animations isn't integrated
    # with the Ruby API in the current version, so this method is probably not
    # useful to you.
    def resume: () -> void

    # The {#stop} method is invoked by SketchUp when the animation is stopped.
    # 
    # This method is optional (you do not need to implement this method unless you
    # want to perform some specialized function when the animation is stopped). You
    # cannot call this method in your code explicitly and expect an animation to
    # stop, only certain SketchUp events cause the method to be called.
    # 
    # Perhaps the most common way for this method to be called is when your Ruby
    # code sets {Sketchup::View#animation=} to +nil+. See the class comments for
    # an example of this.
    # 
    # ```ruby
    # class MyAnimation
    #   def stop
    #     # Insert your handler code for cleaning up after your animation.
    #   end
    # end
    # ```
    # 
    # _@note_ — Do not call {#Sketchup::View#animation=} from this method. This will
    # cause a recursive loop and crash SketchUp 2017 and earlier versions.
    # As of SketchUp 2018 this will raise a +RunTimeError+.
    def stop: () -> void
  end

  # The Dimension class provides base functionality for classes DimensionLinear
  # and DimensionRadial. It's not instantiable.
  # 
  # @version SketchUp 2014
  class Dimension < Sketchup::Drawingelement
    ARROW_CLOSED: untyped
    ARROW_DOT: untyped
    ARROW_NONE: untyped
    ARROW_OPEN: untyped
    ARROW_SLASH: untyped

    # The add_observer method is used to add a DimensionObserver to the dimension.
    # 
    # _@param_ `observer` — A DimensionObserver.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # observer = MyDimObserver.new
    # dim = Sketchup.active_model.entities.add_dimension_linear([50, 10, 0],
    #       [100, 10, 0], [0, 20, 0])
    # status = dim.add_observer(observer)
    # ```
    # 
    # _@note_ — If the given observer responds to +onTextChanged+, it will be
    # added as a {Sketchup::DimensionObserver}. If not, the base
    # {Sketchup::Entity#add_observer} will be called.
    def add_observer: (untyped observer) -> untyped

    # The arrow_type method retrieves the current arrow type of the dimension.
    # Valid arrow types are class constants:
    # - +Dimension::ARROW_NONE,+
    # - +Dimension::ARROW_SLASH+
    # - +Dimension::ARROW_DOT+
    # - +Dimension::ARROW_CLOSED+
    # - +Dimension::ARROW_OPEN+
    # 
    # _@return_ — a numerical representation of the arrow type
    # 
    # ```ruby
    # type = dim.arrow_type
    # if type == Sketchup::Dimension::ARROW_CLOSED
    #   puts "Arrow type is closed"
    # end
    # ```
    def arrow_type: () -> untyped

    # The arrow_type= method sets the arrow type of the dimension.
    # Valid arrow types are class constants:
    # - +Dimension::ARROW_NONE,+
    # - +Dimension::ARROW_SLASH+
    # - +Dimension::ARROW_DOT+
    # - +Dimension::ARROW_CLOSED+
    # - +Dimension::ARROW_OPEN+
    # 
    # _@param_ `type` — a numerical representation of the arrow type.
    # 
    # _@return_ — the arrow type that was set.
    # 
    # ```ruby
    # dim.arrow_type = Sketchup::Dimension::ARROW_CLOSED
    # ```
    def arrow_type=: (untyped _type) -> untyped

    # The has_aligned_text= method accepts true or false indicating whether the
    # dimension's text is aligned to the dimension or to the screen.
    # 
    # _@param_ `value`
    # 
    # _@return_ — the alignment flag that was set
    # 
    # ```ruby
    # dim.has_aligned_text = true
    # ```
    def has_aligned_text=: (bool value) -> untyped

    # The has_aligned_text method is used to determine whether the dimension's text
    # is aligned to the dimension or to the screen.
    # 
    # _@return_ — status - true if text is aligned to the dimension.
    # False if dimension text is aligned to the screen.
    # 
    # ```ruby
    # aligned = dim.has_aligned_text?
    # ```
    def has_aligned_text?: () -> bool

    # The plane method is used to retrieve the plane of the dimension. Refer to the
    # Geom module for information on how planes are represented.
    # 
    # _@return_ — the plane of the dimension
    # 
    # ```ruby
    # plane = dim.plane
    # ```
    def plane: () -> untyped

    # The remove_observer method is used to remove a DimensionObserver from the
    # dimension. Note that, if the given observer responds to 'onTextChanged', it
    # will be removed as a DimensionObserver. If not, the base
    # Entity.remove_observer will be called.
    # 
    # _@param_ `observer` — A DimensionObserver.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # observer = MyDimObserver.new
    # dim = Sketchup.active_model.entities.add_dimension_linear([50, 10, 0],
    #       [100, 10, 0], [0, 20, 0])
    # status = dim.add_observer(observer)
    # status = dim.remove_observer(observer)
    # ```
    def remove_observer: (untyped observer) -> untyped

    # The text method is used to retrieve the dimension text.
    # 
    # _@return_ — the dimension text
    # 
    # ```ruby
    # dimtext = dim.text
    # ```
    def text: () -> untyped

    # The text= method is used to set an override on the dimension text.
    # 
    # _@param_ `text`
    # 
    # _@return_ — the newly set text override
    # 
    # ```ruby
    # dim.text= "text"
    # ```
    def text=: (String text) -> untyped
  end

  # The +Sketchup::Licensing+ module contains methods for
  # extensions purchased from Extension Warehouse to check their licensing status.
  # 
  # It is advised to place these calls inside encrypted Ruby (.rbe) files. This
  # API is also exposed via the SketchUp C API. Extensions that already use
  # native code should prefer using the native API, which should be more secure
  # than their Ruby API counterparts.
  # 
  # For more details, see
  # {Licensing Example}[https://github.com/SketchUp/sketchup-ruby-api-tutorials/tree/main/examples/99_license]
  # 
  # @version SketchUp 2015
  module Licensing
    EXPIRED: untyped
    LICENSED: untyped
    NOT_LICENSED: untyped
    TRIAL: untyped
    TRIAL_EXPIRED: untyped

    # Acquires a license for a given extension.
    # 
    # _@param_ `extension_id` — The Extension Warehouse UUID for the desired extension.
    # 
    # _@return_ — An object representing
    # licensing state for the extension. Do not store this object, retrieve
    # it again when needed since licensing state may have changed.
    # 
    # ```ruby
    # ext_id = "4e215280-dd23-40c4-babb-b8a8dd29d5ee"
    # ext_lic = Sketchup::Licensing.get_extension_license(ext_id)
    # if ext_lic.licensed?
    #    puts "Extension is licensed."
    # end
    # ```
    def self.get_extension_license: (String extension_id) -> ExtensionLicense

    # The Sketchup::Licensing::ExtensionLicense class is used to store extension
    # license information. An instance of this class is returned by
    # Sketchup::Licensing.get_extension_license. Note that this is a temporary
    # object representing the extension licensing state for the moment it was
    # returned. It will not reflect any licensing state changes that may occur.
    # 
    # @version SketchUp 2015
    class ExtensionLicense
      # The days_remaining method is used to get the number of days remaining until
      # license expiration.
      # 
      # _@return_ — Integer - Number of days until license expiration. Zero
      # if a permanent license or not licensed.
      # 
      # ```ruby
      # ext_id = "4e215280-dd23-40c4-babb-b8a8dd29d5ee"
      # ext_lic = Sketchup::Licensing.get_extension_license(ext_id)
      # if ext_lic.days_remaining != 0
      #    puts "The license will expire in #{ext_lic.days_remaining} days."
      # end
      # ```
      def days_remaining: () -> untyped

      # The error_description method is used to obtain error information in case of
      # failure to acquire a license. This is meant to aid in debugging only.
      # Extensions should not rely on any exact error description.
      # 
      # _@return_ — String - error description.
      # 
      # ```ruby
      # ext_id = "4e215280-dd23-40c4-babb-b8a8dd29d5ee"
      # ext_lic = Sketchup::Licensing.get_extension_license(ext_id)
      # if !ext_lic.licensed?
      #    puts ext_lic.error_description
      # end
      # ```
      def error_description: () -> untyped

      # The licensed? method is used to decide whether the extension is licensed to
      # run or not.
      # 
      # _@return_ — Boolean - true if the extension is allowed to run, false
      # if it is not licensed and should quit.
      # 
      # ```ruby
      # ext_id = "4e215280-dd23-40c4-babb-b8a8dd29d5ee"
      # ext_lic = Sketchup::Licensing.get_extension_license(ext_id)
      # if ext_lic.licensed?
      #    puts "Extension is licensed."
      # end
      # ```
      def licensed?: () -> bool

      # The state method returns a constant indicating the specific licensing state.
      # These should be used for informational purposes only and not to decide if
      # the extension is licensed to run. For that, please use the licensed? method.
      # 
      # _@return_ — Integer - One of Sketchup::Licensing::LICENSED,
      # Sketchup::Licensing::EXPIRED, Sketchup::Licensing::TRIAL,
      # Sketchup::Licensing::TRIAL_EXPIRED,
      # Sketchup::Licensing::NOT_LICENSED
      # 
      # ```ruby
      # ext_id = "4e215280-dd23-40c4-babb-b8a8dd29d5ee"
      # ext_lic = Sketchup::Licensing.get_extension_license(ext_id)
      # if ext_lic.state == Sketchup::Licensing::TRIAL_EXPIRED
      #    puts "Trial period has expired."
      # end
      # ```
      def state: () -> untyped
    end
  end

  # This provides a way for SketchUp to customize a line style and be set on a
  # layer.
  # 
  # @version SketchUp 2019
  class LineStyle < Sketchup::Entity
    # The {#name} method retrieves the name of the line style object.
    # 
    # _@return_ — The name of the line style.
    # 
    # ```ruby
    # line_style = Sketchup.active_model.line_styles["Solid Basic"]
    # line_style.name # returns "Solid Basic"
    # ```
    def name: () -> String
  end

  # A collection of Materials objects. Each model contains a Materials collection
  # that can be accessed via Model.materials.
  # 
  # @example
  #   # Get a handle to all the materials in the current model.
  #   model = Sketchup.active_model
  #   materials = model.materials
  # 
  # @version SketchUp 6.0
  class Materials < Sketchup::Entity
    include Enumerable[Sketchup::Material]

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#[]} method is used to retrieve a material by index or name.
    # 
    # The {#at} method is an alias of {#[]}
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # material = materials[0]
    # ```
    def []: (untyped arg) -> untyped

    # Add a new Material.  When called with no arguments, this will generate a
    # new unique name for the new Material.  If a name is given, it will check
    # to see if there is already a material with that name.  If there is already
    # a material with the given name, then a new unique name is generated using
    # the given name as a base.
    # 
    # _@param_ `name` — The name of the new material.
    # 
    # _@return_ — a Material object
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # material = materials.add('Joe')
    # ```
    def add: (String name) -> Sketchup::Material

    # The add_observer method is used to add an observer to the materials
    # collection.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # materials = Sketchup.active_model.materials
    # status = materials.add_observer(observer)
    # ```
    def add_observer: (Object observer) -> bool

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#[]} method is used to retrieve a material by index or name.
    # 
    # The {#at} method is an alias of {#[]}
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # material = materials[0]
    # ```
    def at: (untyped arg) -> untyped

    # ```ruby
    # materials = Sketchup.active_model.materials
    # count = materials.count
    # ```
    # 
    # _@note_ — Since SketchUp 2014 the count method is inherited from Ruby's
    # +Enumerable+ mix-in module. Prior to that the {#count} method is an alias
    # for {#length}.
    # 
    # _@see_ `#length`
    def count: () -> Integer

    # The current method is used to get the current material, i.e. the material
    # that the user has selected in the Materials dialog.
    # 
    # _@return_ — a Material object.
    # 
    # ```ruby
    # current = Sketchup.active_model.materials.current
    # ```
    def current: () -> Sketchup::Material

    # The current= method is used to set the current material.
    # 
    # _@param_ `material` — A Material object.
    # 
    # ```ruby
    # # Make the first material in the model "current"
    # materials = Sketchup.active_model.materials
    # materials.current = materials[0]
    # ```
    def current=: (Sketchup::Material material) -> Sketchup::Material

    # The {#each} method is used to iterate through all of the materials.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # model.materials.each { |material|
    #   puts material.display_name
    # }
    # ```
    # 
    # _@note_ — Don't remove content from this collection while iterating over it with
    # {#each}. This would change the size of the collection and cause elements to
    # be skipped as the indices change. Instead copy the current collection to an
    # array using +to_a+ and then use +each+ on the array, when removing content.
    def each: () ?{ (Material) -> void } -> void

    # The number of materials in the collection.
    # 
    # ```ruby
    # materials = Sketchup.active_model.materials
    # number = materials.length
    # ```
    # 
    # _@note_ — The returned number includes {Sketchup::Image} materials as well.
    # It will not reflect the number of materials yielded by {#each}. To get
    # the number of non-image materials use {#count} or +materials.to_a.size+.
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The {#load} method is used to load a material from file into the model.
    # 
    # If a matching material exist in the model it will be returned instead.
    # 
    # _@param_ `filename` — the path to the SKM file to load.
    # 
    # _@return_ — the new loaded material, or existing material.
    # 
    # ```ruby
    # # Load a material from the shipped SketchUp library. (SketchUp 2016)
    # filename = 'Materials/Brick, Cladding and Siding/Cinder Block.skm'
    # path = Sketchup.find_support_file(filename)
    # materials = Sketchup.active_model.materials
    # material = materials.load(path)
    # ```
    def load: (String filename) -> Sketchup::Material

    # The purge_unused method is used to remove unused materials.
    # 
    # _@return_ — The Materials object.
    # 
    # ```ruby
    # materials = Sketchup.active_model.materials
    # materials.purge_unused
    # ```
    def purge_unused: () -> Sketchup::Materials

    # Remove a given material.
    # 
    # NOTE: On SketchUp versions prior to 2014 there is a bug in this method that
    # could potentially lead to file corruption. If you call Materials.remove on a
    # material that is painted onto any entity in the active model (e.g. faces,
    # edges, groups, ...), then calling this method will not successfully unpaint
    # the entity and remove the material from the model.
    # You must first unpaint all of the entities that respond to .material
    # and .back_material before calling Materials.remove.
    # 
    # _@param_ `material` — The material to remove.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # if entity.respond_to?(:material) do
    #   if entity.material.equal?(material_to_remove) do
    #     entity.material = nil
    #   end
    # end
    # # for entities that have a back material
    # if entity.respond_to?(:back_material) do
    #   if entity.back_material.equal?(material_to_remove) do
    #     entity.back_material = nil
    #   end
    # end
    # ```
    # 
    # ```ruby
    # model = Sketchup.active_model
    # materials = model.materials
    # material = materials.add('Joe')
    # materials.remove(material)
    # ```
    def remove: (Sketchup::Material material) -> bool

    # The remove_observer method is used to remove an observer from the materials
    # collection.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # materials = Sketchup.active_model.materials
    # status = materials.remove_observer(observer)
    # ```
    def remove_observer: (Object observer) -> bool

    # The number of materials in the collection.
    # 
    # The {#size} method is an alias for {#length}.
    # 
    # ```ruby
    # materials = Sketchup.active_model.materials
    # number = materials.size
    # ```
    # 
    # _@note_ — The returned number includes {Sketchup::Image} materials as well.
    # It will not reflect the number of materials yielded by {#each}. To get
    # the number of non-image materials use {#count} or +materials.to_a.size+.
    # 
    # _@see_ `#length`
    def size: () -> Integer

    # The {#unique_name} method is used to retrieve a unique name from the
    # materials collection that is based on the provided one. If provided name is
    # unique it will be returned, otherwise any trailing indices will be replaced
    # by a new index.
    # 
    # _@param_ `name` — the suggested name.
    # 
    # _@return_ — a unique name.
    # 
    # ```ruby
    # materials = Sketchup.active_model.materials
    # unique_name = materials.unique_name("test_name")
    # ```
    def unique_name: (String name) -> String
  end

  # A set of the currently selected entities. Use the Model.selection method
  # to get a Selection object.  Note that the order of entities
  # (<code>selection[0]</code>, <code>selection[1]</code> and so on) in the set
  # is in no particular order and should not be assumed to be in the same order
  # as the user selected the entities.
  # 
  # @example
  #   # Get a handle to the selection set.
  #   model = Sketchup.active_model
  #   selection = model.selection
  # 
  # @version SketchUp 6.0
  class Selection
    include Enumerable[Sketchup::Entity]

    # The {#[]} method is used to retrieve an {Sketchup::Entity} from the selection
    # by index. Index 0 is the first entity in the selection.
    # 
    # This method is not very efficient. If you need to look at every entity in
    # the selection, consider using {#each} instead of using this method
    # to manually grab each one.
    # 
    # _@param_ `index` — The index of the Entity object to retrieve.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # selection = model.selection
    # selection.add(entities.to_a)
    # p selection[0]
    # ```
    # 
    # _@see_ `#at`
    def []: (Integer index) -> Sketchup::Entity?

    # sord omit - no YARD type given for "*args", using untyped
    # The add method is used to add entities to the selection.  Entities that are
    # added to the Selection are visually indicated by the selection bounding box.
    # 
    # You can pass it individual Entities or an Array of Entities:
    # Note that the add, remove, and toggle methods are all aliases for one
    # another. So if you call remove on an entity that is not selected, it will
    # be toggled to be selected, not removed! Be cautious when writing your code to
    # not make the assumption about the currently selected state of a given entity.
    # 
    # _@return_ — the number of Entity objects added
    # 
    # ```ruby
    # # Add by listing the entities...
    # ss.add(e1, e2, e3)
    # 
    # # ...or add by passing an Array of entities.
    # ss.add([e1, e2, e3])
    # ```
    # 
    # ```ruby
    # entities = model.active_entities
    # entity = entities[0]
    # status = selection.add entity
    # ```
    def add: (*untyped args) -> Integer

    # The add_observer method is used to add an observer to the selection object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # selection = Sketchup.active_model.selection
    # status = selection.add_observer observer
    # ```
    def add_observer: (Object observer) -> bool

    # The {#at} method is an alias for {#[]}.
    # 
    # _@param_ `index` — The index of the Entity object to retrieve.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # selection = model.selection
    # selection.add(entities.to_a)
    # p selection.at(0)
    # ```
    # 
    # _@see_ `#[]`
    def at: (Integer index) -> Sketchup::Entity?

    # The clear method is used to clear the selection.
    # 
    # ```ruby
    # entity = entities[0]
    # selection.add entity
    # UI.messagebox "Ready to Clear"
    # selection.clear
    # ```
    def clear: () -> void

    # The {contains?} method is and alias of {#include?}.
    # 
    # _@param_ `entity`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entity = model.active_entities.first
    # selection = model.selection
    # selection.add(entity)
    # p selection.contains?(entity)
    # ```
    # 
    # _@see_ `#include?`
    def contains?: (Sketchup::Entity entity) -> bool

    # ```ruby
    # selection = Sketchup.active_model.selection
    # number = selection.count
    # ```
    # 
    # _@note_ — Since SketchUp 2014 the count method is inherited from Ruby's
    # +Enumerable+ mix-in module. Prior to that the {#count} method is an alias
    # for {#length}.
    # 
    # _@see_ `#length`
    def count: () -> Integer

    # The each method is used to iterate through all of the selected entities.
    # 
    # If you want to do something with all of the selected Entities, this is more
    # efficient than using [].
    # 
    # ```ruby
    # selection.each { |entity| puts entity }
    # ```
    # 
    # _@note_ — Don't remove content from this collection while iterating over it with
    # {#each}. This would change the size of the collection and cause elemnts to
    # be skipped as the indices change. Instead copy the current collection to an
    # array using +to_a+ and then use +each+ on the array, when removing content.
    def each: () ?{ (Sketchup::Entity) -> void } -> void

    # The empty? method is used to determine if there are entities in the
    # selection.
    # 
    # ```ruby
    # status = selection.add entity
    # status = selection.empty
    # ```
    def empty?: () -> bool

    # The first method is used to retrieve the first selected entity
    # 
    # Returns nil if nothing is selected. This method is useful when you know that
    # only a single entity is selected, or you are only interested in the first
    # selected entity.
    # 
    # _@return_ — the first selected Entity object if successful
    # 
    # ```ruby
    # status = selection.add entity
    # entity = selection.first
    # ```
    def first: () -> Sketchup::Entity

    # The {include?} method is used to determine if a given {Sketchup::Entity} is
    # in the selection.
    # 
    # _@param_ `entity`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entity = model.active_entities.first
    # selection = model.selection
    # selection.add(entity)
    # p selection.include?(entity)
    # ```
    # 
    # _@see_ `#contains?`
    def include?: (Sketchup::Entity entity) -> bool

    # The {#invert} method is used to invert the selection.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # selection = model.selection
    # # Create a cube
    # face = entities.add_face([0, 0, 0], [9, 0, 0], [9, 9, 0], [0, 9, 0])
    # face.pushpull(-9)
    # # Add the first two faces to the selection
    # faces = entities.grep(Sketchup::Face).take(2)
    # selection.add(faces)
    # # Invert selection
    # selection.invert
    # ```
    def invert: () -> void

    # The is_curve? method is used to determine if the selection contains all
    # edges that belong to a single curve.
    # 
    # ```ruby
    # selection.add entity
    # status = selection.is_curve?
    # ```
    def is_curve?: () -> bool

    # The is_surface? method is used to determine if the selection contains only
    # all of the faces that are part of a single curved surface.
    # 
    # ```ruby
    # selection.add entity
    # status = selection.is_surface
    # ```
    def is_surface?: () -> bool

    # The {#length} method is used to retrieve the number of selected entities.
    # 
    # ```ruby
    # selection = Sketchup.active_model.selection
    # number = selection.length
    # ```
    # 
    # _@see_ `#size`
    # 
    # _@see_ `#nitems`
    def length: () -> Integer

    # The model method retrieves the model for the selection.
    # 
    # _@return_ — the model that includes the selection if
    # successful
    # 
    # ```ruby
    # model = selection.model
    # ```
    def model: () -> Sketchup::Model

    # The {#nitems} method is an alias for {#length}.
    # 
    # ```ruby
    # selection = Sketchup.active_model.selection
    # number = selection.nitems
    # ```
    # 
    # _@see_ `#length`
    def nitems: () -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # The remove method is used to remove entities from the selection.
    # 
    # You can pass it individual Entities or an Array of Entities:
    # Note that the add, remove, and toggle methods are all aliases for one
    # another. So if you call remove on an entity that is not selected, it will
    # be toggled to be selected, not removed! Be cautious when writing your code to
    # not make the assumption about the currently selected state of a given entity.
    # 
    # _@return_ — the number of Entity objects removed
    # 
    # ```ruby
    # # Remove by listing the entities...
    # ss.remove(e1, e2, e3)
    # 
    # # ...or remove by passing an Array of entities.
    # ss.remove([e1, e2, e3])
    # ```
    # 
    # ```ruby
    # entities = model.active_entities
    # entity = entities[0]
    # status = selection.add entity
    # ```
    def remove: (*untyped args) -> Integer

    # The remove_observer method is used to remove an observer from the selection
    # object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # selection = Sketchup.active_model.selection
    # status = object.remove_observer observer
    # ```
    def remove_observer: (Object observer) -> bool

    # The shift method is used to remove the first entity from the selection and
    # returns it.
    # 
    # _@return_ — the first Entity object in the selection set
    # if successful
    # 
    # ```ruby
    # status = selection.add entity
    # UI.messagebox "Ready to remove item from selection set"
    # entity = selection.shift
    # ```
    def shift: () -> Sketchup::Entity

    # The single_object? method is used to determine if the selection contains a
    # single object.
    # 
    # It can either be a single Entity or a group of Entities for which is_curve?
    # or is_surface? will return true.
    # 
    # ```ruby
    # status = selection.single_object
    # ```
    def single_object?: () -> bool

    # The {#size} method is an alias for {#length}.
    # 
    # ```ruby
    # selection = Sketchup.active_model.selection
    # number = selection.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # The toggle method is used to change whether an entity is part of the
    # selection. Entities that are not already selected
    # are added. Entities that are already selected are removed.
    # 
    # You can pass it individual Entities or an Array of Entities:
    # Note that the add, remove, and toggle methods are all aliases for one
    # another. So if you call remove on an entity that is not selected, it will
    # be toggled to be selected, not removed! Be cautious when writing your code to
    # not make the assumption about the currently selected state of a given entity.
    # 
    # _@return_ — the number of Entity objects changed
    # 
    # ```ruby
    # # Toggle by listing the entities...
    # ss.toggle(e1, e2, e3)
    # 
    # # ...or toggle by passing an Array of entities.
    # ss.toggle([e1, e2, e3])
    # ```
    # 
    # ```ruby
    # entities = model.active_entities
    # entity = entities[0]
    # status = selection.add entity
    # ```
    def toggle: (*untyped args) -> Integer
  end

  # The {Sketchup::InputPoint} class is used to pick 3d points and/or entities
  # that reside under the current cursor location, similar to native Line tool
  # and other drawing tools. Unlike {Sketchup::PickHelper},
  # {Sketchup::InputPoint} uses inference, i.e. "snaps" to vertices and other
  # entities when the cursor is close to them.
  # 
  # Only {Sketchup::Tool}s react to cursor location and most of these methods are
  # only useful in the context of a tool. For example, if you want to determine
  # the 3d point you just moved the cursor over, you would use
  # {#pick} from within your {Sketchup::Tool#onMouseMove} method.
  # {Sketchup::InputPoints} are best picked from mouse move, as you want them to
  # draw them to the view.
  # 
  # For an example, see
  # {Tool
  # Example}[https://github.com/SketchUp/sketchup-ruby-api-tutorials/tree/main/examples/02_custom_tool].
  # 
  # To lock inference similar to native SketchUp tools, see
  # {View#lock_inference}.
  # 
  # @version SketchUp 6.0
  class InputPoint
    # The == method is used to determine if two input points are the same.
    # 
    # _@param_ `inputpoint2` — The second input point in the comparison.
    # 
    # _@return_ — status - true if the InputPoint objects are the same
    # object. False if the objects are not the same.
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip1 = Sketchup::InputPoint.new
    # ip2 = view.inputpoint x,y
    # # Copy the contents of inputpoint2 into inputpoint1
    # ip1.copy! ip2
    # # Returns true
    # status = ip1 == ip2
    # ```
    def ==: (untyped inputpoint2) -> untyped

    # The clear method is used to clear the input point.
    # 
    # This sets it to an empty state. After calling this, valid? will return
    # false.
    # 
    # _@return_ — inputpoint - the cleared (empty) input point if this
    # successful
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip1 = view.inputpoint x,y
    # # Returns true
    # ip = ip1.clear
    # ```
    def clear: () -> untyped

    # The copy! method is used to copy the data from a second input point into
    # this input point.
    # 
    # _@param_ `inputpoint` — The second input point.
    # 
    # _@return_ — inputpoint - the new input point that received the copy
    # if successful
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip1 = Sketchup::InputPoint.new
    # ip2 = view.inputpoint x,y
    # # Copy the contents of inputpoint2 into inputpoint1
    # ip = ip1.copy! ip2
    # ```
    def copy!: (untyped inputpoint) -> untyped

    # The degrees_of_freedom method retrieves the number of degrees of freedom
    # there are for an input point.
    # 
    # If you are just getting a point in space, then the degrees_of_freedom will
    # be 3 - meaning that there is nothing about the point that would constrain
    # its position.
    # 
    # If you are on a face, then the degrees_of_freedom will be 2
    # meaning that you can only move on the plane of the face.
    # 
    # If you are on an Edge or an axis, then the degrees_of_freedom will be 1
    # meaning that you can only move in the direction of the edge or axis.
    # 
    # If you get an end point of an Edge, or an intersection point, then the
    # degrees_of_freedom will be 0.
    # 
    # _@return_ — degrees_of_freedom - see comments.
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip1 = view.inputpoint x,y
    # dof = ip1.degrees_of_freedom
    # ```
    def degrees_of_freedom: () -> untyped

    # The depth method retrieves the depth of an inference if it is coming from a
    # component.
    # 
    # If the InputPoint is not getting a position from inside a component, this
    # method will return 0. Otherwise it returns the depth of the entity in a
    # nested component that is providing the position.
    # 
    # _@return_ — depth - a number representing the depth of the
    # inputpoint (inside groups and components) if successful
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip1 = view.inputpoint x,y
    # d = ip1.depth
    # ```
    def depth: () -> untyped

    # The display? method is used to determine if the input point has anything to
    # draw.
    # 
    # If the method returns true, then the draw method will draw something.
    # 
    # _@return_ — status - true if the draw method will draw something,
    # false if the draw method has nothing to draw
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip1 = view.inputpoint x,y
    # status = ip1.display
    # ```
    def display?: () -> bool

    # The draw method is used to draw the input point.
    # 
    # This is useful for showing an InputPoint from within the draw method of a
    # tool that you have implemented in Ruby. Additional examples are available in
    # the Plugins/examples directory.
    # 
    # _@param_ `view` — The current view.
    # 
    # _@return_ — view
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip1 = view.inputpoint x,y
    # ip = ip1.draw view
    # ```
    def draw: (untyped view) -> untyped

    # The edge method is used to retrieve the edge if the input point is getting
    # its position from a point on an Edge.
    # 
    # _@return_ — edge - an Edge object if successful, or nil if
    # unsuccessful
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip1 = view.inputpoint x,y
    # e = ip1.edge
    # ```
    def edge: () -> untyped

    # The face method retrieves the face at or behind the input point. This can be
    # used to determine a plane, similar to what native Rotate tool does.
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip1 = view.inputpoint x,y
    # f = ip1.face
    # ```
    # 
    # _@note_ — The InputPoint doesn't necessarily lie on the face, but can be e.g. on
    # an edge in front of the face.
    def face: () -> Sketchup::Face?

    # sord omit - no YARD type given for "*args", using untyped
    # The new method is used to create a new InputPoint object.
    # 
    # ```ruby
    # ip1 = Sketchup::InputPoint.new
    # 
    # # Or you can construct it at an arbitrary location.
    # starting_point = Geom::Point3d.new(100, 200, 300)
    # ip2 = Sketchup::InputPoint.new(starting_point)
    # ```
    # 
    # _@note_ — Prior to SketchUp 2019 it was not possible to
    # sub-class {Sketchup::InputPoint} due to a bug in how SketchUp initialized
    # the class.
    def initialize: (*untyped args) -> void

    # The {#instance_path} method retrieves the instance path for the picked point.
    # 
    # The returned instance_path is a copy of what the input point is holding on to
    # at the moment you access it. Your copy will not update if you make new picks
    # with the input point.
    # 
    # If there has been no valid pick it will return `nil`.
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip = view.inputpoint(x, y)
    # instance_path = ip.instance_path
    # ```
    def instance_path: () -> Sketchup::InstancePath?

    # The pick method is used to get the input point at a specific screen
    # position.
    # 
    # The first form just uses the screen position to compute the InputPoint. It
    # is used when you don't want the InputPoint to be dependent on another
    # InputPoint.
    # 
    # The second form uses the screen position and another InputPoint. It will
    # find additional inferences such as along one of the axis directions from the
    # first point.
    # 
    # _@param_ `view` — The current view.
    # 
    # _@param_ `x` — A x value.
    # 
    # _@param_ `y` — A y value.
    # 
    # _@param_ `inputpoint` — A second input point used as a reference for the pick.
    # 
    # _@return_ — status - true if a valid InputPoint was picked and it
    # is different than it was before.
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # inputpoint = view.inputpoint x, y
    # inputpoint2 = Sketchup::InputPoint.new
    # inputpoint.pick view, x, y
    # inputpoint.pick view, x, y, inputpoint2
    # ```
    def pick: (
                untyped view,
                untyped x,
                untyped y,
                ?untyped inputpoint
              ) -> untyped

    # The position method is used to get the 3D point from the input point.
    # 
    # _@return_ — point - a Point3d object position for the input point
    # if successful
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip1 = view.inputpoint x,y
    # point = ip1.position
    # ```
    def position: () -> untyped

    # The tooltip method is used to retrieve the string that is the tool tip to
    # display for the input point.
    # 
    # _@return_ — tip - a string tooltip or an empty string (if the input
    # point doesn't provide a tooltip).
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip1 = view.inputpoint x,y
    # # Click on a face and you get "On Face"
    # tip = ip1.tooltip
    # ```
    def tooltip: () -> untyped

    # The transformation method retrieves the Transformation object for the input
    # point.
    # 
    # If the InputPoint object is getting its position from something inside of a
    # component instance, this method returns the Transformation of the component
    # instance. Otherwise it returns the identity Transformation.
    # 
    # Note that the position method on a input point always returns a point that is
    # transformed into model space. If you are using the edge, face or vertex
    # method on the InputPoint though, you will probably need to use the
    # transformation method to transform the data that you get back from the
    # selected entity.
    # 
    # _@return_ — transformation - the Transformation for the input point
    # if successful
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip1 = view.inputpoint x,y
    # # In this case, returning the identity transformation
    # tform = ip1.transformation
    # ```
    def transformation: () -> untyped

    # The valid? method is used to determine if an input point has valid data.
    # 
    # You must have called the pick method to set the data before it is valid.
    # 
    # _@return_ — status - true if the input point has valid data, false
    # if it does not have valid data.
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip1 = view.inputpoint x,y
    # status = ip1.valid?
    # ```
    def valid?: () -> bool

    # The vertex method returns a Vertex associated with the InputPoint. If the
    # InputPoint is on the end of a line, then it will return the Vertex. If the
    # InputPoint does not select any vertices this method returns nil.
    # 
    # _@return_ — vertex - The associated vertex
    # 
    # ```ruby
    # view = Sketchup.active_model.active_view
    # x = 100
    # y = 100
    # ip1 = view.inputpoint x,y
    # # Click on a face and you get "On Face"
    # tip = ip1.vertex
    # ```
    def vertex: () -> untyped
  end

  # Provides access to the different line style objects in the model.
  # 
  # @version SketchUp 2019
  class LineStyles < Sketchup::Entity
    include Enumerable[LineStyle]

    # sord omit - no YARD type given for "arg", using untyped
    # The {#[]} method lets you retrieve a line style by name or index.
    # 
    # The {#at} method is an alias of {#[]}.
    # 
    # _@return_ — The line style retrieved. Nil if the name
    # couldn't be retrived.
    # 
    # ```ruby
    # solid_style = Sketchup.active_model.line_styles["Solid Basic"]
    # line_style = Sketchup.active_model.line_styles[1]
    # ```
    def []: (untyped arg) -> Sketchup::LineStyle?

    # sord omit - no YARD type given for "arg", using untyped
    # The {#[]} method lets you retrieve a line style by name or index.
    # 
    # The {#at} method is an alias of {#[]}.
    # 
    # _@return_ — The line style retrieved. Nil if the name
    # couldn't be retrived.
    # 
    # ```ruby
    # solid_style = Sketchup.active_model.line_styles["Solid Basic"]
    # line_style = Sketchup.active_model.line_styles[1]
    # ```
    def at: (untyped arg) -> Sketchup::LineStyle?

    # The {#each} method is used to iterate through all the line styles.
    # 
    # ```ruby
    # line_styles = Sketchup.active_model.line_styles
    # line_styles.each{ |line_style| p line_style.name }
    # ```
    def each: () ?{ (LineStyle) -> void } -> void

    # The {#names} method return the support line styles as strings.
    # 
    # ```ruby
    # Sketchup.active_model.line_styles.names
    # ```
    def names: () -> ::Array[String]

    # The {#size} method returns the number of line styles that SketchUp supports.
    # 
    # _@return_ — The count of line styles.
    # 
    # ```ruby
    # line_styles = Sketchup.active_model.line_styles
    # line_styles.size
    # ```
    def size: () -> Integer

    # The {#to_a} method returns an array of all the line styles.
    # 
    # _@return_ — Containing all the line style objects.
    # 
    # ```ruby
    # line_styles = Sketchup.active_active_model.line_styles.to_a
    # ```
    def to_a: () -> ::Array[untyped]
  end

  # The {Sketchup::PickHelper} class is used to pick entities that reside under
  # the current cursor location, similar to native Select tool. Unlike
  # {Sketchup::InputPoint}, {Sketchup::PickHelper} uses no inference.
  # 
  # Only {Sketchup::Tool}s react to cursor location and most of these methods are
  # only useful in the context of a tool. For example, if you want to determine
  # the entity you just clicked, you would use {#do_pick} from within your
  # {Sketchup::Tool#onLButtonDown} method.
  # 
  # You can retrieve a PickHelper object using the {Sketchup::View#pick_helper}
  # method.
  # 
  # Entities that are picked (found under the
  # cursor when a mouse or keyboard event occurs), are called Pick Records and
  # are placed in an indexed list.
  # 
  # @note The same {Sketchup::Pickhelper} instance is being reused by SketchUp.
  #   Don't extend, add methods or redefine methods on this object as it can
  #   clash with other extensions.
  # 
  # @version SketchUp 6.0
  class PickHelper
    PICK_CROSSING: untyped
    PICK_INSIDE: untyped

    # The all_picked method is used to get an array of entities from the
    # active entities from all the pick paths. Duplicates might occur if
    # there are multiple pick paths for entities that ends in a group or
    # component.
    # 
    # For example, if the pick hits at the border of an edge and face
    # inside a group there will be two pick paths - one for the face and
    # one for the edge. Since this method returns entities from the active
    # entities it would return an array with the group two times.
    # 
    # _@return_ — elements - the array of elements in the pick.
    # 
    # ```ruby
    # ph = view.pick_helper
    # ph.do_pick(x, y)
    # entities = ph.all_picked
    # ```
    def all_picked: () -> untyped

    # The best_picked method is used to retrieve the "best" entity picked (entity
    # that you would have picked if you were using the select tool).
    # 
    # Returns nil if nothing was picked. You must have called do_pick
    # before calling this method.
    # 
    # _@return_ — entity - the best picked entity
    # 
    # ```ruby
    # ph = view.pick_helper
    # ph.do_pick(x, y)
    # best_entity = ph.best_picked
    # ```
    def best_picked: () -> untyped

    # Used to pick a set of entities from a model from a BoundingBox. The pick
    # criteria can be for completely-contained or partially-contained entities,
    # similar to how the Selection tool works.
    # 
    # transformation) if num_picked > 0 Sketchup.active_model.selection.add(ph.all_picked) end
    # 
    # _@param_ `bounding_box` — BoundingBox object defining the volume to use for picking
    # 
    # _@param_ `pick_type` — PICK_INSIDE to select entities completely contained or PICK_CROSSING to select entities partially contained.
    # 
    # _@param_ `transformation` — Transformation that will be applied to the volume defined by the BoundingBox that allows for a rotation.
    # 
    # _@return_ — The number of Entity objects picked
    # 
    # ```ruby
    # boundingbox = Geom::BoundingBox.new
    # boundingbox.add([1, 1, 1], [100, 100, 100])
    # ph = Sketchup.active_model.active_view.pick_helper
    # 
    # # Rotate the box 45' around the z-axis
    # angle = 45
    # transformation = Geom::Transformation.new(ORIGIN, Z_AXIS, angle)
    # 
    # num_picked = ph.boundingbox_pick(boundingbox, Sketchup::PickHelper::PICK_CROSSING,
    # ```
    def boundingbox_pick: (untyped bounding_box, untyped pick_type, ?untyped transformation) -> untyped

    # The count method is used to count the number of entities picked (number of
    # pick records)
    # 
    # _@return_ — number - the number of entities picked
    # 
    # ```ruby
    # number = pickhelper.count
    # ```
    def count: () -> untyped

    # The depth_at method retrieves the depth of one of the currently picked
    # entities in the list of pick records.
    # 
    # _@param_ `index` — A number from 0 to number of items picked minus one.
    # 
    # _@return_ — integer - the depth of the entity if successful
    # 
    # ```ruby
    # pickhelper = view.pick_helper
    # pickhelper.do_pick(x, y)
    # # Iterate all pick-routes:
    # pickhelper.count.times { |pick_path_index|
    #   puts pickhelper.depth_at(pick_path_index)
    # }
    # ```
    def depth_at: (untyped index) -> untyped

    # The do_pick method is used to perform the initial pick. This method is
    # generally called before any other methods in the PickHelper class.
    # 
    # Returns the number of entities picked. The x and y values are the screen
    # coordinates of the point at which would want to do a pick.
    # 
    # _@param_ `x` — X screen coordinate for the pick.
    # 
    # _@param_ `y` — Y screen coordinate for the pick.
    # 
    # _@param_ `aperture` — The size of the pick-aperture.
    # 
    # _@return_ — Integer - The number of Entity objects picked
    # 
    # ```ruby
    # ph = view.pick_helpernum = ph.do_pick(x, y)
    # ```
    def do_pick: (untyped x, untyped y, ?untyped aperture) -> untyped

    # The element_at method is used to retrieve a specific entity in the list of
    # picked elements. This element will be from the active entities.
    # 
    # Use count() to get the number of possible pick paths.
    # 
    # _@param_ `index` — A number from 0 to number of items picked minus one.
    # 
    # _@return_ — entity - the entity at the index position in the list
    # of picked entities.
    # 
    # ```ruby
    # pickhelper = view.pick_helper
    # pickhelper.do_pick(x, y)
    # # Iterate all pick-routes:
    # pickhelper.count.times { |pick_path_index|
    #   puts pickhelper.element_at(pick_path_index)
    # }
    # # You would iterate the same elements in all_picked.
    # ```
    def element_at: (untyped index) -> untyped

    # The {#init} method is used to initialize the PickHelper for testing points.
    # 
    # You do not normally need to call this method, but you can use this if you
    # want to call {#test_point} or {#pick_segment} on a lot of points.
    # 
    # If the optional aperture is given, it is given in pixels.
    # 
    # _@param_ `x` — X screen coordinate for the pick.
    # 
    # _@param_ `y` — Y screen coordinate for the pick.
    # 
    # _@param_ `aperture` — aperture in pixels.
    # 
    # _@return_ — self
    # 
    # ```ruby
    # ph = view.pick_helper
    # ph.init(x, y, 5)
    # # Find all points picked by the screen click.
    # selected = points.select { |point|
    #   ph.test_point(point)
    # }
    # ```
    def init: (Integer x, Integer y, ?Integer aperture) -> PickHelper

    # The leaf_at method retrieves the deepest thing in a pick path.
    # 
    # For example, if you have a face that is within a component that is within
    # another component, leaf_at returns the face.
    # 
    # Use count() to get the number of possible pick paths.
    # 
    # _@param_ `index` — A number from 0 to number of items picked minus one.
    # 
    # _@return_ — entity - the leaf entity
    # 
    # ```ruby
    # pickhelper = view.pick_helper
    # pickhelper.do_pick(x, y)
    # # Iterate all pick-routes:
    # pickhelper.count.times { |pick_path_index|
    #   p pickhelper.leaf_at(pick_path_index)
    # }
    # ```
    def leaf_at: (untyped index) -> untyped

    # The path_at method is used to retrieve the entire path for an entity in the
    # pick list (as an array).
    # 
    # If one of the pick paths end in a face nested in a group nested in a
    # component this method will return an array of these entities. The Group
    # will be first and the face will be last.
    # 
    # The first item in the array will be from the active entities and the last
    # item will be a drawing element that is not a group, component or image.
    # 
    # _@param_ `index` — A number from 0 to number of items picked minus one.
    # 
    # _@return_ — array - an array of entities including the leaf
    # 
    # ```ruby
    # pickhelper = view.pick_helper
    # pickhelper.do_pick(x, y)
    # # Iterate all pick-routes:
    # pickhelper.count.times { |pick_path_index|
    #   p pickhelper.path_at(pick_path_index)
    # }
    # ```
    def path_at: (untyped index) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The {#pick_segment} method is used to pick a segment of a polyline curve that
    # is defined by an array of points.
    # 
    # If you click on a point in a polyline curve, the index of
    # the point in the curve is returned (starting at 0).
    # 
    # If you click on a segment in the polyline curve, the index of the segment is
    # returned. Segments are returned by negative indicies and start at index -1
    # (for the segment connecting the first two points) and increase by a factor
    # of -1 (for example, the segment connecting second and third point is -2).
    # 
    # There is no need to invoke {#do_pick} for this and the results are unrelated.
    # 
    # ```ruby
    # point1 = Geom::Point3d.new(0 ,0, 0)
    # point2 = Geom::Point3d.new(10, 0, 0)
    # segment = [point1, point2]
    # ph = view.pick_helper
    # # If testing many points this is the fastest way to test.
    # ph.init(x, y)
    # picked = ph.pick_segment(segment)
    # # This do not require .init
    # picked = ph.pick_segment(segment, x, y)
    # ```
    # 
    # _@note_ — The return value will be a negative index when a segment is picked.
    def pick_segment: (*untyped args) -> untyped

    # The picked_edge method is used to retrieve the "best" Edge picked.
    # 
    # Returns nil if there were no edges picked. You must have called do_pick
    # before calling this method.
    # 
    # _@return_ — edge - an Edge object if successful
    # 
    # ```ruby
    # ph = view.pick_helper
    # ph.do_pick(x, y)
    # edge = ph.picked_edge
    # ```
    def picked_edge: () -> untyped

    # The picked_element method retrieves the best drawing element, that is not an
    # edge or a face, picked.
    # 
    # Returns nil if nothing was picked. You must have called do_pick
    # before calling this method.
    # 
    # _@param_ `index`
    # 
    # _@return_ — element - a drawing element that is not an edge or face
    # if successful
    # 
    # ```ruby
    # ph = view.pick_helper
    # ph.do_pick(x, y)
    # entity = ph.picked_element
    # ```
    def picked_element: (untyped index) -> untyped

    # The picked_face method is used to retrieve the best face picked.
    # 
    # Returns nil if there were no faces picked. You must have called do_pick
    # before calling this method.
    # 
    # _@return_ — face - a Face object if successful
    # 
    # ```ruby
    # ph = view.pick_helper
    # ph.do_pick(x, y)
    # face = ph.picked_face
    # ```
    def picked_face: () -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # The {#test_point} method is used to test a point to see if it would be
    # selected using the default or given pick aperture.
    # 
    # There is no need to invoke {#do_pick} for this and the results are unrelated.
    # 
    # ```ruby
    # ph = view.pick_helper
    # # If testing many points this is the fastest way to test.
    # ph.init(x, y)
    # picked = ph.test_point(point)
    # # These do not require init()
    # picked = ph.test_point(point, x, y)
    # picked = ph.test_point(point, x, y, aperture)
    # ```
    def test_point: (*untyped args) -> bool

    # The transformation_at method is used to get a transformation at a specific
    # pick path index in the pick helper.
    # 
    # The transformation combines the transformation of all groups, components and
    # images in the pick path. This transformation can be used to transform the
    # coordinates of the leaf entity into the coordinates of the active entities.
    # 
    # _@param_ `index` — The index where the transformation should be retrieved.
    # 
    # _@return_ — transformation - the transformation found
    # 
    # ```ruby
    # pickhelper = view.pick_helper
    # pickhelper.do_pick(x, y)
    # # Iterate all pick-routes:
    # pickhelper.count.times { |pick_path_index|
    #   puts pickhelper.transformation_at(pick_path_index)
    # }
    # ```
    # 
    # Get transformation for specific picked element
    # ```ruby
    # pickhelper = view.pick_helper
    # pickhelper.do_pick(x, y)
    # face = pickhelper.picked_face # Face may be inside a group or component.
    # 
    # index = pickhelper.count.times.find { |i| pickhelper.leaf_at(i) == face }
    # transformation = index ? pickhelper.transformation_at(index) : IDENTITY
    # 
    # # Face#area is one method that may need a transformation.
    # area = face.area(transformation)
    # ```
    def transformation_at: (untyped index) -> untyped

    # The view method is used to get the view associated with the PickHelper.
    # 
    # _@return_ — view - the associated view
    # 
    # ```ruby
    # view = pickhelper.view
    # ```
    def view: () -> untyped

    # Used to pick a set of entities from a model based on a screen coordinate
    # rectangular area defined by two points. The pick criteria can be for
    # completely-contained or partially-contained entities, similar to how
    # the Selection tool works. The z value of the points passed in are ignored.
    # 
    # _@param_ `start_point` — First screen coordinate point.
    # 
    # _@param_ `end_point` — Second screen coordinate point.
    # 
    # _@param_ `pick_type` — PICK_INSIDE to select entities completely contained or PICK_CROSSING to select entities partially contained.
    # 
    # _@return_ — The number of Entity objects picked
    # 
    # ```ruby
    # ph = Sketchup.active_model.active_view.pick_helper
    # start_point = Geom::Point3d.new(100, 100, 0)
    # end_point = Geom::Point3d.new(500, 500, 0)
    # num_picked = ph.window_pick(start_point, end_point, Sketchup::PickHelper::PICK_CROSSING)
    # ```
    def window_pick: (untyped start_point, untyped end_point, untyped pick_type) -> untyped
  end

  # The ShadowInfo class contains method to extract the shadow information for a
  # model. The majority of the shadow information returned exists in the Model
  # Info > Location and Model Info > Shadows dialogs inside SketchUp.
  # 
  # The following shadow information keys are maintained in SketchUp:
  # 
  # - +City+ (in Model Info > Geo-location > Set Manual Location...) Note that 'City' is called
  # 'Location' in the UI
  # - +Country+ (in Model Info > Geo-location > Set Manual Location...)
  # - +Dark+ (in Window > Shadows)
  # - +DayOfYear+
  # - +DaylightSavings+
  # - +DisplayNorth+ (in View > Toolbars > Solar North) Note that 'Toolbar' is called 'Tool Palettes'
  # on Mac
  # - +DisplayOnAllFaces+ (in Window > Shadows)
  # - +DisplayOnGroundPlane+ (in Window > Shadows)
  # - +DisplayShadows+ (in Window > Shadows)
  # - +EdgesCastShadows+ (in Window > Shadows)
  # - +Latitude+ (in Model Info > Geo-location > Set Manual Location...)
  # - +Light+ (in Window > Shadows)
  # - +Longitude+ (in Model Info > Geo-location > Set Manual Location...)
  # - +NorthAngle+ (in View > Toolbars > Solar North) Note that 'Toolbar' is called 'Tool Palettes'
  # on Mac
  # - +ShadowTime+ (in Window > Shadows)
  # - +ShadowTime_time_t+ (ShadowTime in Epoch time)
  # - +SunDirection+ (Generated based on ShadowTime)
  # - +SunRise+ (Generated based on ShadowTime)
  # - +SunRise_time_t+ (SunRise in Epoch time)
  # - +SunSet+ (Generated based on ShadowTime)
  # - +SunSet_time_t+ (SunSet in Epoch time)
  # - +TZOffset+ (in Window > Shadows)
  # - +UseSunForAllShading+ (in Window > Shadows)
  # 
  # You access the ShadowInfo object by calling Model.shadow_info:
  # 
  # @example
  #   model = Sketchup.active_model
  #   shadowinfo = model.shadow_info
  #   UI.messagebox("My city is: " + shadowinfo["City"].to_s)
  # 
  # @version SketchUp 6.0
  class ShadowInfo < Sketchup::Entity
    include Enumerable[untyped]

    # The each_key method iterates through all of the shadow information keys.
    # 
    # ```ruby
    # shadowinfo.each_key { |key| puts key }
    # ```
    def self.each_key: () -> void

    # The keys method is a class method that returns an array with all of the
    # attribute keys
    # 
    # _@return_ — an array of keys
    # 
    # ```ruby
    # keys = Sketchup::ShadowInfo.keys
    # ```
    def self.keys: () -> ::Array[String]

    # The [] method retrieves a value from the array of keys
    # 
    # _@param_ `key` — The key of the shadowinfo value to retrieve.
    # 
    # _@return_ — the value that is retrieved.
    # 
    # ```ruby
    # value = shadowinfo["key"]
    # ```
    def []: (String key) -> Object?

    # The set value []= method is used to set the value in the array of shadow
    # info options.
    # 
    # _@param_ `key` — The key of the shadowinfo value to set.
    # 
    # _@param_ `value` — The value to be set.
    # 
    # _@return_ — the value that was set if successful, or false
    # if unsuccessful.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # shadowinfo = model.shadow_info
    # value = shadowinfo["City"]
    # UI.messagebox value
    # value = shadowinfo["City"]="Denver, CO"
    # UI.messagebox value
    # ```
    def []=: (String key, Object value) -> Object

    # The add_observer method is used to add an observer to the current object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # status = object.add_observer observer
    # ```
    def add_observer: (Object observer) -> bool

    # The count method is inherited from the Enumerable mix-in module.
    # 
    # ```ruby
    # shadow_info = Sketchup.active_model.shadow_info
    # number = shadow_info.count
    # ```
    def count: () -> Integer

    # The {#each} method iterates through all of the shadow information key/value
    # pairs.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # shadow_info = model.shadow_info
    # shadow_info.each { |key, value|
    #   puts "#{key} : #{value}"
    # }
    # ```
    # 
    # _@see_ `#each_pair`
    def each: () ?{ (String key, Object value) -> void } -> void

    # The each_key method iterates through all of the shadow information keys.
    # 
    # ```ruby
    # shadowinfo.each_key { |key| puts key }
    # ```
    def each_key: () -> void

    # The {#each_pair} method is an alias for {#each}.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # shadow_info = model.shadow_info
    # shadow_info.each_pair { |key, value|
    #   puts "#{key} : #{value}"
    # }
    # ```
    # 
    # _@see_ `#each`
    def each_pair: () ?{ (String key, Object value) -> void } -> void

    # The keys method is a class method that returns an array with all of the
    # attribute keys
    # 
    # _@return_ — an array of keys
    # 
    # ```ruby
    # keys = Sketchup::ShadowInfo.keys
    # ```
    def keys: () -> ::Array[String]

    # The {#length} method returns the number of options in the shadow options
    # collection
    # 
    # ```ruby
    # shadow_info = Sketchup.active_model.shadow_info
    # number = shadow_info.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The remove_observer method is used to remove an observer from the current
    # object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # status = object.remove_observer observer
    # ```
    def remove_observer: (Object observer) -> bool

    # The {#size} method is an alias for {#length}.
    # 
    # ```ruby
    # shadow_info = Sketchup.active_model.shadow_info
    # number = shadow_info.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer
  end

  # This observer interface is implemented to react to application events.
  # This interface is often used to attach other observers to models as they
  # are opened or started.
  # This ensures that your observers are watching all open models.
  # 
  # For example, when one attaches a {Sketchup::SelectionObserver}, it is only
  # attached to the {Sketchup::Selection} collection of a given model. If a 2nd
  # model is opened, the new model's selection changes will not fire selection
  # callbacks unless you've attached a {Sketchup::SelectionObserver} to the new
  # model as well. By watching for {#onNewModel}, you can be sure to do so.
  # 
  # @abstract To implement this observer, create a Ruby class of this type, override the
  #   desired methods, and add an instance of the observer to the
  #   application class.
  # 
  # @example
  #   # This is an example of an observer that watches the application for
  #   # new models and shows a messagebox.
  #   class MyAppObserver < Sketchup::AppObserver
  #     def onNewModel(model)
  #       puts "onNewModel: #{model}"
  # 
  #       # Here is where one might attach other observers to the new model.
  #       model.selection.add_observer(MySelectionObserver.new)
  #     end
  #   end
  # 
  #   # Attach the observer
  #   Sketchup.add_observer(MyAppObserver.new)
  # 
  # @version SketchUp 6.0
  class AppObserver
    # The {#expectsStartupModelNotifications} method is called to determine if the
    # observer expects to receive {#onNewModel} and {#onOpenModel} calls for the
    # models that are created or opened at SketchUp startup. This includes the
    # empty initial model, a model opened via command line arguments, or
    # auto-restored models on Mac OS X.
    # 
    # _@return_ — +true+ to receive {#onNewModel} and {#onOpenModel} calls
    # for startup models. Return +false+ or simply not
    # implement the method in order to not receive these calls
    # (which was the behavior prior to SketchUp 2014).
    # 
    # ```ruby
    # def expectsStartupModelNotifications
    #   return true
    # end
    # ```
    # 
    # _@note_ — Prior to SketchUp 2014, {#onNewModel} and {#onOpenModel} were
    # not being called for the startup models. This issue is now fixed but
    # observers still need to express their intent to receive these calls. This is
    # for back-compatibility with existing scripts which worked around these
    # missing calls by other means. For new code, this method should be implemented
    # and should return +true+.
    def expectsStartupModelNotifications: () -> bool

    # The {#onActivateModel} method is called when an open model is activated. This
    # is relevant on Mac only which supports multiple documents to be opened
    # simultaneously.
    # 
    # _@param_ `model` — The newly-activated model object.
    # 
    # ```ruby
    # def onActivateModel(model)
    #   puts "onActivateModel: #{model}"
    # end
    # ```
    def onActivateModel: (Sketchup::Model model) -> void

    # sord omit - no YARD return type given, using untyped
    # The {#onExtensionsLoaded} method is called when SketchUp has finished loading
    # all extensions when the application starts.
    # 
    # ```ruby
    # def onExtensionsLoaded
    #   puts "onExtensionsLoaded"
    # end
    # ```
    def onExtensionsLoaded: () -> untyped

    # The {#onNewModel} method is called when the application creates a new, empty
    # model.
    # 
    # _@param_ `model` — The active model object.
    # 
    # ```ruby
    # def onNewModel(model)
    #   puts "onNewModel: #{model}"
    # end
    # ```
    def onNewModel: (Sketchup::Model model) -> void

    # The {#onOpenModel} method is called when the application opens an existing
    # model.
    # 
    # _@param_ `model` — The active model object.
    # 
    # ```ruby
    # def onOpenModel(model)
    #   puts "onOpenModel: #{model}"
    # end
    # ```
    # 
    # _@note_ — If a skp file is loaded via the command line or double-clicking on
    # a skp in explorer (which is also is the command line) then this
    # observer will not be called.  The Ruby interpreter in SketchUp is
    # initialized after command line processing so the observer won't
    # be added in time to get the notification.
    def onOpenModel: (Sketchup::Model model) -> void

    # The {#onQuit} method is called when SketchUp closes. This is useful if you
    # need to clean up anything or store your application state upon close.
    # 
    # ```ruby
    # def onQuit()
    #   puts "onQuit"
    # end
    # ```
    def onQuit: () -> void

    # The {#onUnloadExtension} method is called when the user turns off a Ruby
    # extension. This is useful for detecting if the user is deactivating
    # some critical set of observers, for example, so you can warn them
    # or cache your extension state.
    # 
    # _@param_ `extension_name` — The name of the extension just unloaded.
    # 
    # ```ruby
    # def onUnloadExtension(extension_name)
    #   puts "onUnloadExtension: #{extension_name}"
    # end
    # ```
    def onUnloadExtension: (String extension_name) -> void
  end

  # Allows layers to be organized in folders. Folders may have duplicate names.
  # 
  # @api TagFolder
  # 
  # @note As of SketchUp 2020 "Layers" were renamed to "Tags" in the UI.
  #   The API retains the use of "Layer" for compatibility and is synonymous with
  #   "Tag".
  # 
  # @version SketchUp 2021.0
  class LayerFolder < Sketchup::Entity
    include Comparable

    # The {#<=>} method is used to compare two layer folders based on their names.
    # This enables the Ruby +Array#sort+ method to sort SketchUp layer folders.
    # 
    # _@param_ `other`
    # 
    # _@return_ — +-1+ if the receiver should appear before +other+.
    # +1+ if the receiver should appear after +other+.
    # +0+ if the receiver and +other+ are equal.
    # +nil+ if +other+ is not comparable with the receiver.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # folder1 = layers.add_folder('Folder1')
    # folder2 = layers.add_folder('Folder2')
    # comparison = folder1 <=> folder2 # Returns: -1
    # comparison = folder1 <=> folder1 # Returns: 0
    # comparison = folder2 <=> folder1 # Returns: 1
    # ```
    def <=>: (Object other) -> Integer?

    # The {#==} method is used to determine if two layer folders are the same.
    # 
    # _@param_ `other`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # folder1 = layers.add('Folder1')
    # folder2 = layers.add('Folder2')
    # equal = folder1 == folder2
    # ```
    def ==: (Object other) -> bool

    # sord omit - no YARD type given for "arg", using untyped
    # The {#add_folder} method adds or moves a layer folder.
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # folder1 = manager.add_folder('Doors')
    # folder2 = folder1.add_folder('Outer Doors')
    # ```
    # 
    # _@see_ `#count_layers`
    def add_folder: (untyped arg) -> Sketchup::LayerFolder

    # The {#add_layer} method adds a layer to a folder.
    # 
    # _@param_ `layer`
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # layer = manager.add_layer('Inner Doors')
    # folder = manager.add_folder('Doors')
    # 
    # folder.add_layer(layer)
    # ```
    # 
    # _@see_ `Sketchup::Layer#folder=` — Information on how which notifications
    # trigger when reparenting a layer.
    def add_layer: (Sketchup::Layer layer) -> void

    # The {#count_folders} method retrieves the number of child folders in the
    # folder.
    # 
    # ```ruby
    # layers = Sketchup.active_model.layers
    # folder1 = layers.add_folder('Hello')
    # folder2 = folder1.add_folder('World')
    # number = folder1.folder_count # Returns: 1
    # ```
    def count_folders: () -> Integer

    # The {#count_layers} method retrieves the number of layers in the folder.
    # 
    # ```ruby
    # layers = Sketchup.active_model.layers
    # layer = layers.add_layer('World')
    # folder = layers.add_folder('Hello')
    # folder.add_layer(layer)
    # number = folder.layer_count # Returns: 1
    # ```
    # 
    # _@see_ `#size`
    # 
    # _@see_ `#length`
    def count_layers: () -> Integer

    # sord omit - no YARD return type given, using untyped
    # The {#each_folder} method is used to iterate through the folders that are
    # direct children to the folder.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # folder1 = layers.add_folder('Hello')
    # folder1.add_folder('World')
    # folder1.each_folder { | folder | puts folder.name }
    # ```
    def each_folder: () ?{ (Sketchup::LayerFolder folder) -> void } -> untyped

    # sord omit - no YARD return type given, using untyped
    # The {#each_layer} method is used to iterate through the layers that are
    # direct children to the folder.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # layer = layers.add_layer('World')
    # folder = layers.add_folder('Hello')
    # folder.add_layer(layer)
    # folder.each_layer { | layer | puts layer.name }
    # ```
    def each_layer: () ?{ (Sketchup::Layer layer) -> void } -> untyped

    # The {#folder} method is used to return the parent layer folder of a layer
    # folder.
    # 
    # _@return_ — +nil+ if the folder is a direct child to
    # the layer manager.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # folder1 = layers.add_folder('Folder1')
    # parent_folder = folder1.folder # Returns: nil
    # 
    # folder2 = folder1.add_folder('Folder2')
    # parent_folder = folder2.folder # Returns: folder1
    # ```
    def folder: () -> Sketchup::LayerFolder?

    # sord omit - no YARD return type given, using untyped
    # The {#folder=} method is used to set the parent layer folder of a layer
    # folder.
    # 
    # This will trigger +onLayerFolderRemoved+ followed by +onLayerFolderAdded+.
    # 
    # _@param_ `parent` — +nil+ will make the the folder a direct child to the layer manager.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # folder1 = layers.add_folder('Folder1')
    # folder2 = layers.add_folder('Folder2')
    # 
    # folder2.folder = folder1
    # ```
    def folder=: (Sketchup::LayerFolder? parent) -> untyped

    # The {#folders} returns the direct child-folders of the folder.
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # folder1 = manager.add_folder('Doors')
    # folder2 = folder1.add_folder('Windows')
    # folders = folder1.folders
    # ```
    def folders: () -> ::Array[Sketchup::LayerFolder]

    # The {#layers} method retrieves the child layers of a folder.
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # folder = manager.add_folder('Hello')
    # folder.add_layer(manager.add_layer('World'))
    # folder.add_layer(manager.add_layer('Universe'))
    # 
    # layers = folder.layers
    # ```
    def layers: () -> ::Array[Sketchup::Layer]

    # The {#name} method gets the name of the folder.
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # folder = manager.add_folder('Doors')
    # name = folder.name
    # ```
    def name: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#name=} method sets the name of the folder.
    # 
    # _@param_ `name`
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # folder = manager.add_folder('Doors')
    # folder.name = 'Windows'
    # ```
    def name=: (String name) -> untyped

    # The {#remove_folder} method removes the folder from the model. All children
    # are preserved, but move up one level.
    # 
    # _@param_ `folder`
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # folder1 = manager.add_folder('Doors')
    # folder2 = manager.add_folder('Outer Doors')
    # folder1.remove_folder(folder2)
    # ```
    def remove_folder: (Sketchup::LayerFolder folder) -> void

    # The {#remove_layer} method removes a layer from a folder. The layer will be
    # parent to the layer manager.
    # 
    # _@param_ `layer`
    # 
    # ```ruby
    # manager = Sketchup.active_model.layers
    # layer = manager.add_layer('Inner Doors')
    # folder = manager.add_folder('Doors')
    # folder.add_layer(layer)
    # 
    # folder.remove_layer(layer)
    # ```
    def remove_layer: (Sketchup::Layer layer) -> void

    # sord omit - no YARD return type given, using untyped
    # The {#visible=} method is used to set if the layer folder is visible.
    # 
    # _@param_ `visible`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # folder = layers.add('Hello')
    # folder.visible = false
    # ```
    def visible=: (bool visible) -> untyped

    # The {#visible?} method is used to determine if the layer folder is visible.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # folder = layers.add('Hello')
    # folder.visible? # Returns: true
    # ```
    def visible?: () -> bool

    # sord omit - no YARD return type given, using untyped
    # The {#visible_on_new_pages=} method is used to set if the layer folder is by
    # default visible on new pages.
    # 
    # _@param_ `visible`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # folder = layers.add_folder('Hello')
    # folder.visible_on_new_pages = false
    # page = model.pages.add('My Page')
    # model.pages.select_page = page # `folder` will now be hidden.
    # ```
    def visible_on_new_pages=: (bool visible) -> untyped

    # The {#visible_on_new_pages?} method is used to determine if the layer folder
    # is by default visible on new pages.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # layers = model.layers
    # folder = layers.add_folder('Hello')
    # folder.visible_on_new_pages? # Returns: true
    # ```
    def visible_on_new_pages?: () -> bool
  end

  # The {Sketchup::InstancePath} class represent the instance path to a given
  # entity within the model hierarchy.
  # 
  # @version SketchUp 2017
  class InstancePath
    include Enumerable[Sketchup::Entity]

    # sord omit - no YARD type given for "other", using untyped
    # _@return_ — `true` if the instances paths represent the same set of
    # entities.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # group = model.entities.add_group
    # edge = group.entities.add_line([10, 10, 10], [20, 20, 20])
    # path = Sketchup::InstancePath.new([group, edge])
    # if path.size > 1
    #   # do something
    # end
    # ```
    def ==: (untyped other) -> bool

    # The elements of an instance path can be accessed similarly to an array.
    # 
    # _@param_ `index`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # group = model.entities.add_group
    # edge = group.entities.add_line([10, 10, 10], [20, 20, 20])
    # path = Sketchup::InstancePath.new([group, edge])
    # path[0] == group # returns true
    # path[1] == edge # returns true
    # ```
    # 
    # _@note_ — This method does not accept negative indices. For the exact behavior
    # of an array, use +{#to_a}+.
    def []: (Integer index) -> Sketchup::Entity

    # The yielded entities will start with the root and end with the leaf.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # group = model.entities.add_group
    # edge = group.entities.add_line([10, 10, 10], [20, 20, 20])
    # path = Sketchup::InstancePath.new([group, edge])
    # path.each { |entity|
    #   # do something
    # }
    # ```
    def each: () ?{ (Sketchup::Entity) -> void } -> void

    # ```ruby
    # model = Sketchup.active_model
    # group = model.entities.add_group
    # edge = group.entities.add_line([10, 10, 10], [20, 20, 20])
    # path = Sketchup::InstancePath.new([group, edge])
    # if path.empty?
    #   # do something...
    # end
    # ```
    def empty?: () -> bool

    # Returns `true` if the instance path contain the given object.
    # 
    # _@param_ `object`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # group = model.entities.add_group
    # edge = group.entities.add_line([10, 10, 10], [20, 20, 20])
    # path = Sketchup::InstancePath.new([group, edge])
    # if path.include?(edge)
    #   # do something...
    # end
    # ```
    def include?: (Object object) -> bool

    # _@param_ `path` — The leaf can be any entity, but the rest must be a group or component instance.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # group = model.entities.add_group
    # edge = group.entities.add_line([10, 10, 10], [20, 20, 20])
    # path = Sketchup::InstancePath.new([group, edge])
    # ```
    def initialize: (::Array[Sketchup::Entity] path) -> void

    # The leaf of an instance path is the last element which can be any entity
    # that can be represented in the model. This is normally a
    # {Sketchup::Drawingelement}, but could be a {Sketchup::Vertex}.
    # 
    # An instance can also be a leaf.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # group = model.entities.add_group
    # edge = group.entities.add_line([10, 10, 10], [20, 20, 20])
    # path = Sketchup::InstancePath.new([group, edge])
    # path.leaf == edge # returns true
    # ```
    def leaf: () -> Sketchup::Entity

    # {#length} is an alias of {#size}.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # group = model.entities.add_group
    # edge = group.entities.add_line([10, 10, 10], [20, 20, 20])
    # path = Sketchup::InstancePath.new([group, edge])
    # if path.length > 1
    #   # do something
    # end
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The serialized version of an instance path is the persistent ids of its
    # entities concatenated with a period.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # group = model.entities.add_group
    # edge = group.entities.add_line([10, 10, 10], [20, 20, 20])
    # path = Sketchup::InstancePath.new([group, edge])
    # pid_path = path.persistent_id_path # something like "342.345"
    # ```
    # 
    # _@see_ `Sketchup::Model#instance_path_from_pid_path`
    def persistent_id_path: () -> String

    # The root of an instance path is the element located closest to the model
    # root. This will be a group or component instance. If you have a non-instance
    # as a leaf with no other parent component this will return `nil`.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # group = model.entities.add_group
    # edge = group.entities.add_line([10, 10, 10], [20, 20, 20])
    # path = Sketchup::InstancePath.new([group, edge])
    # path.root == group # returns true
    # ```
    def root: () -> (Sketchup::Group | Sketchup::ComponentInstance)?

    # ```ruby
    # model = Sketchup.active_model
    # group = model.entities.add_group
    # edge = group.entities.add_line([10, 10, 10], [20, 20, 20])
    # path = Sketchup::InstancePath.new([group, edge])
    # if path.size > 1
    #   # do something
    # end
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer

    # _@return_ — an array representing the instance path.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # group = model.entities.add_group
    # edge = group.entities.add_line([10, 10, 10], [20, 20, 20])
    # path = Sketchup::InstancePath.new([group, edge])
    # pid_string = path.to_a.join('.')
    # ```
    def to_a: () -> ::Array[untyped]

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # ```ruby
    # model = Sketchup.active_model
    # group = model.entities.add_group
    # edge = group.entities.add_line([10, 10, 10], [20, 20, 20])
    # path = Sketchup::InstancePath.new([group, edge])
    # tr = path.transformation
    # ```
    def transformation: (*untyped args) -> untyped

    # An instance path is valid if it has at least one element and consist of
    # groups and instances with exception of the leaf which can be any entity.
    # 
    # This method doesn't check if the path can actually be looked up in the model.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # group = model.entities.add_group
    # edge = group.entities.add_line([10, 10, 10], [20, 20, 20])
    # path = Sketchup::InstancePath.new([group, edge])
    # if path.valid?
    #   # do something...
    # end
    # ```
    def valid?: () -> bool
  end

  # The SectionPlane class represents a section plane in a SketchUp model. Note
  # that prior to SketchUp 2014 there was no way to create a SectionPlane object
  # using Ruby. For older versions of SketchUp, you must manually create a
  # section plane with the Section Plane Tool in SketchUp and then query the
  # entities array to find the SectionPlane object.
  # 
  # @version SketchUp 6.0
  class SectionPlane < Sketchup::Drawingelement
    # The activate method is used to make the section plane the active one of its
    # parent component/group.
    # 
    # _@return_ — self if successful
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # sp = entities.add_section_plane([50, 50, 0], [1.0, 1.0, 0])
    # sp.activate
    # ```
    def activate: () -> untyped

    # The active? method indicates whether the section plane is active or not.
    # 
    # _@return_ — boolean - true if active
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # sp = entities.add_section_plane([50, 50, 0], [1.0, 1.0, 0])
    # sp.activate
    # if sp.active?
    #    puts "Yes, it is active"
    # end
    # ```
    def active?: () -> bool

    # The get_plane method is used to retrieve the plane that the section plane is
    # on.
    # 
    # _@return_ — plane - a plane. See the Geom module and Array class
    # for further information on planes.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # # Grab the first section plane from the model.
    # sp = entities.grep(Sketchup::SectionPlane).first
    # plane = sp.get_plane
    # if (plane)
    #   puts plane.to_s
    # else
    #   puts 'Failure'
    # end
    # ```
    def get_plane: () -> untyped

    # The {#name} method is used to retrieve the name of the section plane.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # # Grab the first section plane from the model.
    # section_plane = entities.grep(Sketchup::SectionPlane).first
    # name = section_plane.name
    # ```
    def name: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#name=} method is used to set the name of a section plane.
    # 
    # _@param_ `name` — The new name for the section plane object.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = Sketchup.active_model.entities
    # # Grab the first section plane from the model.
    # section_plane = entities.grep(Sketchup::SectionPlane).first
    # section_plane.name = "my section plane"
    # ```
    def name=: (String name) -> untyped

    # The set_plane method is used to set the plane that the section plane is
    # on.
    # 
    # _@param_ `plane` — An array representing the new plane,
    # 
    # _@return_ — section_plane - the updated SectionPlane.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # # Grab the first section plane from the model.
    # sp = entities.grep(Sketchup::SectionPlane).first
    # sp = sp.set_plane my_plane_array
    # ```
    def set_plane: (untyped plane) -> untyped

    # The {#symbol} method is used to retrieve the symbol of the section plane.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # # Grab the first section plane from the model.
    # section_plane = entities.grep(Sketchup::SectionPlane).first
    # symbol = section_plane.symbol
    # ```
    def symbol: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#symbol=} method is used to set the symbol of a section plane.
    # 
    # _@param_ `symbol` — The new symbol for the section plane object.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = Sketchup.active_model.entities
    # # Grab the first section plane from the model.
    # section_plane = entities.grep(Sketchup::SectionPlane).first
    # section_plane.symbol = "AB1"
    # ```
    # 
    # _@note_ — The symbol must be three characters or less.
    def symbol=: (String symbol) -> untyped
  end

  # This observer interface is implemented to react to view events.
  # 
  # @abstract To implement this observer, create a Ruby class of this type,
  #   override the desired methods, and add an instance of the observer to the
  #   view object.
  # 
  # @example
  #   # This is an example of an observer that watches tool interactions.
  #   class MyViewObserver < Sketchup::ViewObserver
  #     def onViewChanged(view)
  #       puts "onViewChanged: #{view}"
  #     end
  #   end
  # 
  #   # Attach the observer.
  #   Sketchup.active_model.active_view.add_observer(MyViewObserver.new)
  # 
  # @version SketchUp 6.0
  class ViewObserver
    # The {#onViewChanged} method is called whenever the view is altered, such as
    # when the user uses the Pan, Orbit, or Zoom tools are used.
    # 
    # _@param_ `view`
    # 
    # ```ruby
    # def onViewChanged(view)
    #   puts "onViewChanged: #{view}"
    # end
    # ```
    def onViewChanged: (Sketchup::View view) -> void
  end

  # This observer interface is implemented to react to model events.
  # 
  # Note that the observers related to transactions (aka undoable operations)
  # are primarily for reporting and debugging. Performing any edit operations
  # of your own (such as modifying the model) inside the observer callback
  # should be avoided, as it could cause crashes or model corruption. The most
  # common use for these callbacks is to help debug problems where your
  # Ruby script's {Sketchup::Model#start_operation} and
  # {Sketchup::Model#commit_operation} calls are somehow conflicting with
  # SketchUp's native undo operations. You can set up an observer set to watch
  # precisely what is going on.
  # 
  # @abstract To implement this observer, create a Ruby class of this type, override the
  #   desired methods, and add an instance of the observer to the model.
  # 
  # @example
  #   # This is an example of an observer that watches the
  #   # component placement event.
  #   class MyModelObserver < Sketchup::ModelObserver
  #     def onPlaceComponent(instance)
  #       puts "onPlaceComponent: #{instance}"
  #     end
  #   end
  # 
  #   # Attach the observer.
  #   Sketchup.active_model.add_observer(MyModelObserver.new)
  # 
  # @version SketchUp 6.0
  class ModelObserver
    # The {#onActivePathChanged} method is invoked when the user opens or closes a
    # {Sketchup::ComponentInstance} or {Sketchup::Group} for editing.
    # 
    # When the user opens an instance for editing the positions and transformations
    # of the entities in the opened instance will be relative to global world
    # coordinates instead of the local coordinates relative to their parent.
    # 
    # See {Sketchup::Model#active_path} and {Sketchup::Model#edit_transform} for
    # methods that report the current edit origin vs. the global origin, etc.
    # 
    # By using this observer callback, you can keep track of the various nested
    # transformations as your users double click to drill into and out of
    # component edits.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # # As the user double clicks into component edits, show the "path" along
    # # the model hierarchy they have followed to get here.
    # def onActivePathChanged(model)
    #   puts "onActivePathChanged: #{model}"
    # end
    # ```
    # 
    # _@see_ `Sketchup::Model#active_path`
    # 
    # _@see_ `Sketchup::Model#edit_transform`
    def onActivePathChanged: (Sketchup::Model model) -> void

    # The {#onAfterComponentSaveAs} method is invoked when the user context-clicks >
    # Save As on a component instance. It is called just after the component is
    # written to disk, so you can restore the component to some state before
    # returning control to the user.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onAfterComponentSaveAs(model)
    #   puts "onAfterComponentSaveAs: #{model}"
    # end
    # ```
    # 
    # _@see_ `#onBeforeComponentSaveAs`
    def onAfterComponentSaveAs: (Sketchup::Model model) -> void

    # The {#onBeforeComponentSaveAs} method is invoked when the user
    # context-clicks > Save As on a component instance. It is called just before
    # the component is written to disk, so you can make changes within the handler
    # and it will make it into the save.
    # 
    # For example, you may decide that you want to add some attribute to every
    # component that is saved out, but you do not want that attribute sticking
    # around inside the current model. Within {#onBeforeComponentSaveAs} you could
    # add the attribute, and within {#onAfterComponentSaveAs} you could delete that
    # attribute.
    # 
    # The callback is not sent the component that is to be saved, but the
    # model's selection will contain it.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onBeforeComponentSaveAs(model)
    #   puts "onBeforeComponentSaveAs: #{model}"
    # end
    # ```
    def onBeforeComponentSaveAs: (Sketchup::Model model) -> void

    # The {#onDeleteModel} method is invoked when a model is deleted.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onDeleteModel(model)
    #   puts "onDeleteModel: #{model}"
    # end
    # ```
    def onDeleteModel: (Sketchup::Model model) -> void

    # The {#onEraseAll} method is invoked when everything in a model is erased.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onEraseAll(model)
    #   puts "onEraseAll: #{model}"
    # end
    # ```
    def onEraseAll: (Sketchup::Model model) -> void

    # The {#onExplode method} is invoked whenever a component anywhere in this
    # model is exploded. This is an easier way to watch explode events vs.
    # attaching an InstanceObserver to every instance in the model.
    # 
    # Since the callback does not return what was exploded, one solution is to
    # place a selection observer that keeps track of which entities whose
    # explosion you are interested in are in the selection. Since SketchUp's
    # user interface only provides a means of exploding the selection, this
    # method is a reliable way to know what was just exploded.
    # 
    # Another method would be to watch
    # {Sketchup::ComponentDefinition.count_instances} to determine what just
    # changed, as any components that were exploded will now be less an instance.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onExplode(model)
    #   puts "onExplode: #{model}"
    # end
    # ```
    def onExplode: (Sketchup::Model model) -> void

    # The {#onPidChanged} method is invoked when a persistent id in the model
    # changes. For example when entities are grouped.
    # 
    # _@param_ `model`
    # 
    # _@param_ `old_pid`
    # 
    # _@param_ `new_pid`
    # 
    # ```ruby
    # def onPidChanged(model, old_pid, new_pid)
    #   puts "onPidChanged: #{model}, #{old_pid} => #{new_pid}"
    # end
    # ```
    def onPidChanged: (Sketchup::Model model, Integer old_pid, Integer new_pid) -> void

    # The {#onPlaceComponent} method is invoked when a component is "placed" into
    # the model, meaning it is dragged from the Component Browser.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onPlaceComponent(model)
    #   puts "onPlaceComponent: #{model}"
    # end
    # ```
    def onPlaceComponent: (Sketchup::Model model) -> void

    # The {#onPostSaveModel} method is invoked after a model has been saved to disk.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onPostSaveModel(model)
    #   puts "onPostSaveModel: #{model}"
    # end
    # ```
    def onPostSaveModel: (Sketchup::Model model) -> void

    # The {#onPreSaveModel} method is invoked before a model is saved to disk.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onPreSaveModel(model)
    #   puts "onPreSaveModel: #{model}"
    # end
    # ```
    def onPreSaveModel: (Sketchup::Model model) -> void

    # The {#onSaveModel} method is invoked after a model has been saved to disk.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onSaveModel(model)
    #   puts "onSaveModel: #{model}"
    # end
    # ```
    def onSaveModel: (Sketchup::Model model) -> void

    # The {#onTransactionAbort} method is invoked when a transaction is aborted.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onTransactionAbort(model)
    #   puts "onTransactionAbort: #{model}"
    # end
    # ```
    # 
    # _@see_ `Sketchup::Model#abort_operation`
    def onTransactionAbort: (Sketchup::Model model) -> void

    # The {#onTransactionCommit} method is invoked when a transaction is completed.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onTransactionCommit(model)
    #   puts "onTransactionCommit: #{model}"
    # end
    # ```
    # 
    # _@see_ `Sketchup::Model#commit_operation`
    def onTransactionCommit: (Sketchup::Model model) -> void

    # The {#onTransactionEmpty} method is invoked when a transaction
    # (aka an undoable operation) starts and then is committed without anything
    # being altered in between.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onTransactionEmpty(model)
    #   puts "onTransactionEmpty: #{model}"
    # end
    # ```
    # 
    # _@see_ `Sketchup::Model#start_operation`
    def onTransactionEmpty: (Sketchup::Model model) -> void

    # The {#onTransactionRedo} method is invoked when the user "redoes" a
    # transaction (aka undo operation.) You can programmatically fire a redo by
    # calling +Sketchup.sendAction("editRedo")+.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onTransactionRedo(model)
    #   puts "onTransactionRedo: #{model}"
    # end
    # ```
    def onTransactionRedo: (Sketchup::Model model) -> void

    # The {#onTransactionStart} method is invoked when a transaction
    # (aka an undoable operation) starts.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onTransactionStart(model)
    #   puts "onTransactionStart: #{model}"
    # end
    # ```
    # 
    # _@see_ `Sketchup::Model#start_operation`
    def onTransactionStart: (Sketchup::Model model) -> void

    # The {#onTransactionUndo method} is invoked when the user "undoes" a
    # transaction (aka undo operation.) You can programmatically fire an undo by
    # calling +Sketchup.sendAction("editUndo")+.
    # 
    # _@param_ `model`
    # 
    # ```ruby
    # def onTransactionUndo(model)
    #   puts "onTransactionUndo: #{model}"
    # end
    # ```
    def onTransactionUndo: (Sketchup::Model model) -> void
  end

  # This observer interface is implemented to react to pages events.
  # 
  # @abstract To implement this observer, create a Ruby class of this type, override the
  #   desired methods, and add an instance of the observer to the objects of
  #   interests.
  # 
  # @example
  #   # This is an example of an observer that watches the pages for new ones.
  #   class MyPagesObserver < Sketchup::PagesObserver
  #     def onElementAdded(pages, page)
  #       puts "onElementAdded: #{page}"
  #     end
  #   end
  # 
  #   # Attach the observer.
  #   Sketchup.active_model.pages.add_observer(MyPagesObserver.new)
  # 
  # @version SketchUp 6.0
  class PagesObserver < Sketchup::EntitiesObserver
    # The {#onContentsModified} method is invoked whenever the pages change.
    # 
    # _@param_ `pages`
    # 
    # ```ruby
    # def onContentsModified(pages)
    #   puts "onContentsModified: #{pages}"
    # end
    # ```
    def onContentsModified: (Sketchup::Pages pages) -> void

    # The {#onElementAdded} method is invoked when an element is added to a
    # {Sketchup::Pages} object.
    # 
    # _@param_ `pages`
    # 
    # _@param_ `page`
    # 
    # ```ruby
    # def onElementAdded(pages, page)
    #   puts "onElementAdded: #{page}"
    # end
    # ```
    def onElementAdded: (Sketchup::Pages pages, Sketchup::Page page) -> void

    # The {#onElementRemoved} method is invoked when an element is removed from a
    # {Sketchup::Pages} object.
    # 
    # _@param_ `pages`
    # 
    # _@param_ `page`
    # 
    # ```ruby
    # def onElementRemoved(pages, page)
    #   puts "onElementRemoved: #{page}"
    # end
    # ```
    def onElementRemoved: (Sketchup::Pages pages, Sketchup::Page page) -> void
  end

  # The TextureWriter class is used primarily for writing the textures used in a
  # SketchUp model out to files as part of an export for use in another
  # application. These methods are usually invoked in this order:
  # 
  #   - 1. load - load one or more textures from a model into the TextureWriter.
  #   - 2. write_all or write - write the texture(s) to file.
  # 
  # @example
  #   # This code snippet sets up a texture writer and some variables that are
  #   # used in the following texture writer examples.
  #   # Assumptions:
  #   # 1) The active model contains at least one entity at the root level of the
  #   #    following types: component instance, group, or image.
  #   # 2) The active model contains at least one face at the root level.
  #   model = Sketchup.active_model
  #   entities = model.entities
  #   faces = entities.grep(Sketchup::Face)
  #   texturable_entities = entities.select{ |ent|
  #       (ent.is_a?(Sketchup::ComponentInstance) ||
  #        ent.is_a?(Sketchup::Group) || ent.is_a?(Sketchup::Image)) }
  #   tw = Sketchup.create_texture_writer
  # 
  # @version SketchUp 6.0
  class TextureWriter
    # The {#length} method is used to determine the number of textures loaded into
    # the texture writer.
    # 
    # The {#count} method is an alias for {#length}.
    # 
    # _@return_ — length - the number of textures loaded in the texture
    # writer
    # 
    # ```ruby
    # length = tw.length
    # tw.load(texturable_entities[0])
    # if length < tw.length
    #   puts("A new entity was successfully loaded into the writer.")
    # end
    # ```
    def count: () -> Integer

    # The filename method is used to retrieve the original filename for a
    # particular texture.
    # 
    # _@param_ `handle` — The index or handle of the texture in the texture writer.
    # 
    # _@return_ — filename - the filename of the texture on the file system.
    # Textures can be generated without filenames, so if the
    # texture doesn't have a name write_all will save the
    # texture to an image file named "i.png". Where i is the
    # first integer greater than zero which was not already used
    # for a png file name.
    # 
    # ```ruby
    # index = tw.load(texturable_entities[0])
    # filename = tw.filename(index)
    # puts("filename = #{filename}")
    # ```
    def filename: (Integer handle) -> String

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The handle method is used to retrieve a handle or index for a specific
    # texture in the texture writer.
    # 
    # ```ruby
    # tw.load(texturable_entities[0])
    # handle = tw.handle(texturable_entities[0])
    # ```
    # 
    # ```ruby
    # load_front_face = true
    # tw.load(faces[0], load_front_face)
    # handle = tw.handle(faces[0], load_front_face)
    # ```
    def handle: (*untyped args) -> untyped

    # The {#length} method is used to determine the number of textures loaded into
    # the texture writer.
    # 
    # The {#count} method is an alias for {#length}.
    # 
    # _@return_ — length - the number of textures loaded in the texture
    # writer
    # 
    # ```ruby
    # length = tw.length
    # tw.load(texturable_entities[0])
    # if length < tw.length
    #   puts("A new entity was successfully loaded into the writer.")
    # end
    # ```
    def length: () -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The load method is used to load one or more textures into the texture writer
    # for writing out to a file.
    # 
    # ```ruby
    # index = tw.load(texturable_entities[0])
    # ```
    # 
    # ```ruby
    # index = tw.load(faces[0], true)
    # ```
    # 
    # _@note_ — If you are passing a face in as the entity argument when loading a
    # texture you will have to specify the second boolean argument, side.
    # The argument side specifies which side of the face the texture will be
    # loaded from.
    def load: (*untyped args) -> untyped

    # sord omit - no YARD type given for "*args", using untyped
    # sord omit - no YARD return type given, using untyped
    # The write method is used to write an individual textures, within the texture
    # writer, to a file. An entity's texture must have been loaded into the texture
    # writer before this method can be used to write it's texture.
    # 
    # This method will return one of the following status messages. (These are
    # constants that are defined by the API.)
    # 
    #   - 0 = FILE_WRITE_OK
    #   - 1 = FILE_WRITE_FAILED_INVALID_TIFF
    #   - 2 = FILE_WRITE_FAILED_UNKNOWN
    # 
    # ```ruby
    # tw.load(texturable_entities[0])
    # if tw.write(texturable_entities[0], "C:\\textures\\A.jpg") == FILE_WRITE_OK
    #   puts("JPEG file successfully written.")
    # end
    # ```
    # 
    # ```ruby
    # tw.load(faces[0], true)
    # if tw.write(faces[0], true, "C:\\textures\\Face.png") == FILE_WRITE_OK
    #   puts("PNG file successfully written.")
    # end
    # if tw.write(faces[0], true, "C:\\textures\\Face.bmp") == FILE_WRITE_OK
    #   puts("BMP file successfully written.")
    # end
    # if tw.write(faces[0], true, "C:\\textures\\Face.tif") == FILE_WRITE_OK
    #   puts("TIFF file successfully written.")
    # end
    # ```
    # 
    # _@note_ — If you are passing a face in as the entity argument when writing a
    # texture you will have to specify the boolean argument, side. The argument
    # side controls the side of the face from which the texture will be sampled
    # before writing it.
    def write: (*untyped args) -> untyped

    # The write_all method is used to write all of the textures within the texture
    # writer to files. It will return one of three status numbers:
    # 
    #   - 0 = FILE_WRITE_OK
    #   - 1 = FILE_WRITE_FAILED_INVALID_TIFF
    #   - 2 = FILE_WRITE_FAILED_UNKNOWN
    # 
    # _@param_ `dirname` — The directory to write to.
    # 
    # _@param_ `filename_format` — true to use 8.3 DOS name format.
    # 
    # _@return_ — status - one of three status messages (see comments.)
    # 
    # ```ruby
    # tw.load(texturable_entities[0]
    # tw.load(faces[0], false)
    # if tw.write_all("C:\\textures\\", true) == FILE_WRITE_OK
    #   puts("Texture files were successfully written.")
    # end
    # ```
    def write_all: (String dirname, bool filename_format) -> Integer
  end

  # This observer interface is implemented to react to tool events.
  # 
  # Some of the code below mentions +tool_names+ and +tool_ids+. Here is a list
  # of the common tool IDs and names:
  # 
  # - +21013+ = 3DTextTool
  # - +21065+ = ArcTool
  # - +10523+ = CameraDollyTool
  # - +10508+ = CameraOrbitTool
  # - +10525+ = CameraPanTool
  # - +21169+ = PositionCameraTool
  # - +10520+ = CameraWalkTool
  # - +10509+ = CameraZoomTool
  # - +10526+ = CameraZoomWindowTool
  # - +21096+ = CircleTool
  # - +21013+ = ComponentTool
  # - +21126+ = ComponentCSTool
  # - +21410+ = DimensionTool
  # - +21019+ = EraseTool
  # - +21031+ = FreehandTool
  # - +21525+ = ExtrudeTool
  # - +21126+ = SketchCSTool
  # - +21048+ = MoveTool
  # - +21024+ = MeasureTool
  # - +21100+ = OffsetTool
  # - +21074+ = PaintTool
  # - +21013+ = PasteTool
  # - +21095+ = PolyTool
  # - +21515+ = PositionTextureTool
  # - +21041+ = PushPullTool
  # - +21057+ = ProtractorTool
  # - +21094+ = RectangleTool
  # - +21129+ = RotateTool
  # - +21236+ = ScaleTool
  # - +21022+ = SelectionTool
  # - +21337+ = SectionPlaneTool
  # - +21020+ = SketchTool
  # - +21405+ = TextTool
  # 
  # @abstract To implement this observer, create a Ruby class of this type,
  #   override the desired methods, and add an instance of the observer to the
  #   {Sketchup::Tools} object.
  # 
  # @example
  #   # This is an example of an observer that watches tool interactions.
  #   class MyToolsObserver < Sketchup::ToolsObserver
  #     def onActiveToolChanged(tools, tool_name, tool_id)
  #       puts "onActiveToolChanged: #{tool_name}"
  #     end
  #   end
  # 
  #   # Attach the observer.
  #   Sketchup.active_model.tools.add_observer(MyToolsObserver.new)
  # 
  # @version SketchUp 6.0
  class ToolsObserver
    # Once you subclass {Sketchup::ToolsObserver} with your unique class, you can
    # override the {#onActiveToolChanged} method to receive tool change
    # notifications.
    # 
    # _@param_ `tools` — A Tools object.
    # 
    # _@param_ `tool_name` — The name of the tool.
    # 
    # _@param_ `tool_id` — The ID of the tool. This is a predefined number unique to a given tool. For example, the Materials Browser is tool_id 21074.
    # 
    # ```ruby
    # def onActiveToolChanged(tools, tool_name, tool_id)
    #   tool_name = fix_mac_tool_name(tool_name)
    #   puts "onActiveToolChanged: #{tool_name}"
    # end
    # 
    # # Returns the "correct" tool name to account for mac API differences.
    # #
    # #   Args:
    # #     tool_name     The tool name to fix
    # #
    # #   Returns
    # #     string   corrected tool name
    # def fix_mac_tool_name(tool_name)
    #   if tool_name == "eTool"
    #     tool_name = "ScaleTool"
    #   elsif tool_name == "ool"
    #     tool_name = "MoveTool"
    #   elsif tool_name == "onentCSTool"
    #     tool_name = "ComponentCSTool"
    #   elsif tool_name == "PullTool"
    #     tool_name = "PushPullTool"
    #   end
    #   return tool_name
    # end
    # ```
    # 
    # _@note_ — In SketchUp 6 and SketchUp 7.0, tool names on the Mac have some of
    # their first characters truncated. For instance, on Windows, a tool is
    # +"CameraOrbit"+. On the Mac, is comes across as +"raOrbit"+.  Therefore,
    # use the +tool_id+ to keep track of which tool you need to watch for, or use
    # logic that corrects for the error. There is an example method of one way to
    # do this shown below. (This example is not a comprehensive list of the tool
    # names.)
    def onActiveToolChanged: (Sketchup::Tools tools, String tool_name, Integer tool_id) -> void

    # The {#onToolStateChanged} method is called each time the user performs an
    # action with a tool. The actual state that is returned is an internal number
    # that varies tool to tool. If you want to watch existing tools for every
    # interaction, you will need to experiment with the tool state to determine
    # which states you care about. There is little consistency tool to tool.
    # 
    # _@param_ `tools` — A Tools object.
    # 
    # _@param_ `tool_name` — The name of the tool.
    # 
    # _@param_ `tool_id` — The ID of the tool. This is a predefined number unique to a given tool. For example, the Materials Browser is tool_id 21074.
    # 
    # _@param_ `tool_state` — A number identifying the state the tool just entered.
    # 
    # ```ruby
    # def onToolStateChanged(tools, tool_name, tool_id, tool_state)
    #   puts "onToolStateChanged: #{tool_name}:#{tool_state}"
    # end
    # ```
    # 
    # _@note_ — In SketchUp 6 and SketchUp 7, tool names on the Mac have their first
    # few characters truncated. For instance, on Windows, a tool is
    # +"CameraOrbit".+ On the Mac, is comes across as +"raOrbit"+.  Therefore,
    # use the tool_id to keep track of which tool you need to watch for, or use
    # logic that corrects for the error. This bug was fixed in SketchUp 8.0.
    def onToolStateChanged: (
                              Sketchup::Tools tools,
                              String tool_name,
                              Integer tool_id,
                              Integer tool_state
                            ) -> void
  end

  # A DefinitionList object holds a list of all of the ComponentDefinition
  # objects in a model. This class contains methods for  adding and retrieving
  # definitions from the list.
  # 
  # @version SketchUp 6.0
  class DefinitionList < Sketchup::Entity
    include Enumerable[Sketchup::ComponentDefinition]

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The [] method is used to retrieve a component definition from the list. You
    # can give an integer index in the range 0 to length, a string which
    # represents the GUID (a unique internal identifier), or a string that is
    # the name of the definition.
    # 
    # ```ruby
    # path=Sketchup.find_support_file "Bed.skp",
    #   "Components/Components Sampler/"
    # model = Sketchup.active_model
    # definitions = model.definitions
    # componentdefinition = definitions.load path
    # component = definitions[0]
    # ```
    def []: (untyped arg) -> untyped

    # The add method is used to add a new component definition to the definition
    # list with the given name.
    # 
    # _@param_ `def_name` — The new component definition to add to the definition list.
    # 
    # _@return_ — the ComponentDefinition object
    # that was added (if successful)
    # 
    # ```ruby
    # model = Sketchup.active_model
    # definitions = model.definitions
    # componentdefinition = definitions.add "BedTraditional"
    # component = definitions[0]
    # ```
    def add: (String def_name) -> Sketchup::ComponentDefinition

    # The add_observer method is used to add an observer to the current object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # definitions = Sketchup.active_model.definitions
    # status = definitions.add_observer observer
    # ```
    def add_observer: (Object observer) -> bool

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The [] method is used to retrieve a component definition from the list. You
    # can give an integer index in the range 0 to length, a string which
    # represents the GUID (a unique internal identifier), or a string that is
    # the name of the definition.
    # 
    # ```ruby
    # path=Sketchup.find_support_file "Bed.skp",
    #   "Components/Components Sampler/"
    # model = Sketchup.active_model
    # definitions = model.definitions
    # componentdefinition = definitions.load path
    # component = definitions[0]
    # ```
    def at: (untyped arg) -> untyped

    # ```ruby
    # model = Sketchup.active_model
    # definitions = model.definitions
    # number = definitions.count
    # ```
    # 
    # _@note_ — Since SketchUp 2014 the count method is inherited from Ruby's
    # +Enumerable+ mix-in module. Prior to that the {#count} method is an alias
    # for {#length}.
    # 
    # _@see_ `#length`
    def count: () -> Integer

    # The {#each} method is used to iterate through all of the component
    # definitions in the definition list.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # definitions = model.definitions
    # definitions.add("BedTraditional")
    # number = definitions.each { |definition| puts definition.name }
    # ```
    # 
    # _@note_ — Don't remove content from this collection while iterating over it with
    # {#each}. This would change the size of the collection and cause elements to
    # be skipped as the indices change. Instead copy the current collection to an
    # array using +to_a+ and then use +each+ on the array, when removing content.
    def each: () ?{ (ComponentDefinition) -> void } -> void

    # The {#import} method is used to import a (non-SketchUp) 3d model file as a definition.
    # 
    # Importers using the C API +SketchUpModelImporterInterface+ interface are supported (those in the
    # +Importers/+ directory).
    # 
    # See the {file:pages/importer_options.md Importer Options} file for information
    # on creating a valid hash for the various importers.
    # 
    # For SketchUp models, instead use {#load}.
    # 
    # _@param_ `path`
    # 
    # _@param_ `options`
    # 
    # ```ruby
    # path = "C:/circle.dwg"
    # definition = Sketchup.active_model.definitions.import(path)
    # ```
    def import: (String path, ?::Hash[untyped, untyped] options) -> Sketchup::ComponentDefinition

    # The {#length} method is used to retrieve number of component definitions in
    # the list.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # definitions = model.definitions
    # number = definitions.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # sord omit - no YARD type given for "*args", using untyped
    # The {#load} method is used to load a component from a file.
    # 
    # _@return_ — the loaded ComponentDefinition
    # 
    # ```ruby
    # path = Sketchup.find_support_file("Bed.skp",
    #   "Components/Components Sampler/")
    # model = Sketchup.active_model
    # definitions = model.definitions
    # definition = definitions.load(path)
    # ```
    def load: (*untyped args) -> Sketchup::ComponentDefinition

    # sord omit - no YARD type given for "*args", using untyped
    # The {#load_from_url} method loads a component from a location specified by
    # string url.
    # 
    # This method throws an exception if an url string is not
    # given, or an error occurs during retrieval from URL and a
    # +load_handler+ was not given. Optional second parameter +load_handler+ can be
    # used to pass in a Ruby object that responds to the following methods:
    # 
    # - +cancelled?+
    # - +onPercentChange(percent)+
    # - +onSuccess()+
    # - +onFailure(message_string)+
    # 
    # Download a component using a LoadHandler
    # ```ruby
    # class LoadHandler
    #   attr_accessor :error
    # 
    #   # @param [Float] percent
    #   def onPercentChange(percent)
    #     Sketchup::set_status_text("loading: #{percent.round}%")
    #   end
    # 
    #   def cancelled?
    #     # You could, for example, show a messagebox after X seconds asking if the
    #     # user wants to cancel the download. If this method returns true, then
    #     # the download cancels.
    #     return false
    #   end
    # 
    #   def onSuccess
    #     Sketchup::set_status_text('')
    #   end
    # 
    #   # @param [String] error_message
    #   def onFailure(error_message)
    #     self.error = error_message
    #     Sketchup::set_status_text('')
    #   end
    # end
    # 
    # # Replace this with a real URL...
    # url = 'https://www.sketchup.com/model.skp'
    # model = Sketchup.active_model
    # load_handler = LoadHandler.new
    # definition = model.definitions.load_from_url(url, load_handler)
    # 
    # if definition.nil?
    #   puts "Error: #{load_handler.error}"
    # end
    # ```
    # 
    # Workaround for macOS bug related to HtmlDialog action callbacks
    # ```ruby
    # module Example
    # 
    #   def self.open_dialog
    #     @dialog = UI::HtmlDialog.new
    #     @dialog.add_action_callback("say") { |action_context, url|
    #       self.load_component_deferred(url)
    #     }
    #     @dialog.set_file("path/to/file.html")
    #     @dialog.show
    #   end
    # 
    #   def load_component_deferred
    #     # The timer delay is enough to avoid .load_from_url from deadlocking.
    #     UI.start_timer(0, false) do
    #       self.load_component(url)
    #     end
    #   end
    # 
    #   def self.load_component(url)
    #     model = Sketchup.active_model
    #     definition = model.definitions.load_from_url(url)
    #     # ...
    #   end
    # 
    # end
    # ```
    def load_from_url: (*untyped args) -> Sketchup::ComponentDefinition

    # The purge_unused method is used to remove the unused component definitions.
    # 
    # ```ruby
    # definitions = Sketchup.active_model.definitions
    # definitions.purge_unused
    # ```
    def purge_unused: () -> Sketchup::DefinitionList

    # The {#remove} method is used to remove a component definition from the
    # definition list with the given component definition. This will remove all
    # instances of the definition.
    # 
    # _@param_ `definition`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # definitions = model.definitions
    # definition = definitions[0]
    # definitions.remove(definition)
    # ```
    def remove: (Sketchup::ComponentDefinition definition) -> bool

    # The remove_observer method is used to remove an observer from the current
    # object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # definitions = Sketchup.active_model.definitions
    # status = definitions.remove_observer observer
    # ```
    def remove_observer: (Object observer) -> bool

    # The {#size} method is an alias for {#length}.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # definitions = model.definitions
    # number = definitions.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer

    # The unique_name is used to generate a unique name for a definition based on
    # a base_name string. For example, a base_name of "Joe" might return "Joe #2"
    # 
    # _@param_ `base_name`
    # 
    # _@return_ — the unique name.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # definitions = model.definitions
    # new_name = definitions.unique_name "My Base Name"
    # ```
    def unique_name: (String base_name) -> String
  end

  # Drawingelement is a base class for an item in the model that can be
  # displayed. These items include edges, construction points, construction
  # lines, and images. Arc curves and arcs are not included because they are not
  # drawing elements by themselves, but are a composition of edges.
  # 
  # @version SketchUp 6.0
  class Drawingelement < Sketchup::Entity
    # The {#bounds} method is used to retrieve the {Geom::BoundingBox} bounding a
    # {Sketchup::Drawingelement}.
    # 
    # For a {Sketchup::Edge}, {Sketchup::ComponentInstance} and most other
    # {Sketchup::Drawingelement}s, the boundingbox follows the coordinate system
    # the drawing element is placed in.
    # For {Sketchup::ComponentDefinition}, the box bounds the contents of the
    # component and follows the component's own internal coordinate system.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # # Remember, anything that can be displayed, such as a face, is also
    # # a Drawingelement. So I can call bounds on a face because Face
    # # is a sub-class of Drawingelement.
    # boundingbox = face.bounds
    # ```
    def bounds: () -> Geom::BoundingBox

    # The casts_shadows= method is used to set the Drawingelement to cast shadows.
    # 
    # _@param_ `casts` — true if you want the Drawingelement object to cast shadows, false if you do not want the Drawingelement object to cast shadows.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 100]
    # pts[1] = [width, 0, 100]
    # pts[2] = [width, depth, 100]
    # pts[3] = [0, depth, 100]
    # # Add the face to the entities in the model.
    # face = entities.add_face pts
    # 
    # # Make the face not cast shadows.
    # status = face.casts_shadows = false
    # UI.messagebox status.to_s
    # ```
    def casts_shadows=: (bool casts) -> bool

    # The casts_shadows? method is used to determine if the Drawingelement is
    # casting shadows.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # status = face.casts_shadows?
    # UI.messagebox status.to_s
    # ```
    def casts_shadows?: () -> bool

    # The erase! method is used to erase an element from the model.
    # 
    # Erasing an Edge also erases all of the Face objects that use the Edge.
    # 
    # _@return_ — true if successful, false if unsuccessful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # status = face.erase!
    # ```
    def erase!: () -> bool

    # The hidden= method is used to set the hidden status for an element.
    # 
    # _@param_ `hidden` — true if you want to hide the element, false if you do not want to hide the element.
    # 
    # _@return_ — true if the element has been hidden, false if
    # the element has not been hidden.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # UI.messagebox "Click OK to Hide the Box"
    # status = face.hidden = true
    # ```
    def hidden=: (bool hidden) -> bool

    # The hidden? method is used to determine if the element is hidden.
    # 
    # Hidden elements are still in the model, but they are not displayed.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # status = face.hidden?
    # UI.messagebox "hidden? " + status.to_s
    # ```
    def hidden?: () -> bool

    # The layer method is used to retrieve the Layer object of the drawing
    # element.
    # 
    # _@return_ — a layer object if successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # layer = face.layer
    # ```
    def layer: () -> Sketchup::Layer

    # The layer= method is used to set the layer for the drawing element.
    # 
    # An exception is raised if you give a string that doesn't match any layer
    # name.
    # 
    # _@param_ `layer` — A layer or layer name.
    # 
    # _@return_ — the new Layer object if successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # # Add a layer
    # layer = Sketchup.active_model.layers.add "joe"
    # # Put the face on the joe layer (instead of layer 0)
    # newlayer = face.layer = layer
    # ```
    def layer=: ((Sketchup::Layer | String) layer) -> (Sketchup::Layer | String)

    # The material method is used to retrieve the material for the drawing
    # element.
    # 
    # _@return_ — the Material object if successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # material = face.material
    # ```
    def material: () -> Sketchup::Material

    # The material= method is used to set the material for the drawing
    # element.
    # 
    # _@param_ `material` — A Material, name of a material, Color, or name of a color.
    # 
    # _@return_ — the new Material object if successful
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # m = model.materials.add "Joe"
    # begin
    #   # Returns nil if not successful, path if successful.
    #   # Should return a texture object.
    #   m.texture = "c:\\My Textures\\Carpet.jpg"
    # rescue
    #   UI.messagebox $!.message
    # end
    # # You will see the material applied when you reverse the box's faces
    # material = face.material = m
    # ```
    def material=: ((Sketchup::Material | String | Sketchup::Color) material) -> (Sketchup::Material | String | Sketchup::Color)

    # The receive_shadows= method is used to set the Drawingelement to receive
    # shadows.
    # 
    # _@param_ `receive` — true if you want the Drawingelement object to receive shadows, false if not.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 100]
    # pts[1] = [width, 0, 100]
    # pts[2] = [width, depth, 100]
    # pts[3] = [0, depth, 100]
    # # Add the face to the entities in the model.
    # face = entities.add_face pts
    # 
    # # Make the face not receive shadows.
    # status = face.receives_shadows = false
    # UI.messagebox status.to_s
    # ```
    def receives_shadows=: (bool receive) -> bool

    # The receive_shadows? method is used to determine if the Drawingelement is
    # receiving shadows.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # status = face.receives_shadows?
    # UI.messagebox status.to_s
    # ```
    def receives_shadows?: () -> bool

    # The visible= method is used to set the visible status for an element. This
    # method performs an opposite function to the hidden= method.
    # 
    # _@param_ `visibility` — true if you want to hide the element, false if not
    # 
    # _@return_ — true if the element has been hidden, false if
    # the element has not been hidden.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # UI.messagebox "Click OK to Hide the Box"
    # status = face.visible = false
    # ```
    def visible=: (bool visibility) -> bool

    # The visible? method is used to get the visible status for an element.
    # 
    # ```ruby
    # depth = 100
    # width = 100
    # model = Sketchup.active_model
    # entities = model.active_entities
    # pts = []
    # pts[0] = [0, 0, 0]
    # pts[1] = [width, 0, 0]
    # pts[2] = [width, depth, 0]
    # pts[3] = [0, depth, 0]
    # # Add the face to the entities in the model
    # face = entities.add_face pts
    # UI.messagebox "Click OK to Hide the Box"
    # face.visible = false
    # UI.messagebox "Is the face visible? " + face.visible?.to_s
    # ```
    def visible?: () -> bool
  end

  # This observer interface is implemented to react to entity events.
  # 
  # @abstract To  implement this observer, create a Ruby class of this type, override the
  #   desired methods, and add an instance of the observer to the entity of
  #   interests.
  # 
  # @example
  #   class MyEntityObserver < Sketchup::EntityObserver
  #     def onEraseEntity(entity)
  #       puts "onEraseEntity: #{entity}"
  #     end
  #   end
  # 
  #   # Attach the observer. (Assumes there is an entity in the model.)
  #   Sketchup.active_model.entities[0].add_observer(MyEntityObserver.new)
  # 
  # @note The methods of this observer fire in such a way that making changes
  #   to the model while inside of them is dangerous. If you experience sudden
  #   crashes, it could be because of this observer. A potential workaround is to
  #   use a {Sketchup::ToolsObserver} to watch what the user is doing instead.
  # 
  # @version SketchUp 6.0
  class EntityObserver
    # The {#onChangeEntity} method is invoked when your entity is modified.
    # 
    # _@param_ `entity`
    # 
    # ```ruby
    # def onChangeEntity(entity)
    #   puts "onChangeEntity: #{entity}"
    # end
    # ```
    def onChangeEntity: (Sketchup::Entity entity) -> void

    # The {#onEraseEntity} method is invoked when your entity is erased.
    # 
    # _@param_ `entity`
    # 
    # ```ruby
    # def onEraseEntity(entity)
    #   puts "onEraseEntity: #{entity}"
    # end
    # ```
    def onEraseEntity: (Sketchup::Entity entity) -> void
  end

  # This observer interface is implemented to react to layers events.
  # 
  # @abstract To implement this observer, create a Ruby class of this type, override the
  #   desired methods, and add an instance of the observer to the objects of
  #   interests.
  # 
  # @example
  #   class MyLayersObserver < Sketchup::LayersObserver
  #     def onLayerAdded(layers, layer)
  #       puts "onLayerAdded: #{layer.name}"
  #     end
  #   end
  # 
  #   Sketchup.active_model.layers.add_observer(MyLayersObserver.new)
  #   Sketchup.active_model.layers.add("Hello World")
  # 
  # @version SketchUp 6.0
  class LayersObserver
    # The {#onCurrentLayerChanged} method is called when the user selects a
    # different active layer.
    # 
    # _@param_ `layers`
    # 
    # _@param_ `layer`
    # 
    # ```ruby
    # class MyLayersObserver < Sketchup::LayersObserver
    #   def onCurrentLayerChanged(layers, layer)
    #     puts "onCurrentLayerChanged: #{layer.name}"
    #   end
    # end
    # 
    # Sketchup.active_model.layers.add_observer(MyLayersObserver.new)
    # layer = Sketchup.active_model.layers.add("Hello World")
    # Sketchup.active_model.active_layer = layer
    # ```
    def onCurrentLayerChanged: (Sketchup::Layers layers, Sketchup::Layer layer) -> void

    # The {#onLayerAdded} method is called when a new layer is added to a model.
    # 
    # _@param_ `layers`
    # 
    # _@param_ `layer`
    # 
    # ```ruby
    # class MyLayersObserver < Sketchup::LayersObserver
    #   def onLayerAdded(layers, layer)
    #     puts "onLayerAdded: #{layer.name}"
    #   end
    # end
    # 
    # Sketchup.active_model.layers.add_observer(MyLayersObserver.new)
    # Sketchup.active_model.layers.add("Hello World")
    # ```
    def onLayerAdded: (Sketchup::Layers layers, Sketchup::Layer layer) -> void

    # The {#onLayerChanged} method is called when a layer is changed.
    # 
    # _@param_ `layers`
    # 
    # _@param_ `layer`
    # 
    # ```ruby
    # def onLayerChanged(layers, layer)
    #   puts "onLayerChanged: #{layer.name}"
    # end
    # 
    # Sketchup.active_model.layers.add_observer(MyLayersObserver.new)
    # layer = Sketchup.active_model.layers.add("Hello World")
    # layer.name = "Hello Universe"
    # ```
    def onLayerChanged: (Sketchup::Layers layers, Sketchup::Layer layer) -> void

    # The {#onLayerFolderAdded} method is called when a layer folder is added
    # to a model.
    # 
    # _@param_ `layers`
    # 
    # _@param_ `layer_folder`
    # 
    # ```ruby
    # class MyLayersObserver < Sketchup::LayersObserver
    #   def onLayerFolderAdded(layers, layer_folder)
    #     puts "onLayerFolderAdded: #{layer_folder.name}"
    #   end
    # end
    # 
    # model = Sketchup.active_model
    # model.layers.add_observer(MyLayersObserver.new)
    # folder = model.layers.add_folder("Hello World")
    # ```
    def onLayerFolderAdded: (Sketchup::Layers layers, Sketchup::LayerFolder layer_folder) -> void

    # The {#onLayerFolderChanged} method is called when a layer folder changes
    # one of its properties.
    # 
    # _@param_ `layers`
    # 
    # _@param_ `layer_folder`
    # 
    # ```ruby
    # class MyLayersObserver < Sketchup::LayersObserver
    #   def onLayerFolderChanged(layers, layer_folder)
    #     puts "onLayerFolderChanged: #{layer_folder.name}"
    #   end
    # end
    # 
    # model = Sketchup.active_model
    # model.layers.add_observer(MyLayersObserver.new)
    # folder = model.layers.add_folder("Hello World")
    # folder.name = "Hello Universe"
    # folder.visible = false
    # ```
    def onLayerFolderChanged: (Sketchup::Layers layers, Sketchup::LayerFolder layer_folder) -> void

    # The {#onLayerFolderRemoved} method is called when a layer folder is removed
    # from a model.
    # 
    # _@param_ `layers`
    # 
    # _@param_ `layer_folder`
    # 
    # ```ruby
    # class MyLayersObserver < Sketchup::LayersObserver
    #   def onLayerFolderRemoved(layers, layer_folder)
    #     puts "onLayerRemoved: #{layer_folder.name}"
    #   end
    # end
    # 
    # model = Sketchup.active_model
    # model.layers.add_observer(MyLayersObserver.new)
    # folder = model.layers.add_folder("Hello World")
    # model.layers.remove_folder(folder)
    # ```
    def onLayerFolderRemoved: (Sketchup::Layers layers, Sketchup::LayerFolder layer_folder) -> void

    # The {#onLayerRemoved} method is called when a layer is removed from a model.
    # 
    # _@param_ `layers`
    # 
    # _@param_ `layer`
    # 
    # ```ruby
    # class MyLayersObserver < Sketchup::LayersObserver
    #   def onLayerRemoved(layers, layer)
    #     puts "onLayerRemoved: #{layer.name}"
    #   end
    # end
    # 
    # Sketchup.active_model.layers.add_observer(MyLayersObserver.new)
    # layer = Sketchup.active_model.layers.add("Hello World")
    # Sketchup.active_model.layers.remove(layer)
    # ```
    def onLayerRemoved: (Sketchup::Layers layers, Sketchup::Layer layer) -> void

    # The {#onParentFolderChanged} method is called when a layer changes parent
    # folder.
    # 
    # _@param_ `layers`
    # 
    # _@param_ `layer`
    # 
    # ```ruby
    # class MyLayersObserver < Sketchup::LayersObserver
    #   def onParentFolderChanged(layers, layer)
    #     puts "onParentFolderChange: #{layer.name}"
    #   end
    # end
    # 
    # model = Sketchup.active_model
    # model.layers.add_observer(MyLayersObserver.new)
    # layer = model.layers.add_layer("World")
    # folder = model.layers.add_folder("Hello")
    # layer.folder = folder
    # ```
    # 
    # _@note_ — When a folder changes parent {#onLayerFolderRemoved} and
    # {#onLayerFolderAdded} triggers.
    def onParentFolderChanged: (Sketchup::Layers layers, Sketchup::Layer layer) -> void

    # The {#onRemoveAllLayers} method is called when all layer are removed from a
    # model.
    # 
    # _@param_ `layers`
    # 
    # ```ruby
    # class MyLayersObserver < Sketchup::LayersObserver
    #   def onRemoveAllLayers(layers)
    #     puts "onRemoveAllLayers: #{layers}"
    #   end
    # end
    # 
    # Sketchup.active_model.layers.add_observer(MyLayersObserver.new)
    # layer = Sketchup.active_model.layers.add("Hello World")
    # Sketchup.active_model.layers.remove(layer)
    # ```
    def onRemoveAllLayers: (Sketchup::Layers layers) -> void
  end

  # The OptionsManager class manages various kinds of OptionsProviders on a
  # Model.
  # 
  # @version SketchUp 6.0
  class OptionsManager
    include Enumerable[untyped]

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The [] method is used to get an option provider by name or index.
    # 
    # For example, to get the UnitsOptions on the Model, you could use the
    # command:
    # 
    # ```ruby
    # Sketchup.active_model.options["UnitsOptions"]
    # ```
    # 
    # ```ruby
    # model = Sketchup.active_model
    # manager = model.options
    # provider = manager[0]
    # if (provider)
    #   UI.messagebox provider.name
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def []: (untyped arg) -> untyped

    # _@return_ — integer - number of OptionsProvider objects if
    # successful
    # 
    # ```ruby
    # optionsmanager = Sketchup.active_model.options
    # number = manager.count
    # ```
    # 
    # _@note_ — Since SketchUp 2014 the count method is inherited from Ruby's
    # +Enumerable+ mix-in module. Prior to that the {#count} method is an alias
    # for {#length}.
    # 
    # _@see_ `#length`
    def count: () -> untyped

    # The each method is used to iterate through options providers.
    # 
    # _@return_ — nil
    # 
    # ```ruby
    # model = Sketchup.active_model
    # manager = model.options
    # manager.each { |provider| puts provider.name }
    # ```
    def each: () ?{ (OptionsProvider) -> void } -> untyped

    # The keys method is used to get a list of keys in the OptionsManager.
    # 
    # _@return_ — keys - Array of string keys
    # 
    # ```ruby
    # model = Sketchup.active_model
    # manager = model.options
    # optionproviderarray = manager.keys
    # if (optionproviderarray)
    #   UI.messagebox optionproviderarray
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def keys: () -> untyped

    # The {#length} method is an alias of {#size}.
    # 
    # ```ruby
    # optionsmanager = Sketchup.active_model.options
    # number = manager.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The {#size} method returns the number of {OptionsProvider} objects inside
    # this {OptionsManager}.
    # 
    # ```ruby
    # optionsmanager = Sketchup.active_model.options
    # number = manager.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer
  end

  # The Classifications class is a container/manager for all classifications in
  # a model.
  # 
  # @version SketchUp 2015
  class Classifications
    include Enumerable[untyped]

    # The [] method is used to get a classification schema by name or index.
    # 
    # _@param_ `index_or_name` — The index or name of the ClassificationSchema object.
    # 
    # _@return_ — schema - a ClassificationSchema object if
    # successful, otherwise nil.
    # 
    # ```ruby
    # # Get schema by name:
    # schema = Sketchup.active_model.classifications["IFC 2x3"]
    # 
    # # Get schema by index:
    # schema = Sketchup.active_model.classifications[1]
    # ```
    def []: (untyped index_or_name) -> untyped

    # The each method is used to iterate through loaded classification schemas.
    # 
    # _@return_ — nil
    # 
    # ```ruby
    # Sketchup.active_model.classifications.each { |schema|
    #   puts schema.name
    # }
    # ```
    def each: ()  ?{ (ClassificationSchema) -> void } -> untyped

    # The keys method is used to get a list of keys in the Classifications class,
    # which are the same as the names of the schemas.
    # 
    # _@return_ — keys - Array of string keys
    # 
    # ```ruby
    # schema_names = Sketchup.active_model.classifications.keys
    # ```
    def keys: () -> untyped

    # The {#length} method returns the number of loaded classification schemas.
    # 
    # ```ruby
    # Sketchup.active_model.classifications.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The load_schema method is used to load a classification schema into a
    # model.
    # 
    # _@param_ `file` — Full path to the schema file
    # 
    # _@return_ — True if successful.
    # 
    # ```ruby
    # c = Sketchup.active_model.classifications
    # file = Sketchup.find_support_file('IFC 4.skc', 'Classifications')
    # status = c.load_schema(file) if !file.nil?
    # ```
    def load_schema: (untyped file) -> untyped

    # The {#size} method returns the number of loaded classification schemas.
    # 
    # ```ruby
    # Sketchup.active_model.classifications.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer

    # The unload_schema method is used to unload a classification schema that was
    # previously loaded into a model.
    # 
    # _@param_ `schema_name` — Name of the schema to unload
    # 
    # _@return_ — True if successful.
    # 
    # ```ruby
    # c = Sketchup.active_model.classifications
    # status = c.unload_schema('IFC 2x3')
    # ```
    def unload_schema: (untyped schema_name) -> untyped
  end

  # The DimensionLinear class represents linear dimensions.
  # 
  # @version SketchUp 2014
  class DimensionLinear < Sketchup::Dimension
    ALIGNED_TEXT_ABOVE: untyped
    ALIGNED_TEXT_CENTER: untyped
    ALIGNED_TEXT_OUTSIDE: untyped
    TEXT_CENTERED: untyped
    TEXT_OUTSIDE_END: untyped
    TEXT_OUTSIDE_START: untyped
    ARROW_CLOSED: untyped
    ARROW_DOT: untyped
    ARROW_NONE: untyped
    ARROW_OPEN: untyped
    ARROW_SLASH: untyped

    # The aligned_text_position method returns the text position for dimensions
    # with aligned text (i.e. has_aligned_text? returns true).
    # Valid values are class constants:
    # - DimensionLinear::ALIGNED_TEXT_ABOVE
    # - DimensionLinear::ALIGNED_TEXT_CENTER
    # - DimensionLinear::ALIGNED_TEXT_OUTSIDE
    # 
    # _@return_ — an integer specifying the text position
    # 
    # ```ruby
    # pos = dim.aligned_text_position
    # if pos == Sketchup::DimensionLinear::ALIGNED_TEXT_ABOVE
    #   puts 'Text is above'
    # elsif pos == Sketchup::DimensionLinear::ALIGNED_TEXT_CENTER
    #   puts 'Text is centered'
    # elsif pos == Sketchup::DimensionLinear::ALIGNED_TEXT_OUTSIDE
    #   puts 'Text is outside'
    # end
    # ```
    def aligned_text_position: () -> untyped

    # The aligned_text_position= method is used to set the text position for
    # dimensions with aligned text (i.e. has_aligned_text? returns true).
    # Valid values are class constants:
    # - DimensionLinear::ALIGNED_TEXT_ABOVE
    # - DimensionLinear::ALIGNED_TEXT_CENTER
    # - DimensionLinear::ALIGNED_TEXT_OUTSIDE
    # 
    # _@param_ `pos` — an integer specifying the text position
    # 
    # _@return_ — the text position that was set.
    # 
    # ```ruby
    # dim.aligned_text_position = Sketchup::DimensionLinear::ALIGNED_TEXT_CENTER
    # ```
    def aligned_text_position=: (untyped pos) -> untyped

    # The end method returns the point or entity the dimension is referencing at
    # its end.
    # 
    # _@return_ — Array - An array of size 2:
    # - Entity being referenced or nil if not associated.
    # - Point3d that contains the referenced location.
    # 
    # ```ruby
    # arr = dim.end
    # if arr[0].nil?
    #   puts "No attached entity. Point is #{arr[1]}"
    # else
    #   puts "Attached entity: #{arr[0]}, at point #{arr[1]}"
    # end
    # ```
    def end: () -> untyped

    # The end= method is used to set the end point of the dimension and/or the
    # entity it is referencing.
    # 
    # _@param_ `pt_or_entity` — This parameter can take several forms: - an InputPoint - a Point3d - a Vertex - a ConstructionPoint - an array of size 2: [Edge, Point3d along the edge] - an array of size 2: [ConstructionLine, Point3d along the line]
    # 
    # _@return_ — self
    # 
    # ```ruby
    # # Reference a point
    # dim.end = [50, 10, 0]
    # # Reference end vertex of an edge
    # dim.end = edge.end
    # # Attach to an edge's midpoint
    # p0 = edge.start.position
    # p1 = edge.end.position
    # mp = Geom::Point3d.new((p0.x+p1.x)/2.0, (p0.y+p1.y)/2.0, (p0.z+p1.z)/2.0)
    # dim.end = [edge, mp]
    # ```
    def end=: (untyped pt_or_entity) -> untyped

    # The {#end_attached_to} method will return the attached end point via an array
    # containing the {Sketchup::InstancePath} and {Geom::Point3d}.
    # 
    # ```ruby
    # # Assuming you have a valid dimension selected that is attached to a
    # # component instance
    # dim = Sketchup.active_model.selection[0]
    # dim.end_attached_to
    # ```
    def end_attached_to: () -> [Sketchup::InstancePath, Geom::Point3d]?

    # sord omit - no YARD return type given, using untyped
    # The {#end_attached_to=} method will attach the ending point to the
    # {Sketchup::InstancePath} and {Geom::Point3d}.
    # 
    # _@param_ `path`
    # 
    # ```ruby
    # # Assuming you have a valid dimension selected that is attached to a
    # # component instance
    # dim = Sketchup.active_model.selection[0]
    # # get the path (instance_path, point)
    # path = dim.end_attached_to
    # instance_path = path[0]
    # instance = instance_path.to_a[0]
    # point1 = Geom::Point3d.new(0, 0, 0)
    # point2 = Geom::Point3d.new(20, 20, 20)
    # instance.definition.entities.add_edges(point1, point2)
    # edge = instance.definition.entities.grep(Sketchup::Edge).first
    # new_instance_path = Sketchup::InstancePath.new([instance, edge])
    # point2 = point2.transform(new_instance_path.transformation.inverse)
    # dim.end_attached_to = [new_instance_path, point2]
    # ```
    def end_attached_to=: ([Sketchup::InstancePath, Geom::Point3d] path) -> untyped

    # The offset_vector method returns the parallel offset vector from the
    # reference line to the dimension line measured from the 'start' reference
    # point.
    # 
    # _@return_ — offset vector as a Vector3d
    # 
    # ```ruby
    # vec = dim.offset_vector
    # puts "Offset vector is #{vec.to_s}"
    # ```
    def offset_vector: () -> untyped

    # sord omit - no YARD return type given, using untyped
    # The offset_vector= method is used to set the parallel offset vector from the
    # reference line to the dimension line measured from the 'start' reference
    # point.
    # 
    # _@param_ `offset_vector`
    # 
    # ```ruby
    # dim.offset_vector = Geom::Vector3d.new(0, 0, 10)
    # ```
    def offset_vector=: (Geom::Vector3d offset_vector) -> untyped

    # The start method returns the point or entity the dimension is referencing at
    # its start.
    # 
    # _@return_ — Array - An array of size 2:
    # - Entity being referenced or nil if not associated.
    # - Point3d that contains the referenced location.
    # 
    # ```ruby
    # arr = dim.start
    # if arr[0].nil?
    #   puts "No attached entity. Point is #{arr[1]}"
    # else
    #   puts "Attached entity: #{arr[0]}, at point #{arr[1]}"
    # end
    # ```
    def start: () -> untyped

    # The start= method is used to set the start point of the dimension and/or
    # the entity it is referencing.
    # 
    # _@param_ `pt_or_entity` — This parameter can take several forms: - an InputPoint - a Point3d - a Vertex - a ConstructionPoint - an array of size 2: [Edge, Point3d along the edge] - an array of size 2: [ConstructionLine, Point3d along the line]
    # 
    # _@return_ — self
    # 
    # ```ruby
    # # Reference a point
    # dim.start = [50, 10, 0]
    # # Reference end vertex of an edge
    # dim.start = edge.end
    # # Attach to an edge's midpoint
    # p0 = edge.start.position
    # p1 = edge.end.position
    # mp = Geom::Point3d.new((p0.x+p1.x)/2.0, (p0.y+p1.y)/2.0, (p0.z+p1.z)/2.0)
    # dim.start = [edge, mp]
    # ```
    def start=: (untyped pt_or_entity) -> untyped

    # The {#start_attached_to} method will return the attached start point via an
    # array containing the {Sketchup::InstancePath} and {Geom::Point3d}.
    # 
    # ```ruby
    # # Assuming you have a valid dimension selected that is attached to a
    # # component instance
    # dim = Sketchup.active_model.selection[0]
    # dim.start_attached_to
    # ```
    def start_attached_to: () -> [Sketchup::InstancePath, Geom::Point3d]?

    # sord omit - no YARD return type given, using untyped
    # The {#start_attached_to=} method will attach the starting point to the
    # {Sketchup::InstancePath} and {Geom::Point3d}.
    # 
    # _@param_ `path`
    # 
    # ```ruby
    # # Assuming you have a valid dimension selected that is attached to a
    # # component instance
    # dim = Sketchup.active_model.selection[0]
    # # get the path (instance_path, point)
    # path = dim.start_attached_to
    # instance_path = path[0]
    # instance = instance_path.to_a[0]
    # point1 = Geom::Point3d.new(0, 0, 0)
    # point2 = Geom::Point3d.new(20, 20, 20)
    # instance.definition.entities.add_edges(point1, point2)
    # edge = instance.definition.entities.grep(Sketchup::Edge).first
    # new_instance_path = Sketchup::InstancePath.new([instance, edge])
    # point2 = point2.transform(new_instance_path.transformation.inverse)
    # dim.start_attached_to = [new_instance_path, point2]
    # ```
    def start_attached_to=: ([Sketchup::InstancePath, Geom::Point3d] path) -> untyped

    # The text_position method returns the position of the text along the dimension
    # line. Valid values are class constants:
    # - DimensionLinear::TEXT_OUTSIDE_START
    # - DimensionLinear::TEXT_CENTERED
    # - DimensionLinear::TEXT_OUTSIDE_END
    # 
    # _@return_ — an integer specifying the text position
    # 
    # ```ruby
    # pos = dim.text_position
    # if pos == Sketchup::DimensionLinear::TEXT_OUTSIDE_START
    #   puts 'Text position is Outside start'
    # elsif pos == Sketchup::DimensionLinear::TEXT_CENTERED
    #   puts 'Text position is Centered'
    # elsif pos == Sketchup::DimensionLinear::TEXT_OUTSIDE_END
    #   puts 'Text position is Outside end'
    # end
    # ```
    def text_position: () -> untyped

    # The text_position= method is used to set the position of the text along the
    # dimension line. Valid values are class constants:
    # - DimensionLinear::TEXT_OUTSIDE_START
    # - DimensionLinear::TEXT_CENTERED
    # - DimensionLinear::TEXT_OUTSIDE_END
    # 
    # _@param_ `pos` — an integer specifying the text position
    # 
    # _@return_ — the text position that was set.
    # 
    # ```ruby
    # dim.text_position = Sketchup::DimensionLinear::TEXT_CENTERED
    # ```
    def text_position=: (untyped pos) -> untyped
  end

  # The DimensionRadial class represents radius and diameter dimensions on
  # arcs and circles.
  # 
  # @version SketchUp 2014
  class DimensionRadial < Sketchup::Dimension
    ARROW_CLOSED: untyped
    ARROW_DOT: untyped
    ARROW_NONE: untyped
    ARROW_OPEN: untyped
    ARROW_SLASH: untyped

    # The arc_curve method returns the ArcCurve object to which this dimension is
    # attached.
    # 
    # _@return_ — The ArcCurve object to which the dimension is attached.
    # 
    # ```ruby
    # arc = dim.arc_curve
    # ```
    def arc_curve: () -> untyped

    # The arc_curve= method is used to set the ArcCurve object to which this
    # dimension is attached.
    # 
    # _@param_ `arc_curve` — The ArcCurve object to which the dimension is to be attached.
    # 
    # _@return_ — The ArcCurve object to which the dimension was attached.
    # 
    # ```ruby
    # dim.arc_curve = arc
    # ```
    def arc_curve=: (untyped arc_curve) -> untyped

    # The leader_break_point method returns the break point on the leader where the
    # dimension text is attached.
    # 
    # _@return_ — the leader break point
    # 
    # ```ruby
    # pt = dim.leader_break_point
    # puts "Break point is #{pt}"
    # ```
    def leader_break_point: () -> untyped

    # The leader_break_point= method is used to set the break point on the leader
    # where the dimension text is attached.
    # 
    # _@param_ `point` — the point to be set
    # 
    # _@return_ — the point that was set
    # 
    # ```ruby
    # dim.leader_break_point = [10, 0, 0]
    # ```
    def leader_break_point=: (untyped point) -> untyped

    # The leader_points method returns the 3 significant points along the dimension
    # line in world coordinates.
    # 
    # _@return_ — Array of 3 Point3d objects. Point 0: leader break point,
    # where the text extension attaches. Point 1: attach point,
    # where leader touches the arc/circle. Point 2: opposite
    # point, where the diameter leader touches the circle on
    # the opposite side.
    # 
    # ```ruby
    # pts = dim.leader_points
    # puts "Break point is #{pts[0]}"
    # puts "Attach point is #{pts[1]}"
    # puts "Opposite point is #{pts[2]}"
    # ```
    def leader_points: () -> untyped
  end

  # The {Sketchup::EntitiesBuilder} is an interface to generate bulk geometry
  # with performance in mind.
  # 
  # This is particularly useful for importers where the geometry is already well
  # defined and one wants to recreate it without further processing.
  # 
  # Before the Entities Builder was introduced there were two ways of adding
  # geometry; the +add_*+ methods of {Sketchup::Entities} and {Geom::PolygonMesh}.
  # 
  # The former is slow as the methods perform intersection, splitting and merging
  # of overlapping geometry. This is useful when creating tools similar to the
  # Line and Rectangle tool.
  # 
  # {Geom::PolygonMesh} is fast, but it doesn't provide granular control per
  # face or edge added.
  # 
  # Entities Builder is similar to {Geom::PolygonMesh} in speed, but with the
  # flexibility of {Sketchup::Entities}'s +add_*+ methods.
  # 
  # <i>(See "Creating a triangulated grid" example)</i>
  # 
  # rdoc-image:../images/entities-builder-grid-example.png
  # 
  # @api EntitiesBuilder
  # 
  # @example Creating a triangulated grid
  #   model = Sketchup.active_model
  #   model.start_operation('Create Grid', true)
  #   model.entities.build { |builder|
  #     # Creates a grid similar to Sandbox Tools, with each square
  #     # triangulated with a soft+smooth edge.
  #     10.times { |x|
  #       10.times { |y|
  #         # 4 +--+ 3
  #         #   |\ |
  #         #   | \|
  #         # 1 +--+ 2
  #         pt1 = Geom::Point3d.new(x, y, 0)
  #         pt2 = Geom::Point3d.new(x + 1, y, 0)
  #         pt3 = Geom::Point3d.new(x + 1, y + 1, 0)
  #         pt4 = Geom::Point3d.new(x, y + 1, 0)
  #         face1 = builder.add_face([pt1, pt2, pt4])
  #         face2 = builder.add_face([pt2, pt3, pt4])
  #         material = (x + y).odd? ? 'red' : 'maroon'
  #         face1.material = material
  #         face2.material = material
  #         edge = builder.add_edge(pt2, pt4)
  #         edge.soft = true
  #         edge.smooth = true
  #       }
  #     }
  #   }
  #   model.commit_operation
  # 
  # @note Like {Geom::PolygonMesh} there is minimal validation checks made on
  #   the input to the creation of the geometry. Vertices are de-duplicated and
  #   edges sharing the same vertices will be de-duplicated. But no intersection
  #   of overlapping entities is made. It leaves a higher responsibility on the
  #   API user to produce valid geometry.
  # 
  # @note While using {Sketchup::Entities#build} it is important to not
  #   add or remove vertices by other means of the builder. Also don't modify the
  #   position of the vertices in the {Sketchup::Entities} container geometry is
  #   added to. Doing so can break the vertex-cache that de-duplicates the vertices.
  # 
  # @see file:pages/generating_geometry.md
  #   Guide on Generating Geometry
  # 
  # @see Sketchup::Entities#build
  # 
  # @see Sketchup::Entities
  # 
  # @see Geom::PolygonMesh
  # 
  # @version SketchUp 2022.0
  class EntitiesBuilder
    # sord omit - no YARD type given for "*args", using untyped
    # Adds a {Sketchup::Edge} to the {#entities} collection.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # model.entities.build { |builder|
    #   edge = builder.add_edge([0, 0, 0], [9, 0, 0])
    #   edge.material = 'red'
    # }
    # ```
    # 
    # _@note_ — Does not split intersecting faces or edges.
    # 
    # _@see_ `Sketchup::Entities#add_line`
    def add_edge: (*untyped args) -> Sketchup::Edge

    # sord omit - no YARD type given for "*args", using untyped
    # Adds a continuous set of {Sketchup::Edge}'s to the {#entities} collection.
    # 
    # _@return_ — In the array, for each pair in +points+ an edge is returned.
    # If two point are so close they are considered identical then +nil+ is returned.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # model.entities.build { |builder|
    #   edges = builder.add_edges([0, 0, 0], [6, 0, 0], [9, 0, 8]) # => 2 edges
    #   edges.each { |edge|
    #     edge.material = 'red'
    #   }
    # }
    # ```
    # 
    # _@note_ — Does not split intersecting faces or edges.
    # 
    # _@see_ `Sketchup::Entities#add_edges`
    def add_edges: (*untyped args) -> ::Array[(Sketchup::Edge | NilClass)]

    # sord omit - no YARD type given for "*args", using untyped
    # Adds a {Sketchup::Face} to the {#entities} collection.
    # 
    # Adding a simple face
    # ```ruby
    # model = Sketchup.active_model
    # model.entities.build { |builder|
    #   face = builder.add_face([[0, 0, 0], [6, 0, 0], [6, 8, 0], [0, 8, 0]])
    #   face.material = 'red'
    # }
    # ```
    # 
    # Adding an edge with two holes
    # ```ruby
    # model = Sketchup.active_model
    # model.entities.build { |builder|
    #   outer_loop = [[0, 0, 0], [8, 0, 0], [8, 9, 0], [0, 9, 0]]
    #   hole1 = [[1, 1, 0], [3, 1, 0], [3, 8, 0], [1, 8, 0]]
    #   hole2 = [[4, 1, 0], [7, 1, 0], [7, 8, 0], [4, 8, 0]]
    #   face = builder.add_face(outer_loop, holes: [hole1, hole2])
    # }
    # ```
    # 
    # _@note_ — Does not split intersecting faces or edges.
    # 
    # _@see_ `Sketchup::Entities#add_face`
    def add_face: (*untyped args) -> Sketchup::Face

    # The {Sketchup::Entities} collection the {Sketchup::EntitiesBuilder} will add
    # the geometry to.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # model.entities.build { |builder|
    #   p builder.entities == model.entities # => true
    # }
    # ```
    def entities: () -> Sketchup::Entities

    # Indicates whether the builder object is valid and can be used.
    # 
    # A builder object is only valid within the scope of the block given to
    # {Sketchup::Entities#build}.
    # 
    # When this return +false+, calling any other method on the builder will raise
    # an error.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # cached_builder = nil
    # model.entities.build { |builder|
    #   p builder.valid? # => true
    #   cached_builder = builder # Don't hold on to builder objects.
    # }
    # p cached_builder.valid? # => false
    # ```
    def valid?: () -> bool

    # sord omit - no YARD type given for "position", using untyped
    # Finds an existing {Sketchup::Vertex} for the given position, otherwise returns +nil+.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # model.entities.build { |builder|
    #   edge = builder.add_edge([1, 0, 0], [9, 0, 0])
    #   builder.vertex_at([0, 0, 0]) => nil
    #   builder.vertex_at([9, 0, 0]) => #<Sketchup::Vertex>
    # }
    # ```
    def vertex_at: (untyped position) -> Sketchup::Vertex?
  end

  # An +OptionsProvider+ class provides various kinds of options on a
  # {Sketchup::Model}. You get an +OptionsProvider+ from the
  # {Sketchup::OptionsManager}. The options are given as name/value pairs.
  # 
  # List of keys added in different SketchUp versions:
  # 
  # [+UnitsOptions+] * +AreaUnit+ (SketchUp 2019.2)
  #                  * +VolumeUnit+ (SketchUp 2019.2)
  #                  * +AreaPrecision+ (SketchUp 2020.0)
  #                  * +VolumePrecision+ (SketchUp 2020.0)
  # 
  # The +AreaUnit+ and +VolumeUnit+ options in +UnitsOptions+ only applies if
  # the +UnitFormat+ is +Length::Decimal+.
  # 
  # @version SketchUp 6.0
  class OptionsProvider
    include Enumerable[untyped]

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The [] method is used to get a value by name or index of the key.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # manager = model.options
    # provider = manager[0]
    # # Retrieves the provider at index 1
    # option = provider[1]
    # ```
    def []: (untyped arg) -> untyped

    # The []= method is used to set the value of a specific key.
    # 
    # Creates a new attribute for the given key if needed.
    # 
    # _@param_ `key` — The valid key.
    # 
    # _@param_ `value` — The value to be set.
    # 
    # _@return_ — value - the value that was set if successful, or false
    # if unsuccessful.
    # 
    # ```ruby
    # option = provider[1]=10
    # ```
    def []=: (untyped key, untyped value) -> untyped

    # The add_observer method is used to add an observer to the current object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # status = object.add_observer observer
    # ```
    def add_observer: (untyped observer) -> untyped

    # ```ruby
    # optionsprovider = Sketchup.active_model.options['UnitsOptions']
    # number = optionsprovider.count
    # ```
    # 
    # _@note_ — Since SketchUp 2014 the count method is inherited from Ruby's
    # +Enumerable+ mix-in module. Prior to that the {#count} method is an alias
    # for {#length}.
    # 
    # _@see_ `#length`
    def count: () -> Integer

    # The {#each} method is used to iterate through all of the options.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # provider = model.options['UnitsOptions']
    # provider.each { |key, value| puts "#{key} = #{value}" }
    # ```
    # 
    # _@see_ `#each_key`
    def each: () ?{ (String key, Object value) -> void } -> void

    # The {#each_key} method is used to iterate through all of the attribute keys.
    # 
    # ```ruby
    # provider.each_key { |key| puts key }
    # ```
    def each_key: () ?{ (String key) -> void } -> void

    # The {#each} method is used to iterate through all of the options.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # provider = model.options['UnitsOptions']
    # provider.each { |key, value| puts "#{key} = #{value}" }
    # ```
    # 
    # _@see_ `#each_key`
    def each_pair: () ?{ (String key, Object value) -> void } -> void

    # The each_value method is used to iterate through all of the attribute
    # values.
    # 
    # Throws an exception if there are no keys.
    # 
    # _@return_ — nil
    # 
    # ```ruby
    # provider.each_value { |value| puts value }
    # ```
    def each_value: () -> untyped

    # The {#has_key?} method is an alias for {#key?}.
    # 
    # _@param_ `name` — The name of the key you are looking for.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # provider = model.options['UnitsOptions']
    # p provider.has_key?("LengthFormat")
    # ```
    # 
    # _@see_ `#key?`
    def has_key?: (String name) -> bool

    # The {#key?} method is used to determine if the options provider has a
    # specific key.
    # 
    # _@param_ `name` — The name of the key you are looking for.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # provider = model.options['UnitsOptions']
    # p provider.key?("LengthFormat")
    # ```
    # 
    # _@see_ `#has_key?`
    def key?: (String name) -> bool

    # The keys method is used to retrieve an array with all of the attribute keys.
    # 
    # _@return_ — keys - an array of keys within the options provider if
    # successful
    # 
    # ```ruby
    # keys = provider.keys
    # key = keys[0]
    # if (key)
    #   UI.messagebox key
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def keys: () -> untyped

    # The {#length} method is an alias of {#size}.
    # 
    # ```ruby
    # optionsprovider = Sketchup.active_model.options['UnitsOptions']
    # number = optionsprovider.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The name method is used to retrieve the name of an options provider.
    # 
    # _@return_ — name - the name of the options provider if successful
    # 
    # ```ruby
    # name = provider.name
    # ```
    def name: () -> untyped

    # The remove_observer method is used to remove an observer from the current
    # object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # status = object.remove_observer observer
    # ```
    def remove_observer: (untyped observer) -> untyped

    # The {#size} method is used to retrieve the size (number of elements) of an
    # options provider.
    # 
    # ```ruby
    # optionsprovider = Sketchup.active_model.options['UnitsOptions']
    # number = optionsprovider.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer
  end

  # The ConstructionLine class contains methods for modifying construction
  # lines.  Construction lines can be infinite in length, semi-infinite (i.e.
  # infinite in one direction) or finite.
  # 
  # @version SketchUp 6.0
  class ConstructionLine < Sketchup::Drawingelement
    # The direction method retrieves a 3D vector in the direction of the
    # construction line.
    # 
    # _@return_ — vector - a Vector3d object if successful
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(0,0,0)
    # point2 = Geom::Point3d.new(20,20,20)
    # constline = entities.add_cline(point1, point2)
    # vector = constline.direction
    # if (vector)
    #   UI.messagebox(vector)
    # else
    #   UI.messagebox("Failure")
    # end
    # ```
    def direction: () -> untyped

    # The direction= method is used to set the direction of the construction line
    # to a 3D vector.
    # 
    # _@param_ `vector` — The Vector3d whose direction will be used to set the direction of the construction line.
    # 
    # _@return_ — vector - the new Vector3d object if successful
    # 
    # ```ruby
    # # Draw a construction line that points diagonally.
    # model = Sketchup.active_model
    # entities = model.active_entities
    # constline = entities.add_cline([10,10,10], [200,200,200])
    # 
    # # Create a new direction that is straight up, and redirect the line.
    # new_direction = [0, 0, 1]
    # constline.direction = new_direction
    # ```
    def direction=: (untyped vector) -> untyped

    # The end method retrieves the end point of a construction line in the form of
    # a 3D point.
    # 
    # If the construction line is infinite at the end, this returns nil.
    # 
    # _@return_ — point - a Point3d object representing the end of the
    # construction line
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(0,0,0)
    # point2 = Geom::Point3d.new(20,20,20)
    # constline = entities.add_cline(point1, point2)
    # endofline = constline.end
    # ```
    def end: () -> untyped

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The end= method is used to set the end point of the construction line. This
    # method will make the length finite at the end.
    # 
    # Set the end to nil to make the construction line infinite at the end.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(0,0,0)
    # point2 = Geom::Point3d.new(20,20,20)
    # point3 = Geom::Point3d.new(10,10,10)
    # constline = entities.add_cline(point1, point2)
    # UI.messagebox(constline.end)
    # # Will display point2
    # ```
    def end=: (untyped arg) -> untyped

    # The position method is used to retrieve a 3D point used to create a
    # construction line on an infinite construction line.
    # 
    # _@return_ — point - the Point3d object used to create the line (if
    # successful)
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(0,0,0)
    # vector = Geom::Vector3d.new(10,10,10)
    # constline = entities.add_cline(point1, vector)
    # # Returns point1 or 0,0,0
    # position = constline.position
    # ```
    def position: () -> untyped

    # The position= method is used to set a 3D point that the construction passes
    # through
    # 
    # _@param_ `point` — The Point3d object for the construction line to pass through.
    # 
    # _@return_ — point - the new Point3d object that the construction
    # line will pass through (if successful)
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(0,0,0)
    # point2 = Geom::Point3d.new(20,20,20)
    # point3 = Geom::Point3d.new(0,20,20)
    # constline = entities.add_cline(point1, point2)
    # position = constline.position = point3
    # ```
    def position=: (untyped point) -> untyped

    # The reverse! method is used to reverse the direction of the construction
    # line.
    # 
    # _@return_ — status
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(0,0,0)
    # point2 = Geom::Point3d.new(20,20,20)
    # constline = entities.add_cline(point1, point2)
    # status = constline.reverse!
    # ```
    def reverse!: () -> untyped

    # The start method is used to retrieve the starting point of a construction
    # line.
    # 
    # If the construction line is infinite at the start, this returns nil.
    # 
    # _@return_ — point - the Poin3d object representing the starting
    # point of the construction line (if successful)
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(0,0,0)
    # point2 = Geom::Point3d.new(20,20,20)
    # constline = entities.add_cline(point1, point2)
    # startofline = constline.start
    # ```
    def start: () -> untyped

    # sord omit - no YARD type given for "arg", using untyped
    # sord omit - no YARD return type given, using untyped
    # The start= method is used to set the start point of a construction line
    # making the line's length finite at the start.
    # 
    # Setting the start to nil will make the construction line infinite at the
    # start.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(0,0,0)
    # point2 = Geom::Point3d.new(20,20,20)
    # point3 = Geom::Point3d.new(5,5,5)
    # constline = entities.add_cline(point1, point2)
    # startofline = constline.start = point3
    # ```
    def start=: (untyped arg) -> untyped

    # The {#stipple} method is used to retrieve the stipple pattern used to display
    # the construction line.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(0, 0, 0)
    # point2 = Geom::Point3d.new(20, 20, 20)
    # constline = entities.add_cline(point1, point2)
    # puts constline.stipple
    # ```
    def stipple: () -> String

    # sord omit - no YARD return type given, using untyped
    # The {#stipple=} method is used to set the stipple pattern used to display
    # the construction line. The stipple pattern is given as a string.
    # 
    # Valid strings are:
    # - <code>"."</code> (Dotted Line),
    # - <code>"-"</code> (Short Dashes Line),
    # - <code>"_"</code> (Long Dashes Line),
    # - <code>"-.-"</code> (Dash Dot Dash Line).
    # 
    # _@param_ `pattern`
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(0, 0, 0)
    # point2 = Geom::Point3d.new(20, 20, 20)
    # constline = entities.add_cline(point1, point2)
    # constline.stipple = "-.-"
    # ```
    def stipple=: ((String | Integer) pattern) -> untyped
  end

  # This observer interface is implemented to react to {Sketchup::Entities}
  # collection events.
  # 
  # @abstract To implement this observer, create a Ruby class of this
  #   type, override the desired methods, and add an instance of the observer to
  #   the objects of interests.
  # 
  # @example
  #   # This is an example of an observer that watches the entities collection
  #   # new added elements and writes a message on the console.
  #   class MyEntitiesObserver < Sketchup::EntitiesObserver
  #     def onElementAdded(entities, entity)
  #       puts "onElementAdded: #{entity}"
  #     end
  #   end
  # 
  #   # Attach the observer
  #   Sketchup.active_model.entities.add_observer(MyEntitiesObserver.new)
  # 
  # @note The methods of this observer fire in such a way that making changes
  #   to the model while inside of them is dangerous. If you experience sudden
  #   crashes, it could be because of this observer. A potential workaround is to
  #   use a {Sketchup::ToolsObserver} to watch what the user is doing instead.
  # 
  # @version SketchUp 6.0
  class EntitiesObserver
    # The {#onActiveSectionPlaneChanged} method is invoked when a section plane
    # within this entities is activated or the active one is deactivated.
    # 
    # _@param_ `entities`
    # 
    # ```ruby
    # def onActiveSectionPlaneChanged(entities)
    #   sp = entities.active_section_plane
    #   if sp.nil?
    #     puts "Section plane is deactivated on #{entities}"
    #   else
    #     puts "#{sp} is activated on #{entities}"
    #   end
    # end
    # ```
    def onActiveSectionPlaneChanged: (Sketchup::Entities entities) -> void

    # The onElementAdded method is invoked when a single element is added
    # to the {Sketchup::Entities} collection.
    # 
    # _@param_ `entities`
    # 
    # _@param_ `entity`
    # 
    # ```ruby
    # def onElementAdded(entities, entity)
    #   puts "onElementAdded: #{entity}"
    # end
    # ```
    def onElementAdded: (Sketchup::Entities entities, Sketchup::Entity entity) -> void

    # The {#onElementModified} method is invoked whenever one or more elements in
    # the collection are modified.
    # 
    # _@param_ `entities`
    # 
    # _@param_ `entity`
    # 
    # ```ruby
    # def onElementModified(entities, entity)
    #   puts "onElementModified: #{entity}"
    # end
    # ```
    def onElementModified: (Sketchup::Entities entities, Sketchup::Entity entity) -> void

    # The {#onElementRemoved} method is invoked when a single element is removed
    # from the {Sketchup::Entities} collection.  Note that the entity has been
    # deleted and should not be used in anyway except to know that the entity has
    # been deleted.
    # 
    # _@param_ `entities`
    # 
    # _@param_ `entity_id` — The id of the entity that was deleted/removed.
    # 
    # ```ruby
    # def onElementRemoved(entities, entity_id)
    #   puts "onElementRemoved: #{entity_id}"
    # end
    # ```
    def onElementRemoved: (Sketchup::Entities entities, Sketchup::Entity entity_id) -> void

    # The {#onEraseEntities} method is invoked when one or more entities are erased.
    # 
    # _@param_ `entities`
    # 
    # ```ruby
    # def onEraseEntities(entities)
    #   puts "onEraseEntities: #{entities}"
    # end
    # ```
    def onEraseEntities: (Sketchup::Entities entities) -> void
  end

  # This observer interface is implemented to react to component instance
  # events.
  # 
  # Note that you may also attach {Sketchup::InstanceObserver}s to
  # {Sketchup::Group}s.
  # 
  # @abstract To implement this observer, create a Ruby class of this type,
  #   override the desired methods, and add an instance of the observer to the
  #   objects of interests.
  # 
  # @example
  #   # This is an example of an observer that watches a specific instance
  #   # for open edit actions and shows a messagebox.
  #   class MyInstanceObserver < Sketchup::InstanceObserver
  #     def onOpen(instance)
  #       puts "onOpen: #{instance}"
  #     end
  # 
  #     def onClose(instance)
  #       puts "onClose: #{instance}"
  #     end
  #   end
  # 
  #   # Attach the observer. (This example assumes that your first definition
  #   # in the model contains an instance to attach the observer to. This
  #   # example should work with a model where Sang or Bryce are present in
  #   # the template.)
  #   model = Sketchup.active_model
  #   model.definitions[0].instances[0].add_observer(MyInstanceObserver.new)
  # 
  # @version SketchUp 6.0
  class InstanceObserver < Sketchup::EntityObserver
    # The {#onClose} method is called when an instance is "closed," meaning an end
    # user was editing a component's geometry and then exited back into the
    # parent's editing space.
    # 
    # _@param_ `instance` — The instance that was just closed
    # 
    # ```ruby
    # def onClose(instance)
    #   puts "onClose: #{instance}"
    # end
    # ```
    def onClose: (Sketchup::ComponentInstance _instance) -> void

    # The {#onOpen} method is called when an instance is "opened," meaning an end
    # user has double clicked on it to edit its geometry. This is particularly
    # useful if your plugin is dynamically drawing geometry or performing
    # transformations in global space, since when in "edit component" mode all
    # transformations and positions are returned in relation to the current
    # component's origin.
    # 
    # This method will tell you when a user has entered edit mode, and you can
    # then use {Sketchup::Model#active_path} and {Sketchup::Model#edit_transform}
    # methods to determine any corrections you need to make to your
    # transformations.
    # 
    # _@param_ `instance` — The instance that was opened
    # 
    # ```ruby
    # def onOpen(instance)
    #   puts "onOpen: #{instance}"
    # end
    # ```
    def onOpen: (Sketchup::ComponentInstance _instance) -> void
  end

  # The {Sketchup::RegionalSettings} module contains methods getting information about the
  # user's locale settings.
  # 
  # Note that when you convert between units and strings you don't need to parse
  # it yourself and you can instead use {String#to_l} and {Length#to_s}.
  # 
  # @version SketchUp 2016 M1
  module RegionalSettings
    # Returns the decimal character for the current user's locale.
    # 
    # _@return_ — the decimal separator character
    # 
    # ```ruby
    # # Format a Float using the user's locale settings.
    # # Ruby's Float.to_s always use period as decimal separator.
    # formatted = 0.123.to_s.tr('.', Sketchup::RegionalSettings.decimal_separator)
    # ```
    def self.decimal_separator: () -> String

    # Returns the list separator character for the current user's locale.
    # 
    # _@return_ — the list separator character
    # 
    # ```ruby
    # # Format a CSV list in user's locale:
    # decimal = Sketchup::RegionalSettings.decimal_separator
    # list = Sketchup::RegionalSettings.list_separator
    # row = [3.14, 1.618, 2.718]
    # csv = row.map { |value| value.to_s.tr('.', decimal) }.join(list)
    # ```
    def self.list_separator: () -> String
  end

  # The RenderingOptions class contains method to extract the rendering
  # information for a model. The majority of the rendering information returned
  # exists in the Styles dialog. The following
  # rendering information keys are maintained in SketchUp:
  # 
  # - +BackgroundColor+
  # - +BandColor+
  # - +ConstructionColor+
  # - +DepthQueWidth+
  # - +DisplayColorByLayer+
  # - +DisplayFog+
  # - +DisplayInstanceAxes+
  # - +DisplayWatermarks+
  # - +DrawDepthQue+
  # - +DrawGround+
  # - +DrawHidden+
  # - +DrawHorizon+
  # - +DrawLineEnds+
  # - +DrawProfilesOnly+
  # - +DrawSilhouettes+
  # - +DrawUnderground+
  # - +EdgeColorMode+
  # - +EdgeDisplayMode+
  # - +EdgeType+
  # - +ExtendLines+
  # - +FaceBackColor+
  # - +FaceFrontColor+
  # - +FogColor+
  # - +FogEndDist+
  # - +FogStartDist+
  # - +FogUseBkColor+
  # - +ForegroundColor+
  # - +GroundColor+
  # - +GroundTransparency+
  # - +HideConstructionGeometry+
  # - +HighlightColor+
  # - +HorizonColor+
  # - +InactiveHidden+
  # - +InstanceHidden+
  # - +JitterEdges+
  # - +LineEndWidth+
  # - +LineExtension+
  # - +LockedColor+
  # - +MaterialTransparency+
  # - +ModelTransparency+
  # - +RenderMode+
  # - +SectionActiveColor+
  # - +SectionCutWidth+
  # - +SectionDefaultCutColor+
  # - +SectionInactiveColor+
  # - +ShowViewName+
  # - +SilhouetteWidth+
  # - +SkyColor+
  # - +Texture+
  # - +TransparencySort+ SketchUp 2017 treats Medium transparency as Faster.
  # 
  # Added in SketchUp 7:
  # - +DisplayDims+
  # - +DisplaySketchAxes+
  # - +DisplayText+
  # 
  # Added in SketchUp 8:
  # - +InactiveFade+
  # - +InstanceFade+
  # 
  # Added in SketchUp 2014:
  # - +DisplaySectionPlanes+
  # 
  # Added in SketchUp 2015:
  # - +DisplaySectionCuts+
  # - +DrawBackEdges+
  # - +SectionCutDrawEdges+
  # 
  # Added in SketchUp 2018:
  # - +SectionCutFilled+
  # - +SectionDefaultFillColor+
  # 
  # Removed in SketchUp 2019.1
  # - +FaceColorMode+ This option was previously included but it was ineffective.
  # 
  # Added in SketchUp 2020.0:
  # - +ROPDrawHiddenGeometry+
  # - +ROPDrawHiddenObjects+
  # 
  # @version SketchUp 6.0
  class RenderingOptions < Sketchup::Entity
    include Enumerable[untyped]
    ROPAssign: untyped
    ROPDrawHidden: untyped
    ROPDrawHiddenGeometry: untyped
    ROPDrawHiddenObjects: untyped
    ROPEditComponent: untyped
    ROPSectionDisplayTurnedOff: untyped
    ROPSetBackgroundColor: untyped
    ROPSetConstructionColor: untyped
    ROPSetDepthQueEdges: untyped
    ROPSetDepthQueWidth: untyped
    ROPSetDisplayColorByLayer: untyped
    ROPSetDisplayDims: untyped
    ROPSetDisplayFog: untyped
    ROPSetDisplayInstanceAxes: untyped
    ROPSetDisplaySketchAxes: untyped
    ROPSetDisplayText: untyped
    ROPSetDisplayWatermarks: untyped
    ROPSetDrawBackEdges: untyped
    ROPSetDrawGround: untyped
    ROPSetDrawHorizon: untyped
    ROPSetDrawUnderground: untyped
    ROPSetEdgeColorMode: untyped
    ROPSetEdgeDisplayMode: untyped
    ROPSetEdgeType: untyped
    ROPSetExtendEdges: untyped
    ROPSetExtendLines: untyped
    ROPSetFaceColor: untyped
    ROPSetFaceColorMode: untyped
    ROPSetFogColor: untyped
    ROPSetFogDist: untyped
    ROPSetFogHint: untyped
    ROPSetFogUseBkColor: untyped
    ROPSetForegroundColor: untyped
    ROPSetGroundColor: untyped
    ROPSetGroundTransparency: untyped
    ROPSetHideConstructionGeometry: untyped
    ROPSetHighlightColor: untyped
    ROPSetJitterEdges: untyped
    ROPSetLineEndEdges: untyped
    ROPSetLineEndWidth: untyped
    ROPSetLineExtension: untyped
    ROPSetLineStyleEdges: untyped
    ROPSetLockedColor: untyped
    ROPSetMaterialTransparency: untyped
    ROPSetModelTransparency: untyped
    ROPSetPhotomatchBackgroundOpacity: untyped
    ROPSetPhotomatchDrawBackground: untyped
    ROPSetPhotomatchDrawOverlay: untyped
    ROPSetPhotomatchOverlayOpacity: untyped
    ROPSetProfileEdges: untyped
    ROPSetProfileWidth: untyped
    ROPSetProfilesOnlyEdges: untyped
    ROPSetRenderMode: untyped
    ROPSetSectionActiveColor: untyped
    ROPSetSectionCutFilled: untyped
    ROPSetSectionCutWidth: untyped
    ROPSetSectionDefaultCutColor: untyped
    ROPSetSectionDefaultFillColor: untyped
    ROPSetSectionDisplayMode: untyped
    ROPSetSectionInactiveColor: untyped
    ROPSetSkyColor: untyped
    ROPSetTexture: untyped
    ROPSetTransparencyObsolete: untyped
    ROPSetXRayOpacity: untyped
    ROPTransparencySortMethod: untyped

    # The each_key method iterates through all of the rendering options keys.
    # 
    # ```ruby
    # Sketchup.active_model.rendering_options.each_key { |key|
    #   puts key
    # }
    # ```
    def self.each_key: () -> void

    # The keys method returns an array with all of the attribute keys.
    # 
    # _@return_ — an array of keys
    # 
    # ```ruby
    # keys = Sketchup.active_model.rendering_options.keys
    # ```
    def self.keys: () -> ::Array[String]

    # The {#[]} method is used to get the value of a rendering option.
    # 
    # _@param_ `key` — The key of the rendering option value to get.
    # 
    # ```ruby
    # result = Sketchup.active_model.rendering_options["DisplayInstanceAxes"]
    # ```
    def []: (String key) -> Object?

    # The set value []= method is used to set the value in the array of
    # rendering options.
    # 
    # _@param_ `key` — The key of the rendering option value to set.
    # 
    # _@param_ `value` — The value to be set.
    # 
    # _@return_ — the value that was set
    # 
    # ```ruby
    # Sketchup.active_model.rendering_options["DisplayInstanceAxes"] = false
    # ```
    def []=: (String key, Object value) -> Object

    # The add_observer method is used to add an observer to the current object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # observer = Sketchup::RenderingOptionsObserver.new # Dummy observer.
    # result = Sketchup.active_model.rendering_options.add_observer(observer)
    # ```
    def add_observer: (Object observer) -> bool

    # The {#count} method is inherited from the +Enumerable+ mix-in module.
    # 
    # ```ruby
    # options = Sketchup.active_model.rendering_options
    # number = options.count
    # ```
    def count: () -> Integer

    # The {#each} method iterates through all of the rendering options key/value
    # pairs.
    # 
    # ```ruby
    # Sketchup.active_model.rendering_options.each { |key, value|
    #   puts "#{key} : #{value}"
    # }
    # ```
    # 
    # _@see_ `#each_pair`
    def each: () ?{ (String key, Object value) -> void } -> void

    # The each_key method iterates through all of the rendering options keys.
    # 
    # ```ruby
    # Sketchup.active_model.rendering_options.each_key { |key|
    #   puts key
    # }
    # ```
    def each_key: () -> void

    # The {#each_pair} method is an alias for {#each}.
    # 
    # ```ruby
    # Sketchup.active_model.rendering_options.each_pair { |key, value|
    #   puts "#{key} : #{value}"
    # }
    # ```
    # 
    # _@see_ `#each`
    def each_pair: () -> void

    # The keys method returns an array with all of the attribute keys.
    # 
    # _@return_ — an array of keys
    # 
    # ```ruby
    # keys = Sketchup.active_model.rendering_options.keys
    # ```
    def keys: () -> ::Array[String]

    # The {#length} method returns the number of options in the rendering options
    # collection.
    # 
    # ```ruby
    # options = Sketchup.active_model.rendering_options
    # number = options.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The remove_observer method is used to remove an observer from the current
    # object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # observer = Sketchup::RenderingOptionsObserver.new # Dummy observer.
    # options = Sketchup.active_model.rendering_options
    # options.add_observer(observer)
    # result = options.remove_observer(observer)
    # ```
    def remove_observer: (Object observer) -> bool

    # The {#size} method is an alias for {#length}.
    # 
    # ```ruby
    # options = Sketchup.active_model.rendering_options
    # number = options.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer
  end

  # The {Sketchup::ComponentInstance} class is used to represent component
  # instances of a component definition or components that have been dragged from
  # the Component Browser and placed (thus, instanced) within the Model.
  # Therefore, the ComponentInstance class contains a reference to a
  # corresponding ComponentDefinition object and a Transformation object (which
  # contains the location of the component in the Drawing Window).
  # 
  # Starting from SketchUp 2018+, the {Sketchup::ComponentInstance} class
  # contains default attributes when created or imported. The attributes
  # are: "Owner", "Status". See the
  # {https://help.sketchup.com/en/article/3000124 Help article} for more
  # information. The dictionary cannot be deleted via ruby and an @raise ArgumentError
  # will be raised. The key/value pairs in the dictionary can be deleted safely.
  # 
  # @version SketchUp 6.0
  class ComponentInstance < Sketchup::Drawingelement
    # The add_observer method is used to add an observer to the current object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # componentinstance = entities.add_instance(definition, transformation)
    # status = componentinstance.add_observer observer
    # ```
    def add_observer: (Object observer) -> bool

    # The definition method is used to retrieve the component definition for this
    # component instance.
    # 
    # _@return_ — a ComponentDefinition object if
    # successful
    # 
    # ```ruby
    # # First create an instance for us to look at.
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # componentinstance = entities.add_instance(definition, transformation)
    # 
    # # You can get an instance's definition with this method.
    # definition = componentinstance.definition
    # ```
    def definition: () -> Sketchup::ComponentDefinition

    # The definition= method is used to set the component definition for this
    # component.
    # 
    # This method causes the instance to use a different definition, but it will
    # use the same transformation to position it in the Model.
    # 
    # _@param_ `definition` — A ComponentDefinition object to set.
    # 
    # _@return_ — the ComponentDefinition object
    # that was set if successful, false if unsuccessful
    # 
    # ```ruby
    # # Assumes that the active model contains two different components.
    # instance1 = Sketchup.active_model.entities[0]
    # instance2 = Sketchup.active_model.entities[1]
    # 
    # # Grab handles to our two definitions.
    # definition1 = instance1.definition
    # definition2 = instance2.definition
    # 
    # # Replace 2nd instance with the 1st definition.
    # instance2.definition = definition1
    # ```
    def definition=: (Sketchup::ComponentDefinition definition) -> Sketchup::ComponentDefinition

    # The equals? method is used to determine if a component instance is
    # geometrically equivalent to another instance.
    # 
    # _@param_ `instance` — The instance to compare this instance with.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # instance1 = entities[0]
    # instance2 = entities[1]
    # status = instance1.equals?(instance2)
    # ```
    def equals?: (Sketchup::ComponentInstance _instance) -> bool

    # The explode method is used to explode the component instance into separate
    # entities.
    # 
    # _@return_ — An array of entity objects if successful, false if
    # unsuccessful
    # 
    # ```ruby
    # # Assuming 'instance' is a ComponentInstance object
    # array = instance.explode
    # if array
    #   UI.messagebox "Exploded the component instance"
    # else
    #   UI.messagebox "Failure"
    # end
    # ```
    def explode: () -> ::Array[Sketchup::Entity]

    # The {#glued_to} method is used to retrieve the entity that this instance is
    # glued to.
    # 
    # ```ruby
    # point = Geom::Point3d.new(10, 20, 30)
    # transform = Geom::Transformation.new(point)
    # model = Sketchup.active_model
    # entities = model.active_entities
    # path = Sketchup.find_support_file("Bed.skp", "Components/Components Sampler/")
    # definitions = model.definitions
    # componentdefinition = definitions.load(path)
    # instance = entities.add_instance(componentdefinition, transform)
    # status = instance.glued_to
    # ```
    def glued_to: () -> (Sketchup::Face | Sketchup::Group | Sketchup::ComponentInstance | Sketchup::Image)?

    # The {glued_to=} method glues this instance to a drawing element.
    # When moving this other drawing elment with the Move tool, the glued instance moves with it.
    # 
    # In SketchUp 2021.1 support for passing {Sketchup::Group}, {Sketchup::ComponentInstance} and
    # {Sketchup::Image} was added.
    # 
    # _@param_ `drawing_element`
    # 
    # _@return_ — the entity the instance was glued to.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # 
    # # Create a face
    # face = entities.add_face([[0, 0, 0], [100, 0, 0], [100, 100, 0], [0, 100, 0]])
    # 
    # # Add component
    # path = Sketchup.find_support_file("Bed.skp", "Components/Components Sampler/")
    # point = Geom::Point3d.new(10, 10, 0)
    # transformation = Geom::Transformation.new(point)
    # definitions = model.definitions
    # definition = definitions.load(path)
    # instance = entities.add_instance(definition, transformation)
    # 
    # # Make component "gluable"
    # definition.behavior.is2d = true
    # 
    # # Glue the component to the face.
    # # If you now move the face, the component will follow.
    # instance.glued_to = face
    # ```
    def glued_to=: ((Sketchup::Face | Sketchup::Group | Sketchup::ComponentInstance | Sketchup::Image)? drawing_element) -> (Sketchup::Face | Sketchup::Group | Sketchup::ComponentInstance | Sketchup::Image)?

    # The guid method is used to get the base 64 encoded unique id
    # for this SketchUp object.
    # 
    # _@return_ — a unique 22 character string
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # componentinstance = entities.add_instance(definition, transformation)
    # guid = componentinstance.guid
    # ```
    def guid: () -> String

    # The intersect method is used to compute the boolean intersection of two
    # instances representing manifold solid volumes (this - arg).  If the specified
    # objects (this and arg) do not represent manifold volumes, this method fails.
    # 
    # _@param_ `instance` — The instance to intersect this instance with.
    # 
    # _@return_ — The resultant group if the two objects
    # (this and arg) represent manifold solids and the
    # operation succeeds otherwise nil is returned.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # instance1 = entities[0]
    # instance2 = entities[1]
    # result = instance1.intersect(instance2)
    # ```
    # 
    # _@note_ — This method is not available in SketchUp Make.
    def intersect: (Sketchup::ComponentInstance _instance) -> Sketchup::Group?

    # The locked= method is used to lock a component instance.
    # 
    # _@param_ `lock`
    # 
    # _@return_ — true if the component instance is locked.
    # False if the instance is not locked.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # componentinstance = entities.add_instance(definition, transformation)
    # status = componentinstance.locked = true
    # ```
    def locked=: (bool lock) -> bool

    # The locked? method is used to determine if a component instance is locked.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # componentinstance = entities.add_instance(definition, transformation)
    # status = componentinstance.locked?
    # ```
    def locked?: () -> bool

    # The {#make_unique} method is used to create a component definition for this
    # instance that is not used by any other instances. If the component is already
    # unique in the model, nothing happens.
    # 
    # _@return_ — returns itself
    # 
    # ```ruby
    # point = Geom::Point3d.new(10,20,30)
    # transform = Geom::Transformation.new(point)
    # model = Sketchup.active_model
    # entities = model.active_entities
    # 
    # path = Sketchup.find_support_file("Bed.skp",
    #   "Components/Components Sampler/")
    # definitions = model.definitions
    # componentdefinition = definitions.load(path)
    # instance = entities.add_instance(componentdefinition, transform)
    # # Returns unique component instance
    # instance.make_unique
    # ```
    def make_unique: () -> Sketchup::ComponentInstance

    # The manifold? method is used to determine if an instance is manifold.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # componentinstance = entities.add_instance(definition, transformation)
    # status = componentinstance.manifold?
    # ```
    def manifold?: () -> bool

    # The {#move!} method is used to set the transformation of this component
    # instance, similarly to {#transformation=} but without recording to the undo
    # stack.
    # 
    # This method is useful for moving entities inside of an animation or page
    # transition.
    # 
    # _@param_ `transformation`
    # 
    # _@return_ — true if successful, false if unsuccessful
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # componentinstance = entities.add_instance(definition, transformation)
    # new_transformation = Geom::Transformation.new([100,0,0])
    # componentinstance.move!(new_transformation)
    # ```
    # 
    # _@note_ — Despite the name being similar to {#transform!}, this method closer
    # corresponds to {#transformation=}.
    def move!: (Geom::Transformation transformation) -> bool

    # The name method is used to get the name of this instance.
    # 
    # _@return_ — the string name of the ComponentInstance
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # componentinstance = entities.add_instance(definition, transformation)
    # name = componentinstance.name
    # ```
    def name: () -> String

    # The name method is used to set the name of this instance.
    # 
    # _@param_ `name` — the string name to set
    # 
    # _@return_ — the newly named ComponentInstance
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # componentinstance = entities.add_instance(definition, transformation)
    # componentinstance.name = "Sang"
    # ```
    def name=: (String name) -> Sketchup::ComponentInstance

    # The outer_shell method is used to compute the outer shell of the two
    # instances representing manifold solid volumes (this || arg). If the specified
    # objects (this and arg) do not represent manifold volumes, this method fails.
    # 
    # _@param_ `instance` — The instance to outer shell this instance with.
    # 
    # _@return_ — The resultant group if the two objects
    # (this and arg) represent manifold solids and the
    # operation succeeds otherwise nil is returned.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # instance1 = entities[0]
    # instance2 = entities[1]
    # result = instance1.outer_shell(instance2)
    # ```
    def outer_shell: (Sketchup::ComponentInstance _instance) -> Sketchup::Group?

    # The remove_observer method is used to remove an observer from the current
    # object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # componentinstance = entities.add_instance(definition, transformation)
    # status = componentinstance.remove_observer observer
    # ```
    def remove_observer: (Object observer) -> bool

    # The show_differences method is used to determine if a component instance is
    # geometrically equivalent to another instance and in addition move the non-
    # matching and matching geometry to new layers.
    # 
    # This method will move both instances to Layer0.  Geometry that is the same
    # in both components will be moved to a new layer named def_name + "_same".
    # Geometry that is not the same will be moved to a layer named def_name +
    # "_diff".
    # 
    # If verbose is true, a list of all the geometry that is different
    # from one component to the other is displayed texturally in the Ruby Console.
    # 
    # _@param_ `instance` — The instance to be compared with.
    # 
    # _@param_ `verbose` — A boolean flag indicating whether to display a textural report of the found differences to the Ruby console.
    # 
    # _@return_ — true if the instances are geometrically
    # equivalent, otherwise false.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # instance1 = entities[0]
    # instance2 = entities[1]
    # status = instance1.show_differences(instance2, true)
    # ```
    def show_differences: (Sketchup::ComponentInstance _instance, bool verbose) -> bool

    # The split method is used to compute the boolean split (map overlay)of the two
    # instances representing manifold solid volumes (this - arg).  If the specified
    # objects (this and arg) do not represent manifold volumes, this method fails.
    # 
    # resultant groups if the two objects (this and arg) represent manifold solids and the operation
    # succeeds otherwise nil is returned. The 3 groups are as follows: The intersection of volume 1 &
    # volume 2, the difference of volume 1 minus volume 2, and the reverse difference of volume 2 minus
    # volume 1.
    # 
    # _@param_ `instance` — The instance to split this instance with.
    # 
    # _@return_ — A vector (array) of the three
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # instance1 = entities[0]
    # instance2 = entities[1]
    # result = instance1.split(instance2)
    # ```
    # 
    # _@note_ — This method is not available in SketchUp Make.
    def split: (Sketchup::ComponentInstance? _instance) -> [Sketchup::Group, Sketchup::Group, Sketchup::Group]

    # The subtract method is used to compute the boolean difference of the two
    # instances representing manifold solid volumes (this - arg).  If the specified
    # objects (this and arg) do not represent manifold volumes, this method fails.
    # 
    # _@param_ `instance` — The instance to subtract this instance from.
    # 
    # _@return_ — The resultant group if the two objects
    # (this and arg) represent manifold solids and the
    # operation succeeds otherwise nil is returned.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # instance1 = entities[0]
    # instance2 = entities[1]
    # result = instance1.subtract(instance2)
    # ```
    # 
    # _@note_ — This method is not available in SketchUp Make.
    def subtract: (Sketchup::ComponentInstance _instance) -> Sketchup::Group?

    # Apply a {Geom::Transformation} to a component instance.
    # 
    # _@param_ `transform` — The transformation object to apply to the component instance.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0, 0, 0])
    # componentinstance = entities.add_instance(definition, transformation)
    # new_transformation = Geom::Transformation.new([100, 0, 0])
    # componentinstance.transform! new_transformation
    # ```
    def transform!: (Geom::Transformation transform) -> bool

    # The transformation method is used to retrieve the transformation of this
    # instance.
    # 
    # _@return_ — the Transformation object if successful
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # componentinstance = entities.add_instance(definition, transformation)
    # t = componentinstance.transformation
    # ```
    def transformation: () -> Geom::Transformation

    # sord omit - no YARD return type given, using untyped
    # The {#transformation=} method is used to set the transformation of this
    # component instance.
    # 
    # _@param_ `transformation`
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # componentinstance = entities.add_instance(definition, transformation)
    # new_transformation = Geom::Transformation.new([100,0,0])
    # componentinstance.transformation = new_transformation
    # ```
    def transformation=: (Geom::Transformation transformation) -> untyped

    # The trim method is used to compute the (non-destructive) boolean difference
    # of the two instances representing manifold solid volumes (this - arg).  If
    # the specified objects (this and arg) do not represent manifold volumes, this
    # method fails.
    # 
    # _@param_ `instance` — The instance to trim this instance against.
    # 
    # _@return_ — The resultant group if the two objects
    # (this and arg) represent manifold solids and the
    # operation succeeds otherwise nil is returned.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # instance1 = entities[0]
    # instance2 = entities[1]
    # result = instance1.trim(instance2)
    # ```
    # 
    # _@note_ — This method is not available in SketchUp Make.
    def trim: (Sketchup::ComponentInstance _instance) -> Sketchup::Group?

    # The union method is used to compute the boolean union of the two instances
    # representing manifold solid volumes (this | arg).  If the specified
    # objects (this and arg) do not represent manifold volumes, this method fails.
    # 
    # _@param_ `instance` — The instance to union this instance with.
    # 
    # _@return_ — The resultant group if the two objects
    # (this and arg) represent manifold solids and the
    # operation succeeds otherwise nil is returned.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # instance1 = entities[0]
    # instance2 = entities[1]
    # result = instance1.union(instance2)
    # ```
    # 
    # _@note_ — This method is not available in SketchUp Make.
    def union: (Sketchup::ComponentInstance _instance) -> Sketchup::Group?

    # The volume method is used to compute the volume of this instance if and only
    # if this instance is manifold.
    # 
    # _@return_ — If the instance represents a manifold volume,
    # volume will be a positive value.  If volume is negative,
    # the instance is not manifold.
    # 
    # ```ruby
    # entities = Sketchup.active_model.entities
    # definition = Sketchup.active_model.definitions[0]
    # transformation = Geom::Transformation.new([0,0,0])
    # componentinstance = entities.add_instance(definition, transformation)
    # volume = componentinstance.volume
    # ```
    def volume: () -> Float
  end

  # A construction point represents a point in the model that can be used to aid
  # in other modeling operations. For example, you may put a construction point
  # at the center of a circle to make it easier to locate that point for
  # performing other operations.
  # 
  # @version SketchUp 6.0
  class ConstructionPoint < Sketchup::Drawingelement
    # The position method is used to retrieve a Point3d used to create a
    # construction point.
    # 
    # _@return_ — point - the Point3d object used to create the
    # ConstructionPoint
    # 
    # ```ruby
    # model = Sketchup.active_model
    # entities = model.active_entities
    # point1 = Geom::Point3d.new(10,0,0)
    # constpoint = entities.add_cpoint point1
    # # Returns 10,0,0
    # position = constpoint.position
    # ```
    def position: () -> untyped
  end

  # This observer interface is implemented to react to changes in dimension text.
  # 
  # @abstract To implement this observer, create a Ruby class of this type,
  #   override the desired methods, and add an instance of the observer to the
  #   dimensions of interest.
  # 
  # @example
  #   # This is an example of a DimensionObserver
  #   class MyDimensionObserver < Sketchup::DimensionObserver
  #     def onTextChanged(dimension)
  #       puts "onTextChanged: #{dimension}, new_text= #{dimension.text}"
  #     end
  #   end
  # 
  #   # Attach the observer. (Assumes there is a dimension in the model root.)
  #   dim = Sketchup.active_model.entities.grep(Sketchup::Dimension).first
  #   dim.add_observer(MyDimensionObserver.new)
  # 
  # @version SketchUp 2014
  class DimensionObserver
    # sord omit - no YARD return type given, using untyped
    # The {#onTextChanged} method is invoked when your entity is erased.
    # 
    # _@param_ `dimension` — The dimension object whose text has been changed.
    # 
    # ```ruby
    # def onTextChanged(dimension)
    #   puts "onTextChanged: #{dimension}, new_text= #{dimension.text}"
    # end
    # ```
    def onTextChanged: (Sketchup::Dimension dimension) -> untyped
  end

  # The ExtensionsManager class provides a way of accessing the
  # SketchupExtensions that have been registered via the
  # Sketchup.register_extension method.
  # 
  # There is only one ExtensionsManager available. You access it via the
  # Sketchup.extensions method.
  # 
  # @version SketchUp 8.0 M2
  class ExtensionsManager
    include Enumerable[SketchupExtension]

    # The [] method is used to get an extension by name, index or ID.
    # 
    # _@param_ `index_or_name` — The index, name or ID of the SketchupExtension object.
    # 
    # ```ruby
    # manager = Sketchup.extensions
    # extension = manager[1]
    # if (extension)
    #   puts extension.name
    # else
    #   puts "No Extensions installed"
    # end
    # 
    # # You can also get extensions by name.
    # solarnorth = manager['Solar North Toolbar']
    # 
    # # You can also get extensions by ID.
    # my_extension = manager['2475A758-6503-46D5-AC5E-16AEA0A3162A']
    # ```
    # 
    # _@note_ — Index starts at 1.
    def []: ((Integer | String) index_or_name) -> SketchupExtension?

    # ```ruby
    # manager = Sketchup.extensions
    # number = manager.count
    # ```
    # 
    # _@note_ — Since SketchUp 2014 the count method is inherited from Ruby's
    # +Enumerable+ mix-in module. Prior to that the {#count} method is an alias
    # for {#length}.
    # 
    # _@see_ `#length`
    def count: () -> Integer

    # The each method is used to iterate through extensions.
    # 
    # _@return_ — nil
    # 
    # ```ruby
    # manager = Sketchup.extensions
    # # Retrieves each extension
    # manager.each { |extension| puts extension.name }
    # ```
    def each: () ?{ (SketchupExtension) -> void } -> untyped

    # The keys method is used to get a list of keys in the ExtensionsManager,
    # which are the same as the names of the extensions.
    # 
    # _@return_ — keys - Array of string keys
    # 
    # ```ruby
    # manager = Sketchup.extensions
    # keys = manager.keys
    # for key in keys
    #   UI.messagebox('The next extension is named: ' + key)
    # end
    # ```
    def keys: () -> untyped

    # The {#length} method returns the number of {SketchupExtension} objects inside
    # this ExtensionsManager.
    # 
    # ```ruby
    # manager = Sketchup.extensions
    # number = manager.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The {#size} method is an alias of {#length}.
    # 
    # ```ruby
    # manager = Sketchup.extensions
    # number = manager.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer
  end

  # This observer interface is implemented to react to materials events.
  # 
  # @abstract To implement this observer, create a Ruby class of this type, override the
  #   desired methods, and add an instance of the observer to the objects of
  #   interests.
  # 
  # @example
  #   class MyMaterialsObserver < Sketchup::MaterialsObserver
  #     def onMaterialAdd(materials, material)
  #       puts "onMaterialAdd: #{material}"
  #     end
  #   end
  # 
  #   Sketchup.active_model.materials.add_observer(MyMaterialsObserver.new)
  # 
  # @note The callback +onMaterialRemoveAll+ has been deprecated, we recommend using
  #   {#onMaterialRemove} instead.
  # 
  # @version SketchUp 6.0
  class MaterialsObserver
    # The {#onMaterialAdd} method is invoked whenever a new material is added.
    # 
    # _@param_ `materials`
    # 
    # _@param_ `material`
    # 
    # ```ruby
    # def onMaterialAdd(materials, material)
    #   puts "onMaterialAdd: #{material}"
    # end
    # ```
    def onMaterialAdd: (Sketchup::Materials materials, Sketchup::Material material) -> void

    # The {#onMaterialChange} method is invoked whenever a material's texture image
    # is altered.
    # 
    # _@param_ `materials`
    # 
    # _@param_ `material`
    # 
    # ```ruby
    # def onMaterialChange(materials, material)
    #   puts "onMaterialChange: #{material}"
    # end
    # ```
    def onMaterialChange: (Sketchup::Materials materials, Sketchup::Material material) -> void

    # The {#onMaterialRefChange} method is invoked whenever the number of entities
    # that a material is painted on changes. This could be due to the user
    # manually painting something, but it could also be when faces are split,
    # pasted, push-pulled, deleted, etc.
    # 
    # _@param_ `materials`
    # 
    # _@param_ `material`
    # 
    # ```ruby
    # def onMaterialRefChange(materials, material)
    #   puts "onMaterialRefChange: #{material}"
    # end
    # ```
    def onMaterialRefChange: (Sketchup::Materials materials, Sketchup::Material material) -> void

    # The {#onMaterialRemove} method is invoked whenever a material is deleted.
    # 
    # _@param_ `materials`
    # 
    # _@param_ `material`
    # 
    # ```ruby
    # def onMaterialRemove(materials, material)
    #   puts "onMaterialRemove: #{material}"
    # end
    # ```
    def onMaterialRemove: (Sketchup::Materials materials, Sketchup::Material material) -> void

    # The {#onMaterialSetCurrent} method is invoked whenever a different material
    # is selected in the Materials dialog.
    # 
    # The materials parameter might be Nil when the material is picked from the
    # materials libraries and not yet added to the model.
    # 
    # _@param_ `materials`
    # 
    # _@param_ `material`
    # 
    # ```ruby
    # def onMaterialSetCurrent(materials, material)
    #   puts "onMaterialSetCurrent: #{material}"
    # end
    # ```
    def onMaterialSetCurrent: (Sketchup::Materials materials, Sketchup::Material material) -> void

    # The {#onMaterialUndoRedo} method is invoked whenever a material is altered
    # and then those changes are undone or redone.
    # 
    # _@param_ `materials`
    # 
    # _@param_ `material`
    # 
    # ```ruby
    # def onMaterialUndoRedo(materials, material)
    #   puts "onMaterialUndoRedo: #{material}"
    # end
    # ```
    # 
    # _@note_ — Due to a bug, this callback does not fire in SU6 or SU7. You can use
    # the {Sketchup::ModelObserver#onTransactionStart} to capture all undo
    # events.
    def onMaterialUndoRedo: (Sketchup::Materials materials, Sketchup::Material material) -> void
  end

  # This observer interface is implemented to react to selection events.
  # 
  # @abstract To implement this observer, create a Ruby class of this type, override the
  #   desired methods, and add an instance of the observer to the objects of
  #   interests.
  # 
  # @example
  #   # This is an example of an observer that watches the selection for
  #   # changes.
  #   class MySelectionObserver < Sketchup::SelectionObserver
  #     def onSelectionBulkChange(selection)
  #       puts "onSelectionBulkChange: #{selection}"
  #     end
  #   end
  # 
  #   # Attach the observer.
  #   Sketchup.active_model.selection.add_observer(MySelectionObserver.new)
  # 
  # @version SketchUp 6.0
  class SelectionObserver
    # _@param_ `selection`
    # 
    # _@param_ `entity`
    # 
    # ```ruby
    # def onSelectionAdded(selection, entity)
    #   puts "onSelectionAdded: #{entity}"
    # end
    # ```
    # 
    # _@note_ — This event might not trigger even if a single element is selected. For
    # instance the Selection tool will trigger {#onSelectionBulkChange} regardless.
    # 
    # _@see_ `onSelectionBulkChange`
    def onSelectionAdded: (Sketchup::Selection selection, Sketchup::Entity entity) -> void

    # The {#onSelectionBulkChange} method is called whenever items are added or
    # removed from the selection set.
    # 
    # The {#onSelectionBulkChange} callback will not trigger if the selection
    # is cleared by clicking on empty model space. Use the {#onSelectionCleared}
    # method to catch this case.
    # 
    # _@param_ `selection`
    # 
    # ```ruby
    # def onSelectionBulkChange(selection)
    #   puts "onSelectionBulkChange: #{selection}"
    # end
    # ```
    def onSelectionBulkChange: (Sketchup::Selection selection) -> void

    # The {#onSelectionCleared} method is called when the selection is completely
    # emptied.
    # 
    # _@param_ `selection`
    # 
    # ```ruby
    # def onSelectionCleared(selection)
    #   puts "onSelectionCleared: #{selection}"
    # end
    # ```
    def onSelectionCleared: (Sketchup::Selection selection) -> void

    # _@param_ `selection`
    # 
    # _@param_ `entity`
    # 
    # ```ruby
    # class MySelectionObserver < Sketchup::SelectionObserver
    #  def onSelectionRemoved(selection, entity)
    #    puts "onSelectionRemoved: #{entity}"
    #  end
    # 
    #  # Due to a SketchUp bug, this method is called by the wrong name.
    #  alias_method :onSelectedRemoved, :onSelectionRemoved
    # end
    # 
    # # Attach the observer.
    # Sketchup.active_model.selection.add_observer(MySelectionObserver.new)
    # ```
    # 
    # _@note_ — This event might not trigger even if a single element is deselected.
    # For instance the Selection tool will trigger {#onSelectionBulkChange}
    # regardless.
    def onSelectionRemoved: (Sketchup::Selection selection, Sketchup::Entity entity) -> void
  end

  # This observer interface is implemented to react to component definition
  # events.
  # 
  # @abstract To implement this observer, create a Ruby class of this type,
  #   override the desired methods, and add an instance of the observer to the
  #   definitions of interests.
  # 
  # @example
  #   # This is an example of an observer that watches a specific definition
  #   # for new component insertions.
  #   class MyDefObserver < Sketchup::DefinitionObserver
  #     def onComponentInstanceAdded(definition, instance)
  #       puts "onComponentInstanceAdded(#{definition}, #{instance})"
  #     end
  #   end
  # 
  #   # Attach the observer
  #   Sketchup.active_model.definitions[0].add_observer(MyDefObserver.new)
  # 
  # @version SketchUp 6.0
  class DefinitionObserver < Sketchup::EntityObserver
    # The {#onComponentInstanceAdded} method is called when a new component
    # instance is added to a model.
    # 
    # _@param_ `definition` — The definition of the added instance
    # 
    # _@param_ `instance` — The added instance
    # 
    # ```ruby
    # def onComponentInstanceAdded(definition, instance)
    #   puts "onComponentInstanceAdded(#{definition}, #{instance})"
    # end
    # ```
    def onComponentInstanceAdded: (Sketchup::ComponentDefinition definition, Sketchup::ComponentInstance _instance) -> void

    # The {#onComponentInstanceRemoved} method is called when a component
    # instance is removed from a model.
    # 
    # _@param_ `definition` — The definition of the instance removed
    # 
    # _@param_ `instance` — The removed instance
    # 
    # ```ruby
    # def onComponentInstanceRemoved(definition, instance)
    #   puts "onComponentInstanceRemoved(#{definition}, #{instance})"
    # end
    # ```
    # 
    # _@note_ — Due to the underlying way that the SketchUp Move Tool is
    # implemented, this method is fired on a Move + Copy operation even
    # though no {Sketchup::ComponentInstance} is apparently removed.
    def onComponentInstanceRemoved: (Sketchup::ComponentDefinition definition, Sketchup::ComponentInstance _instance) -> void
  end

  # This observer interface is implemented to react to changes to the shadow
  # settings.
  # 
  # @abstract To implement this observer, create a Ruby class of this type,
  #   override the desired methods, and add an instance of the observer to the
  #   {Sketchup::ShadowInfo} object.
  # 
  # @example
  #   # This is an example of an observer that watches the selection for
  #   # changes.
  #   class MyShadowInfoObserver < Sketchup::ShadowInfoObserver
  #     def onShadowInfoChanged(shadow_info, type)
  #       puts "onShadowInfoChanged: #{type}"
  #     end
  #   end
  # 
  #   # Attach the observer.
  #   Sketchup.active_model.shadow_info.add_observer(MyShadowInfoObserver.new)
  # 
  # @version SketchUp 6.0
  class ShadowInfoObserver
    # The {#onShadowInfoChanged} method is invoked whenever the user alters a
    # setting inside the Shadows and Model Info dialogs. The type parameter
    # contains a number identifying which option was altered. Here are the types to
    # expect:
    # 
    # - 0 = Time/Date sliders
    # - 1 = Display Shadows checkbox
    # - 2 = Light/Dark sliders
    # - 3 = Geographic Location (in Model Info > Location)
    # - 4 = Solar Orientation (in Model Info > Location)
    # - 7 = Use Sun for Shading checkbox
    # - 8 = Display from Edges checkbox
    # - 9 = Display on Ground checkbox
    # - 10 = Display on Faces checkbox
    # 
    # _@param_ `shadow_info`
    # 
    # _@param_ `type` — A number identifying which setting was changed.
    # 
    # ```ruby
    # def onShadowInfoChanged(shadow_info, type)
    #   puts "onShadowInfoChanged: #{type}"
    # end
    # ```
    def onShadowInfoChanged: (Sketchup::ShadowInfo shadow_info, Integer _type) -> void
  end

  # The AttributeDictionary class allows you to attach arbitrary collections of
  # attributes to a SketchUp entity. The attributes are defined by key/value
  # pairs where the keys are strings.  An Entity or Model object can have any
  # number of AttributeDictionary objects (see the AttributeDictionaries class).
  # 
  # The Entity class is a popular parent class in SketchUp, meaning you can
  # attach attribute dictionaries to almost anything, from geometric items
  # like edges and faces and components to more conceptual things like pages
  # or materials.
  # 
  # @version SketchUp 6.0
  class AttributeDictionary < Sketchup::Entity
    include Enumerable[untyped]

    # The [] method is used to retrieve the attribute with a given key.
    # 
    # _@param_ `key` — The name of the attribute.
    # 
    # _@return_ — the attribute stored under your key, or
    # nil if not found
    # 
    # ```ruby
    # model = Sketchup.active_model
    # value = model.set_attribute "testdictionary", "test", 115
    # attrdicts = model.attribute_dictionaries
    # attrdict = attrdicts["testdictionary"]
    # 
    # # value will contain 115
    # value = attrdict["test"]
    # ```
    def []: (String key) -> Object?

    # The set value ([]=) method is used to set the value of an attribute with a
    # given key.
    # 
    # Creates a new attribute for the given key if needed.
    # 
    # _@param_ `key` — The valid key.
    # 
    # _@param_ `value` — The value to be set.
    # 
    # _@return_ — the value that was set if successful, or false
    # if unsuccessful.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # value = model.set_attribute "testdictionary", "test", 110
    # attrdicts = model.attribute_dictionaries
    # attrdict = attrdicts["testdictionary"]
    # value = attrdict["test2"] = 120
    # if (value)
    #   UI.messagebox value
    # end
    # ```
    def []=: (String key, (bool | Integer | Float | Length | String | Time | ::Array[untyped] | Geom::Point3d | Geom::Vector3d)? value) -> Object?

    # The count method is inherited from the Enumerable mix-in module.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # model.set_attribute('Example', 'Hello', 'World')
    # dictionary = model.attribute_dictionary('Example')
    # number = dictionary.count
    # ```
    def count: () -> Integer

    # The delete_key method is used to delete an attribute with a given key.
    # 
    # _@param_ `key` — The key to be deleted.
    # 
    # _@return_ — the value of the key
    # 
    # ```ruby
    # create_if_nil = true
    # model = Sketchup.active_model
    # attrdict = model.attribute_dictionary("test_dict", create_if_nil)
    # attrdict["attr_one"] = "one"
    # attrdict["attr_two"] = "two"
    # 
    # # Delete a key/value pair and get the deleted value.
    # attrdict = model.attribute_dictionaries['test_dict']
    # value = attrdict.delete_key("attr_one")
    # ```
    def delete_key: (String key) -> Object?

    # sord omit - no YARD return type given, using untyped
    # The {#each} method iterate through all of the attributes.
    # 
    # ```ruby
    # create_if_nil = true
    # model = Sketchup.active_model
    # attrdict = model.attribute_dictionary("test_dict", create_if_nil)
    # attrdict["attr_one"] = "one"
    # attrdict["attr_two"] = "two"
    # 
    # # Iterates through all attributes and prints the key to the screen.
    # attrdict = model.attribute_dictionaries['test_dict']
    # attrdict.each { | key, value |
    #   puts "#{key} = #{value}"
    # }
    # ```
    # 
    # _@note_ — Don't remove content from this collection while iterating over it with
    # {#each}. This would change the size of the collection and cause elements to
    # be skipped as the indices change. Instead copy the current collection to an
    # array using +to_a+ and then use +each+ on the array, when removing content.
    # 
    # _@see_ `#each_pair`
    def each: () ?{ (String key, Object value) -> void } -> untyped

    # The {#each_key} method is used to iterate through all of the attribute keys.
    # 
    # ```ruby
    # create_if_nil = true
    # model = Sketchup.active_model
    # attrdict = model.attribute_dictionary("test_dict", create_if_nil)
    # attrdict["attr_one"] = "one"
    # attrdict["attr_two"] = "two"
    # 
    # # iterates through all attributes and prints the key to the screen
    # attrdict = model.attribute_dictionaries['test_dict']
    # attrdict.each_key { |key| puts key }
    # ```
    def each_key: () ?{ (String key) -> void } -> void

    # sord omit - no YARD return type given, using untyped
    # The {#each_pair} method is an alias for {#each}.
    # 
    # ```ruby
    # create_if_nil = true
    # model = Sketchup.active_model
    # attrdict = model.attribute_dictionary("test_dict", create_if_nil)
    # attrdict["attr_one"] = "one"
    # attrdict["attr_two"] = "two"
    # 
    # # iterates through all attributes and prints the key to the screen
    # attrdict = model.attribute_dictionaries['test_dict']
    # attrdict.each_pair { | key, value |
    #   puts "#{key} = #{value}"
    # }
    # ```
    # 
    # _@see_ `#each`
    def each_pair: () ?{ (String key, Object value) -> void } -> untyped

    # The keys method is used to retrieve an array with all of the attribute keys.
    # 
    # _@return_ — an array of keys within the attribute dictionary
    # if successful
    # 
    # ```ruby
    # create_if_nil = true
    # model = Sketchup.active_model
    # attrdict = model.attribute_dictionary "test_dict", create_if_nil
    # attrdict["attr_one"] = "one"
    # attrdict["attr_two"] = "two"
    # 
    # # Gets an array of keys
    # attrdict = model.attribute_dictionaries['test_dict']
    # keys = attrdict.keys
    # ```
    def keys: () -> ::Array[String]

    # The {#length} method is used to retrieve the size (number of elements) of an
    # attribute dictionary.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # model.set_attribute('Example', 'Hello', 'World')
    # dictionary = model.attribute_dictionary('Example')
    # number = dictionary.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The name method is used to retrieve the name of an attribute dictionary.
    # 
    # _@return_ — the name of the attribute dictionary if
    # successful
    # 
    # ```ruby
    # create_if_nil = true
    # model = Sketchup.active_model
    # attrdict = model.attribute_dictionary "test_dict", create_if_nil
    # attrdict["attr_one"] = "one"
    # attrdict["attr_two"] = "two"
    # 
    # # Show the name.
    # UI.messagebox attrdict.name
    # ```
    def name: () -> String

    # The {#size} method is an alias of {#length}.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # model.set_attribute('Example', 'Hello', 'World')
    # dictionary = model.attribute_dictionary('Example')
    # number = dictionary.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer

    # The values method is used to retrieve an array with all of the attribute
    # values.
    # 
    # _@return_ — an array of values within the attribute dictionary
    # if successful
    # 
    # ```ruby
    # create_if_nil = true
    # model = Sketchup.active_model
    # attrdict = model.attribute_dictionary "test_dict", create_if_nil
    # attrdict["attr_one"] = "one"
    # attrdict["attr_two"] = "two"
    # 
    # # Gets an array of values
    # attrdict = model.attribute_dictionaries['test_dict']
    # values = attrdict.values
    # ```
    def values: () -> ::Array[Object]
  end

  # The {Sketchup::ComponentDefinition} class is used to define the contents for
  # a SketchUp component. Components are a collection of entities that can be
  # instanced and reused multiple times throughout a model. For example, you
  # could draw a chair once, turn it into a component, and then use 6 instances
  # of it to surround a table. Edits to the original "definition" will then
  # propagate across all of its instances.
  # 
  # The ComponentDefinition class contains the global entities and settings for
  # each definition. See the {Sketchup::ComponentInstance} class for how each
  # copy is defined.
  # 
  # Starting from SketchUp 2018+, the {Sketchup::ComponentDefinition} class
  # contains a new default attribute dictionary named "SU_DefinitionSet" with
  # default keys named named "Price", "Size", "Url". See the
  # {https://help.sketchup.com/en/article/3000124 Help article} for more
  # information. The dictionary cannot be deleted via ruby and an ArgumentError
  # will be raised. The key/value pairs in the dictionary can be deleted safely.
  # 
  # @version SketchUp 6.0
  class ComponentDefinition < Sketchup::Drawingelement
    include Comparable

    # The <=> method is used to compare two ComponentDefinition objects for
    # sorting. The comparison is done based on the component name.
    # 
    # _@param_ `compdef2` — The second component definition in the comparison.
    # 
    # _@return_ — a -1 if component1 is less then component2. A 1
    # if component1 greater than component2
    # 
    # ```ruby
    # c1=Sketchup.find_support_file "Bed.skp",
    #   "Components/Components Sampler/"
    # c2=Sketchup.find_support_file "Fence.skp",
    #   "Components/Components Sampler/"
    # if c1 <=> c2
    #   UI.messagebox("c1 sorts before c2")
    # end
    # ```
    def <=>: (Sketchup::ComponentDefinition compdef2) -> Integer

    # The == method is used to test if two ComponentDefinition objects are the
    # same (based on their address in memory).
    # 
    # _@param_ `compdef2` — The second component definition in the comparison.
    # 
    # _@return_ — true if the ComponentDefinition objects are
    # the same object. False if the objects are not the same.
    # 
    # ```ruby
    # c1=Sketchup.find_support_file "Bed.skp",
    #   "Components/Components Sampler/"
    # c2=Sketchup.find_support_file "Fence.skp",
    #   "Components/Components Sampler/"
    # if c1 == c2
    #   UI.messagebox("These definitions are the same.")
    # end
    # ```
    def ==: (Sketchup::ComponentDefinition compdef2) -> bool

    # The add_classification method is used to add a given classification to
    # the component.
    # 
    # Note that you cannot classify image definitions.
    # 
    # _@param_ `schema_name` — a String - Schema name to add
    # 
    # _@param_ `schema_type` — a String - Schema type to add
    # 
    # _@return_ — true if the classification succeeds. Otherwise false.
    # 
    # ```ruby
    # definition = Sketchup.active_model.definitions.first
    # success = definition.add_classification("IFC 2x3", "IfcDoor")
    # ```
    def add_classification: (String schema_name, String schema_type) -> bool

    # The add_observer method is used to add an observer to the current object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # componentdefinition = Sketchup.active_model.definitions[0]
    # status = componentdefinition.add_observer observer
    # ```
    def add_observer: (Object observer) -> bool

    # The behavior method is used to retrieve the Behavior object associated with
    # a component definition.
    # 
    # _@return_ — a Behavior object if successful
    # 
    # ```ruby
    # path = Sketchup.find_support_file "Bed.skp",
    #   "Components/Components Sampler/"
    # model = Sketchup.active_model
    # definitions = model.definitions
    # componentdefinition = definitions.load path
    # behavior = componentdefinition.behavior
    # ```
    def behavior: () -> Sketchup::Behavior

    # The count_instances method is used to count the number of unique component
    # instances in a model using this component definition. This does not represent
    # the total number of instances placed in the model as it doesn't take into
    # account instances inside unused definitions.
    # 
    # _@return_ — the number of component instances of this
    # component definition (if successful)
    # 
    # ```ruby
    # path = Sketchup.find_support_file('Bed.skp',
    #   'Components/Components Sampler/')
    # definitions = Sketchup.active_model.definitions
    # definition = definitions.load(path)
    # number = definition.count_instances
    # ```
    def count_instances: () -> Integer

    # The count_used_instances method is used to count the total number of
    # component instances in a model using this component definition. This method
    # takes into account the full hierarchy of the model.
    # 
    # _@return_ — the number of component instances of this
    # component definition (if successful)
    # 
    # ```ruby
    # path = Sketchup.find_support_file('Bed.skp',
    #   'Components/Components Sampler/')
    # definitions = Sketchup.active_model.definitions
    # definition = definitions.load(path)
    # number = definition.count_used_instances
    # ```
    def count_used_instances: () -> Integer

    # The description method is used to retrieve the description of the component
    # definition.
    # 
    # Component definitions do not have a description, by default.
    # 
    # _@return_ — the description of the component definition if successful
    # 
    # ```ruby
    # # Get the description
    # componentdefinition = Sketchup.active_model.definitions[0]
    # description = componentdefinition.description
    # ```
    def description: () -> String

    # The description= method is used to set the description for the component
    # definition.
    # 
    # _@param_ `description`
    # 
    # _@return_ — the description if successful, false if
    # unsuccessful
    # 
    # ```ruby
    # componentdefinition = Sketchup.active_model.definitions[0]
    # componentdefinition.description = "This is a traditional bed"
    # description = componentdefinition.description
    # ```
    def description=: (String description) -> String

    # The entities method retrieves a collection of all the entities in the
    # component definition
    # 
    # _@return_ — an Entities object if successful
    # 
    # ```ruby
    # componentdefinition = Sketchup.active_model.definitions[0]
    # entities = componentdefinition.entities
    # ```
    def entities: () -> Sketchup::Entities

    # The get_classification_value method is used to retrieve the value from
    # a classification attribute given a key path.
    # 
    # _@param_ `path` — An array composed of the key path to the value.
    # 
    # _@return_ — a Ruby object if successful, nil otherwise.
    # 
    # ```ruby
    # definition = Sketchup.active_model.definitions.first
    # definition.add_classification("IFC 2x3", "IfcDoor")
    # 
    # path = ["IFC 2x3", "IfcDoor", "ObjectType", "IfcLabel"]
    # value = definition.get_classification_value(path)
    # ```
    def get_classification_value: (::Array[String] path) -> Object?

    # The group? method is used to determine if this component definition is used
    # to hold the elements of a group.
    # 
    # ```ruby
    # path = Sketchup.find_support_file "Bed.skp",
    #   "Components/Components Sampler/"
    # model = Sketchup.active_model
    # definitions = model.definitions
    # componentdefinition = definitions.load path
    # status = componentdefinition.group?
    # ```
    def group?: () -> bool

    # The guid method is used to retrieve the unique identifier of this component
    # definition. The guid changes after the component definition is modified and
    # the component edit is exited.
    # 
    # _@return_ — a string guid if successful
    # 
    # ```ruby
    # componentdefinition = Sketchup.active_model.definitions[0]
    # guid = componentdefinition.guid
    # ```
    def guid: () -> String

    # The hidden method is used to determine if this component definition should
    # be hidden on the component browser.
    # 
    # ```ruby
    # componentdefinition = Sketchup.active_model.definitions[0]
    # status = componentdefinition.hidden?
    # ```
    def hidden?: () -> bool

    # The image? method is used to determine if this component definition is used
    # to define an image.
    # 
    # ```ruby
    # componentdefinition = Sketchup.active_model.definitions[0]
    # status = componentdefinition.image?
    # if (status)
    #   UI.messagebox "Component definition defines an image"
    # else
    #   UI.messagebox status.to_s
    #   UI.messagebox "Component definition does not define an image"
    # end
    # ```
    def image?: () -> bool

    # The insertion_point method is used to retrieve the Point3d object where the
    # component was inserted.
    # 
    # _@return_ — the Point3d where the component was inserted if
    # successful. False if unsuccessful.
    # 
    # ```ruby
    # point = Geom::Point3d.new 10,20,30
    # transform = Geom::Transformation.new point
    # model = Sketchup.active_model
    # entities = model.active_entities
    # path = Sketchup.find_support_file "Bed.skp",
    #   "Components/Components Sampler/"
    # definitions = model.definitions
    # componentdefinition = definitions.load path
    # instance = entities.add_instance componentdefinition, transform
    # point = componentdefinition.insertion_point
    # ```
    # 
    # _@deprecated_ — SketchUp 2020.0 removed the insertion point feature.
    # The getter will always return the origin point and the
    # setter becomes a no-op.
    def insertion_point: () -> Geom::Point3d

    # Sets the insertion point of your definition.
    # 
    # _@param_ `point` — The Point3d object to use as the insertion point.
    # 
    # _@return_ — The Point3d object used as the insertion point.
    # 
    # ```ruby
    # point = Geom::Point3d.new(10, 20, 0)
    # componentdefinition = Sketchup.active_model.definitions[0]
    # componentdefinition.insertion_point = point
    # ```
    # 
    # _@deprecated_ — SketchUp 2020.0 removed the insertion point feature.
    # The getter will always return the origin point and the
    # setter becomes a no-op.
    def insertion_point=: (Geom::Point3d point) -> Geom::Point3d

    # The instances method is used to return any array of ComponentInstancesfor
    # this ComponentDefinition.
    # 
    # _@return_ — an array of ComponentInstances
    # (if successful)
    # 
    # ```ruby
    # componentdefinition = Sketchup.active_model.definitions[0]
    # instances = componentdefinition.instances
    # ```
    def instances: () -> ::Array[Sketchup::ComponentInstance]

    # The internal? method is used to determine if the component definition is
    # internal to the Component Browser
    # 
    # ```ruby
    # point = Geom::Point3d.new 10,20,30
    # transform = Geom::Transformation.new point
    # model = Sketchup.active_model
    # entities = model.active_entities
    # path = Sketchup.find_support_file "Bed.skp",
    #   "Components/Components Sampler/"
    # definitions = model.definitions
    # componentdefinition = definitions.load path
    # status = componentdefinition.internal?
    # ```
    def internal?: () -> bool

    # Invalidates the bounding box of your definition. This command forces the
    # update of the bounding box of definition while inside an operation.
    # See Model.start_operation for how to start an operation.
    # 
    # This method is useful if you make changes to your geometry using the Ruby
    # API and then need to know your bounding box size. This method forces
    # SketchUp to recalculate the definition's bounding box when you choose.
    # 
    # _@return_ — true if successful
    # 
    # ```ruby
    # componentdefinition = Sketchup.active_model.definitions[0]
    # componentdefinition.invalidate_bounds
    # ```
    def invalidate_bounds: () -> bool

    # The {#live_component?} method is used to identify Live Components and
    # sub-definitions of Live Components.
    # 
    # Skipping Live Components
    # ```ruby
    # model = Sketchup.active_model
    # model.definitions.each { |definition|
    #   next if definition.live_component?
    #   puts definition.name
    # }
    # ```
    # 
    # _@note_ — These components are parametrically generated and API users should not
    # modify them.
    def live_component?: () -> bool

    # The name method retrieves the name of the component definition.
    # 
    # _@return_ — the component definition's name if successful
    # 
    # ```ruby
    # path = Sketchup.find_support_file "Bed.skp",
    #   "Components/Components Sampler/"
    # model = Sketchup.active_model
    # definitions = model.definitions
    # componentdefinition = definitions.load path
    # name = componentdefinition.name
    # ```
    def name: () -> String

    # The name= method is used to set the name of the component definition.
    # 
    # _@param_ `name`
    # 
    # _@return_ — the name assigned to the component definition if
    # successful
    # 
    # ```ruby
    # path = Sketchup.find_support_file "Bed.skp",
    #   "Components/Components Sampler/"
    # model = Sketchup.active_model
    # definitions = model.definitions
    # componentdefinition = definitions.load path
    # name = componentdefinition.name="Bed"
    # ```
    def name=: (String name) -> String

    # The path method is used to retrieve the path where the component was loaded.
    # 
    # _@return_ — Returns empty string if it is an internal component.
    # 
    # ```ruby
    # path = Sketchup.find_support_file("Bed.skp", "Components/Components Sampler/")
    # model = Sketchup.active_model
    # definitions = model.definitions
    # componentdefinition = definitions.load(path)
    # path = componentdefinition.path
    # ```
    def path: () -> String

    # The refresh_thumbnail method is used to force SketchUp to regenerate the
    # thumbnail image that appears in the component browser. This is useful if
    # you've used the API to change the geometry of your component and would
    # like the thumbnail to match.
    # 
    # ```ruby
    # componentdefinition = Sketchup.active_model.definitions[0]
    # componentdefinition.refresh_thumbnail
    # ```
    def refresh_thumbnail: () -> void

    # The remove_classification method is used to remove a given classification
    # from the component.
    # 
    # Note that you cannot classify image definitions.
    # 
    # _@param_ `schema_name` — Schema name to remove
    # 
    # _@param_ `schema_type` — Schema type to remove. If not provided or an empty string, the currently applied schema type for the given schema name will be removed.
    # 
    # _@return_ — true if the removal succeeds. Otherwise false.
    # 
    # ```ruby
    # definition = Sketchup.active_model.definitions.first
    # success = definition.remove_classification("IFC 2x3", "IfcDoor")
    # ```
    def remove_classification: (String schema_name, String schema_type) -> bool

    # The remove_observer method is used to remove an observer from the current
    # object.
    # 
    # _@param_ `observer` — An observer.
    # 
    # _@return_ — true if successful, false if unsuccessful.
    # 
    # ```ruby
    # componentdefinition = Sketchup.active_model.definitions[0]
    # status = componentdefinition.remove_observer observer
    # ```
    def remove_observer: (Object observer) -> bool

    # sord omit - no YARD type given for "*args", using untyped
    # The {#save_as} method is used to save your definition as a SketchUp file at the
    # specified file destination.
    # 
    # Use this method when the user has chosen a path. If you want to "silently" save
    # out the definition, without changing the path it is associated with, use
    # {#save_copy} instead.
    # 
    # _@return_ — true if successful
    # 
    # ```ruby
    # my_definition = Sketchup.active_model.definitions[0]
    # my_definition.save_as("c:\\myComponent.skp")
    # ```
    def save_as: (*untyped args) -> bool

    # sord omit - no YARD type given for "*args", using untyped
    # The {#save_copy} method is used to save your definition as a SketchUp file
    # without changing the file path it is already associated with.
    # 
    # This can be used to save out to a temporary file used by some other process,
    # without having the temporary path permanentely written to the SketchUp
    # model.
    # 
    # _@return_ — true if successful
    # 
    # ```ruby
    # my_definition = Sketchup.active_model.definitions[0]
    # my_definition.save_copy("c:\\myComponent.skp")
    # ```
    def save_copy: (*untyped args) -> bool

    # Saves a component thumbnail image. The image format is specified by the
    # file extension of filePath. Supported image formats are bmp, jpg, png,
    # tif, pct, and gif.
    # 
    # _@param_ `filename`
    # 
    # _@return_ — true if successful, false otherwise.
    # 
    # ```ruby
    # componentdefinition = Sketchup.active_model.definitions[0]
    # componentdefinition.save_thumbnail "test_thumb.png"
    # ```
    def save_thumbnail: (String filename) -> bool

    # The set_classification_value method is used to set the value of a
    # classification attribute given a key path.
    # 
    # _@param_ `path` — An array composed of the key path to the value.
    # 
    # _@param_ `value` — A value valid for that specific attribute.
    # 
    # _@return_ — true if the path was valid, false otherwise.
    # 
    # ```ruby
    # definition = Sketchup.active_model.definitions.first
    # definition.add_classification("IFC 2x3", "IfcDoor")
    # 
    # path = ["IFC 2x3", "IfcDoor", "ObjectType", "IfcLabel"]
    # success = definition.set_classification_value(path, "Room 101")
    # ```
    def set_classification_value: (::Array[String] path, Object value) -> bool
  end

  # This observer interface is implemented to react to events on a definitions
  # collection.
  # 
  # @abstract To implement this observer, create a Ruby class of this type,
  #   override the desired methods, and add an instance of the observer to the
  #   collection of interest.
  # 
  # @example
  #   class MyDefinitionsObserver < Sketchup::DefinitionsObserver
  #     def onComponentAdded(definitions, definition)
  #       puts "onComponentAdded: #{definition.name}"
  #     end
  #   end
  # 
  #   Sketchup.active_model.definitions.add_observer(MyDefinitionsObserver.new)
  # 
  # @version SketchUp 6.0
  class DefinitionsObserver
    # The {#onComponentAdded} method is called whenever a definition is added to
    # the definitions collection.
    # 
    # _@param_ `definitions`
    # 
    # _@param_ `definition`
    # 
    # ```ruby
    # def onComponentAdded(definitions, definition)
    #   puts "onComponentAdded: #{definition}"
    # end
    # ```
    def onComponentAdded: (Sketchup::DefinitionList definitions, Sketchup::ComponentDefinition definition) -> void

    # The {#onComponentPropertiesChanged} method is called whenever a definition's
    # name or description are changed.
    # 
    # This does not fire when "Glue To", "Cuts Opening", or "Face Camera" settings
    # are changed.
    # 
    # _@param_ `definitions`
    # 
    # _@param_ `definition`
    # 
    # ```ruby
    # def onComponentPropertiesChanged(definitions, definition)
    #   puts "onComponentPropertiesChanged: #{definition}"
    # end
    # ```
    def onComponentPropertiesChanged: (Sketchup::DefinitionList definitions, Sketchup::ComponentDefinition definition) -> void

    # The {#onComponentAdded} method is called whenever a definition is removed
    # from the definitions collection.
    # 
    # _@param_ `definitions`
    # 
    # _@param_ `definition`
    # 
    # ```ruby
    # def onComponentRemoved(definitions, definition)
    #   puts "onComponentRemoved: #{definition}"
    # end
    # ```
    # 
    # _@note_ — This methods fires twice for each Component/Group erased.
    def onComponentRemoved: (Sketchup::DefinitionList definitions, Sketchup::ComponentDefinition definition) -> void

    # The {#onComponentTypeChanged} event is fired when a component is converted to
    # a group or vice versa. (In the underlying implementation, {Sketchup::Group}s
    # are just a special kind of definition that is allowed to only have a single
    # instance.)
    # 
    # _@param_ `definitions`
    # 
    # _@param_ `definition`
    # 
    # ```ruby
    # def onComponentTypeChanged(definitions, definition)
    #   puts "onComponentTypeChanged: #{definition}"
    # end
    # ```
    def onComponentTypeChanged: (Sketchup::DefinitionList definitions, Sketchup::ComponentDefinition definition) -> void
  end

  # This observer interface is implemented to react to changes in camera
  # position (a frame) between one scene page and another. This observer's
  # callback method is called when the user manually makes a scene change,
  # or the internal animation feature runs.
  # 
  # This abstract observer is any object that implements a callback method
  # +frameChange+ with 3 arguments: +from_scene+ (the scene that you
  # transition from), +to_scene+ (the scene that you transition toward)
  # and a +percent_done+ between +0.0+ and +1.0+ (that indicates the percentage
  # of transition between the two scenes.)
  # 
  #   # Basic Class Definition:
  #   class MyFrameChangeObserver
  #     def frameChange(from_scene, to_scene, percent_done)
  #      # Actual code here.
  #     end
  #   end
  # 
  # The observer is attached using the {Sketchup::Pages.add_frame_change_observer}
  # class method, which returns an integer id that can be stored and later
  # used to detach the observer.
  # 
  #   # Attach an observer to the global Pages object:
  #   @id = Sketchup::Pages.add_frame_change_observer(MyFrameChangeObserver.new)
  # 
  # Later, detaching this observer is done by passing this +id+ reference to
  # the {Sketchup::Pages.remove_frame_change_observer} class method.
  # 
  #   # Basic Observer Detachment:
  #   Sketchup::Pages.remove_frame_change_observer(@id)
  # 
  # @abstract Implement the methods described in this class to create a frame
  #   change observer. You can not sub-class this class because it is not
  #   defined by the API.
  # 
  # @example Draws a progress bar on the status line.
  #   class MyFrameChangeObserver
  #     def frameChange(from_scene, to_scene, percent_done)
  #       if percent_done == 0.0
  #         Sketchup.status_text= "% done:"
  #         if from_scene.nil? # PC bug!
  #           puts "Animating to page: '#{to_scene.name}'"
  #         else
  #           puts "From page '#{from_scene.name}' to '#{to_scene.name}'"
  #         end
  #       else
  #         Sketchup.status_text= "% done: #{'|'*(percent_done*100).to_i}"
  #         UI.messagebox("All Done!") if percent_done >= 1.0
  #       end
  #     end
  #   end
  #   @id = Sketchup::Pages.add_frame_change_observer(MyFrameChangeObserver.new)
  class FrameChangeObserver
    # This callback method is called during a slide show or creation of an
    # animation after the camera has been set up, but before the frame is
    # displayed. It gives you a chance to perform your own actions during
    # the animation. The arguments for +frameChange+ method are the scene
    # page that you transition from (+from_scene+), the scene page that you
    # transition to (+to_scene+), and a +percent_done+ between +0.0+ and +1.0+
    # that tell you the percentage of the transition between the two scene
    # pages.
    # 
    # By watching for +percent_done >= 1.0+, you can activate Ruby code that
    # executes as soon as the user's camera has finished animating.
    # 
    # _@param_ `from_scene` — The previous scene page the view is transitioning from.
    # 
    # _@param_ `to_scene` — The selected scene page the view is transitioning towards.
    # 
    # _@param_ `percent_done` — The percentage of transition between the two scene pages.
    # 
    # _@return_ — Value can be anything, but is ignored by SketchUp.
    # 
    # ```ruby
    # class MyFrameChangeObserver
    #   def frameChange(from_scene, to_scene, percent_done)
    #     if percent_done == 0.0
    #       puts "Animating to scene '#{to_scene.name}':"
    #     else
    #       puts format("% 7.2f %",percent_done*100)
    #     end
    #   end
    # end
    # @id = Sketchup::Pages.add_frame_change_observer(MyFrameChangeObserver.new)
    # ```
    # 
    # _@note_ — The +from_scene+ argument into this callback does not appear to
    # be populated on the PC. You can store a variable that keeps track of
    # the +to_scene+ and then use that on a subsequent Scene selection to
    # determine the last Page that the user was on.
    def frameChange: (Sketchup::Page? from_scene, Sketchup::Page to_scene, Float percent_done) -> void
  end

  # The ClassificationSchema class represent schemas loaded in the model.
  # 
  # @version SketchUp 2015
  class ClassificationSchema
    include Comparable

    # The <=> method is used to compare two ClassificationSchema objects for
    # sorting. The comparison is done based on the schema name.
    # 
    # _@param_ `schema2` — The second schema in the comparison.
    # 
    # _@return_ — Integer - -1 if schema1 is less then schema2. 1 if
    # schema1 is greater than schema2, 0 if the schemas
    # are equal.
    # 
    # ```ruby
    # schema1 = Sketchup.active_model.classifications["IFC 2x3"]
    # schema2 = Sketchup.active_model.classifications["gbXML"]
    # # Returns -1
    # result = schema1 <=> schema2
    # # Returns an array of sorted schemas.
    # schemas = Sketchup.active_model.classifications.to_a.sort
    # ```
    def <=>: (untyped schema2) -> untyped

    # The name method returns the name of the schema.
    # 
    # _@return_ — String - containing the schema name.
    # 
    # ```ruby
    # Sketchup.active_model.classifications.each { |schema|
    #   puts schema.name
    # }
    # ```
    def name: () -> untyped

    # The namespace method returns the namespace of the schema.
    # 
    # _@return_ — String - containing the schema namespace.
    # 
    # ```ruby
    # Sketchup.active_model.classifications.each { |schema|
    #   puts schema.namespace
    # }
    # ```
    def namespace: () -> untyped
  end

  # The AttributeDictionaries class is a collection of all of the
  # AttributeDictionary objects that are attached to a given Entity object.
  # 
  # The Entity class is a popular parent class in SketchUp, meaning you can
  # attach AttributeDictionaries to almost anything, from geometric items
  # like edges and faces and components to more conceptual things like pages
  # or materials.
  # 
  # You access this class not by performing an AttributeDictionaries.new but
  # by grabbing a handle from an existing entity.
  # 
  # @example
  #   # Grab the first entity from the model.
  #   my_layer = Sketchup.active_model.entities[0]
  # 
  #   # Grab a handle to its attribute dictionaries.
  #   attrdicts = my_layer.attribute_dictionaries
  # 
  # @version SketchUp 6.0
  class AttributeDictionaries < Sketchup::Entity
    include Enumerable[untyped]

    # Get an AttributeDictionary by name. Returns nil if there is none with the
    # given name.
    # 
    # _@param_ `key` — The name of the attribute dictionary.
    # 
    # _@return_ — the dictionary
    # 
    # ```ruby
    # model = Sketchup.active_model
    # attrdicts = model.attribute_dictionaries
    # # Iterates through all dictionaries and prints to screen.
    # dict = attrdicts['my_dictionary']
    # if dict
    #   UI.messagebox("Found: " + dict.to_s)
    # else
    #   UI.messagebox("No dictionary found.")
    # end
    # ```
    def []: (String key) -> Sketchup::AttributeDictionary

    # The count method is inherited from the Enumerable mix-in module.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # model.set_attribute('Example', 'Hello', 'World')
    # dictionaries = model.attribute_dictionaries
    # number = dictionaries.count
    # ```
    # 
    # _@see_ `#length`
    def count: () -> Integer

    # The delete method destroys a given AttributeDictionary. This
    # AttributeDictionary can be passed directly or identified by its
    # string name.
    # 
    # In SketchUp 2018, special attribute dictionaries have been added. The name of
    # these dictionaries are "SU_InstanceSet" and "SU_DefinitionSet". The
    # dictionaries cannot be deleted via ruby and an ArgumentError will be raised.
    # The key/value pairs in the dictionary can be deleted safely.
    # 
    # object
    # 
    # _@param_ `key_or_dict` — The name of the attribute dictionary to delete, or the dictionary object itself.
    # 
    # _@return_ — the modified AttributeDictionaries
    # 
    # ```ruby
    # model = Sketchup.active_model
    # attrdicts = model.attribute_dictionaries
    # # Deletes a dictionary called 'my_dictionary'
    # attrdicts.delete 'my_dictionary'
    # ```
    def delete: ((String | Sketchup::AttributeDictionary) key_or_dict) -> Sketchup::AttributeDictionaries

    # The each method is used to iterate through all of the attributes
    # dictionaries.
    # 
    # Throws an exception if there are no keys.
    # 
    # _@return_ — nil
    # 
    # ```ruby
    # model = Sketchup.active_model
    # dictionaries = model.attribute_dictionaries
    # # Iterates through all dictionaries and prints to screen.
    # dictionaries.each { |dictionary| puts dictionary.name }
    # ```
    def each: () ?{ (Sketchup::AttributeDictionary) -> void } -> untyped

    # The {#length} method returns the number of attribute dictionary objects in
    # the collection.
    # 
    # _@return_ — the number of attribute dictionary objects in the
    # collection.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # model.set_attribute('Example', 'Hello', 'World')
    # dictionaries = model.attribute_dictionaries
    # number = dictionaries.length
    # ```
    # 
    # _@see_ `#size`
    def length: () -> Integer

    # The {#size} method is an alias of {#length}.
    # 
    # ```ruby
    # model = Sketchup.active_model
    # model.set_attribute('Example', 'Hello', 'World')
    # dictionaries = model.attribute_dictionaries
    # number = dictionaries.size
    # ```
    # 
    # _@see_ `#length`
    def size: () -> Integer
  end

  # This observer interface is implemented to react to operations provider
  # events. What this means is that you can watch as the user changes SketchUp
  # options and react to them. The following {Sketchup::OptionsProviders} are
  # defined in the API:
  # 
  # - <code>"UnitsOptions"</code>
  # - <code>"PrintOptions"</code>
  # - <code>"PageOptions"</code>
  # - <code>"SlideshowOptions"</code>
  # - <code>"NamedOptions"</code>
  # 
  # Each of these has a list of specific options that the user can set. See the
  # {Sketchup::OptionsManager} and {Sketchup::OptionsProvider} classes for more
  # details.
  # 
  # @abstract To implement this observer, create a Ruby class of this type,
  #   override the desired methods, and add an instance of the observer to the
  #   objects of interests.
  # 
  # @example
  #   class MyOptionsProviderObserver < Sketchup::OptionsProviderObserver
  #     def onOptionsProviderChanged(provider, name)
  #       puts "onOptionsProviderChanged: #{name}"
  #     end
  #   end
  # 
  #   # Detect when the end user changes their units settings.
  #   options_provider = Sketchup.active_model.options["UnitsOptions"]
  #   options_provider.add_observer(MyOptionsProviderObserver.new)
  # 
  # @version SketchUp 6.0
  class OptionsProviderObserver
    # The {#onOptionsProviderChanged} method is invoked when a property of an
    # {Sketchup::OptionsProvider} changes.
    # 
    # _@param_ `provider`
    # 
    # _@param_ `name` — The name of the specific option that was changed.
    # 
    # ```ruby
    # def onOptionsProviderChanged(provider, name)
    #   puts "onOptionsProviderChanged: #{name}"
    # end
    # ```
    def onOptionsProviderChanged: (Sketchup::OptionsProvider provider, String name) -> void
  end

  # This observer interface is implemented to react to rendering options events.
  # 
  # @abstract To implement this observer, create a Ruby class of this type, implement the
  #   desired methods, and add an instance of the observer to the objects of
  #   interests.
  # 
  # @example
  #   # This is an example of an observer that watches the rendering options
  #   # for changes.
  #   class MyRenderingOptionsObserver < Sketchup::RenderingOptionsObserver
  #     def onRenderingOptionsChanged(rendering_options, type)
  #       puts "onRenderingOptionsChanged(#{rendering_options}, #{type})"
  #     end
  #   end
  # 
  #   # Attach the observer.
  #   rendering_options = Sketchup.active_model.rendering_options
  #   rendering_options.add_observer(MyRenderingOptionsObserver.new)
  class RenderingOptionsObserver
    # sord omit - no YARD return type given, using untyped
    # The onRenderingOptionsChanged method is invoked whenever the user changes
    # their rendering options.
    # 
    # _@param_ `rendering_options`
    # 
    # _@param_ `type` — A number indicating which option was changed represented by one of the constants defined in {Sketchup::RenderingOptions}.
    # 
    # ```ruby
    # def onRenderingOptionsChanged(rendering_options, type)
    #   puts "onRenderingOptionsChanged(#{rendering_options}, #{type})"
    # end
    # ```
    def onRenderingOptionsChanged: (Sketchup::RenderingOptions rendering_options, Integer _type) -> untyped
  end
end

# The LanguageHandler class contains methods used to help make SketchUp
# extensions easier to localize across different languages. It looks for
# translated resources within the Resources folder in the extension's directory
# structure. All translated resources should be located within the appropriate
# language folder and encoded in UTF-8. The strings file should include
# "key"="value" string pairs in the following format:
# 
# language code gocorp_swiveldriver/Resources/fr/swiveldriver.strings
#   gocorp_swiveldriver/Resources/es/swiveldriver.strings
# 
# @example Example code that uses LanguageHandler:
#   # Create a global language handler object
#   swiveldriver_lang_handler = LanguageHandler.new('swiveldriver.strings')
# 
#   # Get localized string
#   localizedStr = swiveldriver_lang_handler.GetString('String 1')
# 
# @example
#   "String 1"="Localized String 1";
#   "String 2"="Localized String 2";
# 
# @example Here's an example extension directory structure:
#   gocorp_swiveldriver.rb <- creates the SketchupExtension instance
#   gocorp_swiveldriver/
#   gocorp_swiveldriver/Resources/
#   gocorp_swiveldriver/Resources/en/swiveldriver.strings <- OPTIONAL localization files by
# 
# @version SketchUp 2014
class LanguageHandler
  # Looks up and returns the localized version of a given string, based on the
  # language SketchUp is currently running in, and the available translations
  # in the Resources folder.
  # 
  # _@param_ `key` — The key for the string to be retrieved.
  # 
  # _@return_ — the localized string.
  # 
  # ```ruby
  # swiveldriver_lang_handler = LanguageHandler.new('swiveldriver.strings')
  # localized_string = swiveldriver_lang_handler['String 1']
  # ```
  def []: (String key) -> String

  # The new method is used to create a new LanguageHandler object.
  # 
  # _@param_ `filename` — The name of the file that contains the localized strings with their keys in UTF-8 encoding.
  # 
  # _@return_ — the new LanguageHandler object
  # 
  # ```ruby
  # swiveldriver_lang_handler = LanguageHandler.new('swiveldriver.strings')
  # ```
  def initialize: (String filename) -> void

  # Returns a string containing the path to the given filename if it can be found
  # in the Resources folder.
  # 
  # _@return_ — the location of the file in the Resources folder.
  # 
  # ```ruby
  # swiveldriver_lang_handler = LanguageHandler.new('swiveldriver.strings')
  # image = swiveldriver_lang_handler.resource_path('fancy_image.png')
  # ```
  def resource_path: () -> String

  # Returns a Hash object containing the localization dictionary.
  # 
  # _@return_ — the localization dictionary.
  # 
  # ```ruby
  # swiveldriver_lang_handler = LanguageHandler.new('swiveldriver.strings')
  # hash = swiveldriver_lang_handler.strings
  # ```
  def strings: () -> ::Hash[untyped, untyped]
end

# The SketchupExtension class contains methods allowing you to create and
# manipulate SketchUp extensions. Extensions are Ruby scripts that can be
# loaded and unloaded using the Extension manager (Extensions panel of the
# Preferences dialog box). Generally you should register your ruby scripts as
# an extension to give SketchUp users the ability to disable it through the
# user interface.
# 
# The idea here is to take the ruby script that actually creates your
# functionality and place it in a folder somewhere outside of the /Plugins
# folder, most commonly a subdirectory like /Plugins/MyExtension. Then
# you create a new ruby script inside the /Plugins directory that will
# set up the extension entry and load your original script if the user
# has your extension turned on.
# 
# Here is an example extension loading script. For this example, the
# following code would be saved in /Plugins/StairTools.rb, and the
# actual plugin itself would live in /Plugins/StairTools/core.rb.
# 
# You can find two example extensions that ship with SketchUp,
# su_dynamiccomponents.rb and su_sandboxtools.rb, under the /Plugins/ folder.
# 
# @example
#   # Create an entry in the Extension list that loads a script called
#   # core.rb.
#   require 'sketchup.rb'
#   require 'extensions.rb'
# 
#   stair_extension = SketchupExtension.new('Stair Tools", "StairTools/core.rb')
#   stair_extension.version = '1.0'
#   stair_extension.description = 'Tools to draw stairs automatically.'
#   Sketchup.register_extension(stair_extension, true)
# 
# @version SketchUp 6.0
class SketchupExtension
  # Loads the extension, meaning the underlying ruby script is immediately
  # interpreted. This is the equivalent of checking the extension's checkbox
  # in the Preferences > Extensions list.
  # 
  # _@return_ — whether the load succeeded
  # 
  # ```ruby
  # # This will register the extension, a necessary step for it to appear
  # # in SketchUp's Preferences > Extensions list
  # ext_c = SketchupExtension.new('Stair Tools C', 'StairTools/core.rb')
  # Sketchup.register_extension(ext_c, false)
  # 
  # # And this will load the extension.
  # ext_c.check
  # ```
  def check: () -> bool

  # The copyright method returns the copyright string which appears beneath
  # an extension inside the Extensions Manager dialog.
  # 
  # _@return_ — the Extension copyright
  # 
  # ```ruby
  # # Create an entry in the Extension list that loads a script called
  # # core.rb.
  # extension = SketchupExtension.new('Stair Tools', 'StairTools/core.rb')
  # extension.copyright = '2008'
  # copyright = extension.copyright
  # ```
  def copyright: () -> String

  # The copyright= method sets the copyright string which appears beneath
  # an extension inside the Extensions Manager dialog.
  # 
  # _@param_ `copyright` — The copyright to set
  # 
  # _@return_ — the new copyright
  # 
  # ```ruby
  # # Create an entry in the Extension list that loads a script called
  # # core.rb.
  # extension = SketchupExtension.new('Stair Tools', 'StairTools/core.rb')
  # extension.copyright = '2008'
  # copyright = extension.copyright
  # ```
  def copyright=: (String copyright) -> String

  # The creator method returns the creator string which appears beneath
  # an extension inside the Extensions Manager dialog.
  # 
  # _@return_ — the Extension creator
  # 
  # ```ruby
  # # Create an entry in the Extension list that loads a script called
  # # core.rb.
  # extension = SketchupExtension.new('Stair Tools', 'StairTools/core.rb')
  # extension.creator = 'Trimble Navigation, Inc.'
  # creator = extension.creator
  # ```
  def creator: () -> String

  # The creator= method sets the creator string which appears beneath
  # an extension inside the Extensions Manager dialog.
  # 
  # _@param_ `creator` — The creator to set
  # 
  # _@return_ — the new creator
  # 
  # ```ruby
  # # Create an entry in the Extension list that loads a script called
  # # core.rb.
  # extension = SketchupExtension.new('Stair Tools', 'StairTools/core.rb')
  # extension.creator = 'Trimble Navigation, Inc.'
  # creator = extension.creator
  # ```
  def creator=: (String creator) -> String

  # The description method returns the long description which appears beneath
  # an extension inside the Extensions Manager dialog.
  # 
  # _@return_ — the Extension description
  # 
  # ```ruby
  # # Create an entry in the Extension list that loads a script called
  # # core.rb.
  # extension = SketchupExtension.new('Stair Tools', 'StairTools/core.rb')
  # extension.description = 'My description.'
  # description = extension.description
  # ```
  def description: () -> String

  # The description= method sets the long description which appears beneath
  # an extension inside the Extensions Manager dialog.
  # 
  # _@param_ `description` — The description string to set.
  # 
  # _@return_ — the Extension description
  # 
  # ```ruby
  # # Create an entry in the Extension list that loads a script called
  # # core.rb.
  # extension = SketchupExtension.new('Stair Tools', 'StairTools/core.rb')
  # extension.description = 'My description.'
  # description = extension.description
  # ```
  def description=: (String description) -> String

  # The extension_path method returns the file system path to the extension's
  # outer rb file.
  # 
  # _@return_ — the file system path to the extension
  def extension_path: () -> String

  # The id method returns the Extension Warehouse ID string.
  # 
  # _@return_ — the Extension Warehouse ID
  def id: () -> String

  # The new method is used to create a new SketchupExtension object. Note
  # that once the extension object is created, it will not appear in the
  # Extension Manager dialog until your register it with the
  # Sketchup.register_extension method.
  # 
  # _@param_ `title` — The name of the extension
  # 
  # _@param_ `path` — The relative path to the script that loads your plugin.
  # 
  # _@return_ — the new Extension object
  # 
  # ```ruby
  # # Create an entry in the Extension list that loads a script called
  # # core.rb.
  # extension = SketchupExtension.new('Stair Tools', 'StairTools/core')
  # 
  # # Then be sure to register it. By passing a 2nd param of true, you're
  # # telling SketchUp to load the extension by default.
  # Sketchup.register_extension(extension, true)
  # ```
  # 
  # _@note_ — It is recommended to omit the file extension provided in the +path+
  # argument. SketchUp will resolve the file extension to +.rbe+, +.rbs+
  # or +.rb+.
  def initialize: (String title, String path) -> void

  # Returns whether the extension is set to load when SketchUp starts up.
  # 
  # ```ruby
  # ext = SketchupExtension.new('Stair Tools', 'StairTools/core.rb')
  # UI.messagebox("load_on_start? is false: #{ext.load_on_start?.to_s}")
  # Sketchup.register_extension(ext, true)
  # UI.messagebox("load_on_start? is now true: #{ext.load_on_start?.to_s}")
  # ```
  def load_on_start?: () -> bool

  # Returns whether the extension is currently loaded, meaning the actual ruby
  # script that implements the extension has been evaluated.
  # 
  # ```ruby
  # ext = SketchupExtension.new('Stair Tools', 'StairTools/core.rb')
  # UI.messagebox("loaded? is false: #{ext.loaded?.to_s}")
  # Sketchup.register_extension(ext, true)
  # UI.messagebox("loaded? is now true: #{ext.loaded?.to_s}")
  # ```
  def loaded?: () -> bool

  # The name method returns the name which appears for
  # an extension inside the Extensions Manager dialog.
  # 
  # _@return_ — the Extension name
  # 
  # ```ruby
  # # Create an entry in the Extension list that loads a script called
  # # core.rb.
  # extension = SketchupExtension.new('Stair Tools', 'StairTools/core.rb')
  # name = extension.name
  # ```
  def name: () -> String

  # The name= method sets the name which appears for
  # an extension inside the Extensions Manager dialog.
  # 
  # _@param_ `name` — The new name
  # 
  # _@return_ — the Extension name
  # 
  # ```ruby
  # # Create an entry in the Extension list that loads a script called
  # # core.rb.
  # extension = SketchupExtension.new('Stair Tools', 'StairTools/core.rb')
  # extension.name = 'Renamed Stair Tools'
  # ```
  def name=: (String name) -> String

  # Returns whether the extension has been registered via
  # Sketchup.register_extension.
  # 
  # ```ruby
  # ext = SketchupExtension.new('Stair Tools', 'StairTools/core.rb')
  # UI.messagebox("My registered? is false: #{ext.registered?.to_s}")
  # Sketchup.register_extension(ext, true)
  # UI.messagebox("Now registered? is now true: #{ext.registered?.to_s}")
  # ```
  def registered?: () -> bool

  # Unloads the extension. This is the equivalent of unchecking the extension's
  # checkbox in the Preferences > Extensions list.
  # 
  # Note that technically the extension is not "unloaded" in the sense that it
  # stops running during the current SketchUp session, but the next time the
  # user restarts SketchUp, the extension will not be active.
  # 
  # _@return_ — whether the unload succeeded
  # 
  # ```ruby
  # # This unloads all extensions. The next time SketchUp starts, none of
  # # the extensions will be active.
  # Sketchup.extensions.each { |extension|
  #   extension.uncheck
  # }
  # ```
  def uncheck: () -> bool

  # The version method returns the version which appears beneath
  # an extension inside the Extensions Manager dialog.
  # 
  # _@return_ — the Extension version
  # 
  # ```ruby
  # # Create an entry in the Extension list that loads a script called
  # # core.rb.
  # extension = SketchupExtension.new('Stair Tools', 'StairTools/core.rb')
  # extension.version = '5.0'
  # version = extension.version
  # ```
  def version: () -> String

  # The version method sets the version which appears beneath
  # an extension inside the Extensions Manager dialog.
  # 
  # _@param_ `version` — The version string to set.
  # 
  # _@return_ — the Extension version
  # 
  # ```ruby
  # # Create an entry in the Extension list that loads a script called
  # # core.rb.
  # extension = SketchupExtension.new('Stair Tools', 'StairTools/core.rb')
  # extension.version = '5.0'
  # version = extension.version
  # ```
  def version=: (String version) -> String

  # The version_id method returns the Extension Warehouse Version ID string.
  # 
  # _@return_ — the Extension Warehouse Version ID string
  def version_id: () -> String
end